// WILLOW V50 CMA Workbench - Complete Netlify Function
// Purpose: Server-side FUB/CloudCMA API integration with HTML serving

const https = require('https');

// API Credentials
const FUB_API_KEY = process.env.FUB_API_KEY || 'fka_0oHt62NxmsExO6x69p08ix82zx8ii1hzrj';
const CLOUDCMA_API_KEY = process.env.CLOUDCMA_API_KEY || '742f4a46e1780904da090d721a9bae7b';
const WEBHOOK_URL = 'https://willow-v50-supervised-cma.netlify.app/.netlify/functions/cloudcma-webhook';

exports.handler = async (event, context) => {
    // CORS headers
    const headers = {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': 'Content-Type',
        'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
        'Content-Type': 'application/json'
    };

    if (event.httpMethod === 'OPTIONS') {
        return { statusCode: 200, headers, body: '' };
    }

    try {
        // Parse request
        const params = event.httpMethod === 'GET' 
            ? event.queryStringParameters || {}
            : JSON.parse(event.body || '{}');

        const action = params.action;

        // If no action parameter, serve HTML interface (Base64 decoded)
        if (!action) {
            const htmlBase64 = 'PCFET0NUWVBFIGh0bWw+CjxodG1sIGxhbmc9ImVuIj4KPGhlYWQ+CiAgICA8bWV0YSBjaGFyc2V0PSJVVEYtOCI+CiAgICA8bWV0YSBuYW1lPSJ2aWV3cG9ydCIgY29udGVudD0id2lkdGg9ZGV2aWNlLXdpZHRoLCBpbml0aWFsLXNjYWxlPTEuMCI+CiAgICA8dGl0bGU+V0lMTE9XIFY1MCAtIENNQSBXb3JrYmVuY2g8L3RpdGxlPgogICAgPCEtLSBGVUIgRW1iZWRkZWQgQXBwcyBTREsgLS0+CiAgICA8c2NyaXB0IHR5cGU9InRleHQvamF2YXNjcmlwdCIgc3JjPSJodHRwczovL2VpYS5mb2xsb3d1cGJvc3MuY29tL2VtYmVkZGVkQXBwcy12MS4wLjEuanMiPjwvc2NyaXB0PgogICAgPHN0eWxlPgogICAgICAgICogewogICAgICAgICAgICBtYXJnaW46IDA7CiAgICAgICAgICAgIHBhZGRpbmc6IDA7CiAgICAgICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7CiAgICAgICAgfQoKICAgICAgICBib2R5IHsKICAgICAgICAgICAgZm9udC1mYW1pbHk6IC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgJ1NlZ29lIFVJJywgUm9ib3RvLCBPeHlnZW4sIFVidW50dSwgQ2FudGFyZWxsLCBzYW5zLXNlcmlmOwogICAgICAgICAgICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoMTM1ZGVnLCAjNjY3ZWVhIDAlLCAjNzY0YmEyIDEwMCUpOwogICAgICAgICAgICBjb2xvcjogIzJkMzc0ODsKICAgICAgICAgICAgbGluZS1oZWlnaHQ6IDEuNjsKICAgICAgICB9CgogICAgICAgIC5jb250YWluZXIgewogICAgICAgICAgICBtYXgtd2lkdGg6IDE0MDBweDsKICAgICAgICAgICAgbWFyZ2luOiAwIGF1dG87CiAgICAgICAgICAgIHBhZGRpbmc6IDIwcHg7CiAgICAgICAgfQoKICAgICAgICAuaGVhZGVyIHsKICAgICAgICAgICAgYmFja2dyb3VuZDogd2hpdGU7CiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDEycHg7CiAgICAgICAgICAgIHBhZGRpbmc6IDIwcHggMzBweDsKICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMjBweDsKICAgICAgICAgICAgYm94LXNoYWRvdzogMCA0cHggNnB4IHJnYmEoMCwwLDAsMC4xKTsKICAgICAgICB9CgogICAgICAgIC5oZWFkZXIgaDEgewogICAgICAgICAgICBmb250LXNpemU6IDI0cHg7CiAgICAgICAgICAgIGNvbG9yOiAjNjY3ZWVhOwogICAgICAgICAgICBtYXJnaW4tYm90dG9tOiA1cHg7CiAgICAgICAgfQoKICAgICAgICAuaGVhZGVyIC5zdWJ0aXRsZSB7CiAgICAgICAgICAgIGZvbnQtc2l6ZTogMTRweDsKICAgICAgICAgICAgY29sb3I6ICM3MTgwOTY7CiAgICAgICAgfQoKICAgICAgICAudGFicyB7CiAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7CiAgICAgICAgICAgIGdhcDogMTBweDsKICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMjBweDsKICAgICAgICB9CgogICAgICAgIC50YWItYnV0dG9uIHsKICAgICAgICAgICAgZmxleDogMTsKICAgICAgICAgICAgYmFja2dyb3VuZDogd2hpdGU7CiAgICAgICAgICAgIGJvcmRlcjogbm9uZTsKICAgICAgICAgICAgcGFkZGluZzogMTVweCAyMHB4OwogICAgICAgICAgICBib3JkZXItcmFkaXVzOiAxMnB4OwogICAgICAgICAgICBmb250LXNpemU6IDE2cHg7CiAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiA2MDA7CiAgICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjsKICAgICAgICAgICAgdHJhbnNpdGlvbjogYWxsIDAuM3MgZWFzZTsKICAgICAgICAgICAgYm94LXNoYWRvdzogMCAycHggNHB4IHJnYmEoMCwwLDAsMC4xKTsKICAgICAgICB9CgogICAgICAgIC50YWItYnV0dG9uOmhvdmVyIHsKICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC0ycHgpOwogICAgICAgICAgICBib3gtc2hhZG93OiAwIDRweCA4cHggcmdiYSgwLDAsMCwwLjE1KTsKICAgICAgICB9CgogICAgICAgIC50YWItYnV0dG9uLmFjdGl2ZSB7CiAgICAgICAgICAgIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCgxMzVkZWcsICM2NjdlZWEgMCUsICM3NjRiYTIgMTAwJSk7CiAgICAgICAgICAgIGNvbG9yOiB3aGl0ZTsKICAgICAgICB9CgogICAgICAgIC50YWItY29udGVudCB7CiAgICAgICAgICAgIGRpc3BsYXk6IG5vbmU7CiAgICAgICAgICAgIGJhY2tncm91bmQ6IHdoaXRlOwogICAgICAgICAgICBib3JkZXItcmFkaXVzOiAxMnB4OwogICAgICAgICAgICBwYWRkaW5nOiAzMHB4OwogICAgICAgICAgICBib3gtc2hhZG93OiAwIDRweCA2cHggcmdiYSgwLDAsMCwwLjEpOwogICAgICAgICAgICBtaW4taGVpZ2h0OiA2MDBweDsKICAgICAgICB9CgogICAgICAgIC50YWItY29udGVudC5hY3RpdmUgewogICAgICAgICAgICBkaXNwbGF5OiBibG9jazsKICAgICAgICB9CgogICAgICAgIC5zZWN0aW9uIHsKICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMzBweDsKICAgICAgICAgICAgcGFkZGluZy1ib3R0b206IDMwcHg7CiAgICAgICAgICAgIGJvcmRlci1ib3R0b206IDJweCBzb2xpZCAjZTJlOGYwOwogICAgICAgIH0KCiAgICAgICAgLnNlY3Rpb246bGFzdC1jaGlsZCB7CiAgICAgICAgICAgIGJvcmRlci1ib3R0b206IG5vbmU7CiAgICAgICAgfQoKICAgICAgICAuc2VjdGlvbi10aXRsZSB7CiAgICAgICAgICAgIGZvbnQtc2l6ZTogMThweDsKICAgICAgICAgICAgZm9udC13ZWlnaHQ6IDcwMDsKICAgICAgICAgICAgY29sb3I6ICMyZDM3NDg7CiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDE1cHg7CiAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7CiAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7CiAgICAgICAgICAgIGdhcDogMTBweDsKICAgICAgICB9CgogICAgICAgIC5mb3JtLWdyb3VwIHsKICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMjBweDsKICAgICAgICB9CgogICAgICAgIC5mb3JtLWxhYmVsIHsKICAgICAgICAgICAgZGlzcGxheTogYmxvY2s7CiAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiA2MDA7CiAgICAgICAgICAgIGNvbG9yOiAjNGE1NTY4OwogICAgICAgICAgICBtYXJnaW4tYm90dG9tOiA4cHg7CiAgICAgICAgICAgIGZvbnQtc2l6ZTogMTRweDsKICAgICAgICB9CgogICAgICAgIC5mb3JtLWlucHV0IHsKICAgICAgICAgICAgd2lkdGg6IDEwMCU7CiAgICAgICAgICAgIHBhZGRpbmc6IDEycHggMTVweDsKICAgICAgICAgICAgYm9yZGVyOiAycHggc29saWQgI2UyZThmMDsKICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogOHB4OwogICAgICAgICAgICBmb250LXNpemU6IDE0cHg7CiAgICAgICAgICAgIHRyYW5zaXRpb246IGJvcmRlci1jb2xvciAwLjNzIGVhc2U7CiAgICAgICAgfQoKICAgICAgICAuZm9ybS1pbnB1dDpmb2N1cyB7CiAgICAgICAgICAgIG91dGxpbmU6IG5vbmU7CiAgICAgICAgICAgIGJvcmRlci1jb2xvcjogIzY2N2VlYTsKICAgICAgICB9CgogICAgICAgIC5mb3JtLXJvdyB7CiAgICAgICAgICAgIGRpc3BsYXk6IGdyaWQ7CiAgICAgICAgICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogcmVwZWF0KGF1dG8tZml0LCBtaW5tYXgoMjAwcHgsIDFmcikpOwogICAgICAgICAgICBnYXA6IDE1cHg7CiAgICAgICAgfQoKICAgICAgICAuZm9ybS1zZWxlY3QgewogICAgICAgICAgICB3aWR0aDogMTAwJTsKICAgICAgICAgICAgcGFkZGluZzogMTJweCAxNXB4OwogICAgICAgICAgICBib3JkZXI6IDJweCBzb2xpZCAjZTJlOGYwOwogICAgICAgICAgICBib3JkZXItcmFkaXVzOiA4cHg7CiAgICAgICAgICAgIGZvbnQtc2l6ZTogMTRweDsKICAgICAgICAgICAgYmFja2dyb3VuZDogd2hpdGU7CiAgICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjsKICAgICAgICB9CgogICAgICAgIC5jaGVja2JveC1ncm91cCB7CiAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7CiAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7CiAgICAgICAgICAgIGdhcDogMTBweDsKICAgICAgICAgICAgbWFyZ2luOiAxNXB4IDA7CiAgICAgICAgfQoKICAgICAgICAuY2hlY2tib3gtZ3JvdXAgaW5wdXRbdHlwZT0iY2hlY2tib3giXSB7CiAgICAgICAgICAgIHdpZHRoOiAyMHB4OwogICAgICAgICAgICBoZWlnaHQ6IDIwcHg7CiAgICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjsKICAgICAgICB9CgogICAgICAgIC5jaGVja2JveC1ncm91cCBsYWJlbCB7CiAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiA2MDA7CiAgICAgICAgICAgIGNvbG9yOiAjNGE1NTY4OwogICAgICAgICAgICBjdXJzb3I6IHBvaW50ZXI7CiAgICAgICAgfQoKICAgICAgICAuYnRuIHsKICAgICAgICAgICAgcGFkZGluZzogMTRweCAyOHB4OwogICAgICAgICAgICBib3JkZXI6IG5vbmU7CiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDhweDsKICAgICAgICAgICAgZm9udC1zaXplOiAxNnB4OwogICAgICAgICAgICBmb250LXdlaWdodDogNjAwOwogICAgICAgICAgICBjdXJzb3I6IHBvaW50ZXI7CiAgICAgICAgICAgIHRyYW5zaXRpb246IGFsbCAwLjNzIGVhc2U7CiAgICAgICAgfQoKICAgICAgICAuYnRuLXByaW1hcnkgewogICAgICAgICAgICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoMTM1ZGVnLCAjNjY3ZWVhIDAlLCAjNzY0YmEyIDEwMCUpOwogICAgICAgICAgICBjb2xvcjogd2hpdGU7CiAgICAgICAgfQoKICAgICAgICAuYnRuLXByaW1hcnk6aG92ZXIgewogICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTJweCk7CiAgICAgICAgICAgIGJveC1zaGFkb3c6IDAgNnB4IDEycHggcmdiYSgxMDIsIDEyNiwgMjM0LCAwLjMpOwogICAgICAgIH0KCiAgICAgICAgLmJ0bi1zZWNvbmRhcnkgewogICAgICAgICAgICBiYWNrZ3JvdW5kOiAjZTJlOGYwOwogICAgICAgICAgICBjb2xvcjogIzRhNTU2ODsKICAgICAgICB9CgogICAgICAgIC5idG4tc2Vjb25kYXJ5OmhvdmVyIHsKICAgICAgICAgICAgYmFja2dyb3VuZDogI2NiZDVlMDsKICAgICAgICB9CgogICAgICAgIC5idG4tZGFuZ2VyIHsKICAgICAgICAgICAgYmFja2dyb3VuZDogI2ZjODE4MTsKICAgICAgICAgICAgY29sb3I6IHdoaXRlOwogICAgICAgIH0KCiAgICAgICAgLmJ0bi1kYW5nZXI6aG92ZXIgewogICAgICAgICAgICBiYWNrZ3JvdW5kOiAjZjU2NTY1OwogICAgICAgIH0KCiAgICAgICAgLmJ0bi1ncm91cCB7CiAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7CiAgICAgICAgICAgIGdhcDogMTBweDsKICAgICAgICAgICAgbWFyZ2luLXRvcDogMjBweDsKICAgICAgICB9CgogICAgICAgIC5pbmZvLWNhcmQgewogICAgICAgICAgICBiYWNrZ3JvdW5kOiAjZjdmYWZjOwogICAgICAgICAgICBib3JkZXItbGVmdDogNHB4IHNvbGlkICM2NjdlZWE7CiAgICAgICAgICAgIHBhZGRpbmc6IDE1cHggMjBweDsKICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogOHB4OwogICAgICAgICAgICBtYXJnaW4tYm90dG9tOiAyMHB4OwogICAgICAgIH0KCiAgICAgICAgLmluZm8tY2FyZC10aXRsZSB7CiAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiA3MDA7CiAgICAgICAgICAgIGNvbG9yOiAjMmQzNzQ4OwogICAgICAgICAgICBtYXJnaW4tYm90dG9tOiA4cHg7CiAgICAgICAgfQoKICAgICAgICAuaW5mby1jYXJkLWNvbnRlbnQgewogICAgICAgICAgICBjb2xvcjogIzcxODA5NjsKICAgICAgICAgICAgZm9udC1zaXplOiAxNHB4OwogICAgICAgIH0KCiAgICAgICAgLmhvbWViZWF0LWl0ZW0gewogICAgICAgICAgICBiYWNrZ3JvdW5kOiAjZjdmYWZjOwogICAgICAgICAgICBib3JkZXItcmFkaXVzOiA4cHg7CiAgICAgICAgICAgIHBhZGRpbmc6IDIwcHg7CiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDE1cHg7CiAgICAgICAgICAgIGJvcmRlci1sZWZ0OiA0cHggc29saWQgI2UyZThmMDsKICAgICAgICB9CgogICAgICAgIC5ob21lYmVhdC1pdGVtLmhpZ2gtZW5nYWdlbWVudCB7CiAgICAgICAgICAgIGJvcmRlci1sZWZ0LWNvbG9yOiAjZjU2NTY1OwogICAgICAgICAgICBiYWNrZ3JvdW5kOiAjZmZmNWY1OwogICAgICAgIH0KCiAgICAgICAgLmhvbWViZWF0LWl0ZW0ubWVkaXVtLWVuZ2FnZW1lbnQgewogICAgICAgICAgICBib3JkZXItbGVmdC1jb2xvcjogI2VkODkzNjsKICAgICAgICAgICAgYmFja2dyb3VuZDogI2ZmZmFmMDsKICAgICAgICB9CgogICAgICAgIC5ob21lYmVhdC1pdGVtLmxvdy1lbmdhZ2VtZW50IHsKICAgICAgICAgICAgYm9yZGVyLWxlZnQtY29sb3I6ICM0Mjk5ZTE7CiAgICAgICAgICAgIGJhY2tncm91bmQ6ICNlYmY4ZmY7CiAgICAgICAgfQoKICAgICAgICAuaG9tZWJlYXQtaXRlbS5ub3QtYWNjZXB0ZWQgewogICAgICAgICAgICBib3JkZXItbGVmdC1jb2xvcjogI2EwYWVjMDsKICAgICAgICAgICAgYmFja2dyb3VuZDogI2VkZjJmNzsKICAgICAgICB9CgogICAgICAgIC5ob21lYmVhdC1oZWFkZXIgewogICAgICAgICAgICBkaXNwbGF5OiBmbGV4OwogICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47CiAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7CiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDE1cHg7CiAgICAgICAgfQoKICAgICAgICAuaG9tZWJlYXQtdGl0bGUgewogICAgICAgICAgICBmb250LXNpemU6IDE2cHg7CiAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiA3MDA7CiAgICAgICAgICAgIGNvbG9yOiAjMmQzNzQ4OwogICAgICAgIH0KCiAgICAgICAgLmVuZ2FnZW1lbnQtYmFkZ2UgewogICAgICAgICAgICBwYWRkaW5nOiA2cHggMTJweDsKICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogMjBweDsKICAgICAgICAgICAgZm9udC1zaXplOiAxMnB4OwogICAgICAgICAgICBmb250LXdlaWdodDogNzAwOwogICAgICAgICAgICB0ZXh0LXRyYW5zZm9ybTogdXBwZXJjYXNlOwogICAgICAgIH0KCiAgICAgICAgLmJhZGdlLWNyaXRpY2FsIHsKICAgICAgICAgICAgYmFja2dyb3VuZDogI2Y1NjU2NTsKICAgICAgICAgICAgY29sb3I6IHdoaXRlOwogICAgICAgIH0KCiAgICAgICAgLmJhZGdlLWhpZ2ggewogICAgICAgICAgICBiYWNrZ3JvdW5kOiAjZWQ4OTM2OwogICAgICAgICAgICBjb2xvcjogd2hpdGU7CiAgICAgICAgfQoKICAgICAgICAuYmFkZ2UtbWVkaXVtIHsKICAgICAgICAgICAgYmFja2dyb3VuZDogIzQyOTllMTsKICAgICAgICAgICAgY29sb3I6IHdoaXRlOwogICAgICAgIH0KCiAgICAgICAgLmJhZGdlLWxvdyB7CiAgICAgICAgICAgIGJhY2tncm91bmQ6ICNhMGFlYzA7CiAgICAgICAgICAgIGNvbG9yOiB3aGl0ZTsKICAgICAgICB9CgogICAgICAgIC5iYWRnZS1ub3QtYWNjZXB0ZWQgewogICAgICAgICAgICBiYWNrZ3JvdW5kOiAjNzE4MDk2OwogICAgICAgICAgICBjb2xvcjogd2hpdGU7CiAgICAgICAgfQoKICAgICAgICAuaG9tZWJlYXQtc3RhdHMgewogICAgICAgICAgICBkaXNwbGF5OiBncmlkOwogICAgICAgICAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IHJlcGVhdChhdXRvLWZpdCwgbWlubWF4KDE1MHB4LCAxZnIpKTsKICAgICAgICAgICAgZ2FwOiAxMHB4OwogICAgICAgICAgICBtYXJnaW4tYm90dG9tOiAxNXB4OwogICAgICAgIH0KCiAgICAgICAgLnN0YXQtaXRlbSB7CiAgICAgICAgICAgIGZvbnQtc2l6ZTogMTNweDsKICAgICAgICAgICAgY29sb3I6ICM0YTU1Njg7CiAgICAgICAgfQoKICAgICAgICAuc3RhdC1sYWJlbCB7CiAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiA2MDA7CiAgICAgICAgICAgIGNvbG9yOiAjNzE4MDk2OwogICAgICAgIH0KCiAgICAgICAgLmFjdGlvbi1jYXJkIHsKICAgICAgICAgICAgYmFja2dyb3VuZDogI2ZmZjVmNTsKICAgICAgICAgICAgYm9yZGVyLWxlZnQ6IDRweCBzb2xpZCAjZjU2NTY1OwogICAgICAgICAgICBib3JkZXItcmFkaXVzOiA4cHg7CiAgICAgICAgICAgIHBhZGRpbmc6IDIwcHg7CiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDIwcHg7CiAgICAgICAgfQoKICAgICAgICAuYWN0aW9uLWNhcmQuaG90IHsKICAgICAgICAgICAgYmFja2dyb3VuZDogI2ZmZmFmMDsKICAgICAgICAgICAgYm9yZGVyLWxlZnQtY29sb3I6ICNlZDg5MzY7CiAgICAgICAgfQoKICAgICAgICAuYWN0aW9uLWNhcmQud2FybSB7CiAgICAgICAgICAgIGJhY2tncm91bmQ6ICNlYmY4ZmY7CiAgICAgICAgICAgIGJvcmRlci1sZWZ0LWNvbG9yOiAjNDI5OWUxOwogICAgICAgIH0KCiAgICAgICAgLmFjdGlvbi1oZWFkZXIgewogICAgICAgICAgICBmb250LXNpemU6IDE2cHg7CiAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiA3MDA7CiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDEwcHg7CiAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7CiAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7CiAgICAgICAgICAgIGdhcDogMTBweDsKICAgICAgICB9CgogICAgICAgIC5hY3Rpb24tY29udGVudCB7CiAgICAgICAgICAgIG1hcmdpbjogMTVweCAwOwogICAgICAgICAgICBwYWRkaW5nOiAxNXB4OwogICAgICAgICAgICBiYWNrZ3JvdW5kOiB3aGl0ZTsKICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogOHB4OwogICAgICAgIH0KCiAgICAgICAgLnNjcmlwdC1ib3ggewogICAgICAgICAgICBiYWNrZ3JvdW5kOiAjZjdmYWZjOwogICAgICAgICAgICBib3JkZXI6IDFweCBzb2xpZCAjZTJlOGYwOwogICAgICAgICAgICBib3JkZXItcmFkaXVzOiA4cHg7CiAgICAgICAgICAgIHBhZGRpbmc6IDE1cHg7CiAgICAgICAgICAgIGZvbnQtc3R5bGU6IGl0YWxpYzsKICAgICAgICAgICAgY29sb3I6ICM0YTU1Njg7CiAgICAgICAgICAgIG1hcmdpbjogMTVweCAwOwogICAgICAgIH0KCiAgICAgICAgLmxvYWRpbmcgewogICAgICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7CiAgICAgICAgICAgIHBhZGRpbmc6IDQwcHg7CiAgICAgICAgICAgIGNvbG9yOiAjNzE4MDk2OwogICAgICAgIH0KCiAgICAgICAgLnNwaW5uZXIgewogICAgICAgICAgICBib3JkZXI6IDRweCBzb2xpZCAjZTJlOGYwOwogICAgICAgICAgICBib3JkZXItdG9wOiA0cHggc29saWQgIzY2N2VlYTsKICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogNTAlOwogICAgICAgICAgICB3aWR0aDogNDBweDsKICAgICAgICAgICAgaGVpZ2h0OiA0MHB4OwogICAgICAgICAgICBhbmltYXRpb246IHNwaW4gMXMgbGluZWFyIGluZmluaXRlOwogICAgICAgICAgICBtYXJnaW46IDAgYXV0byAyMHB4OwogICAgICAgIH0KCiAgICAgICAgQGtleWZyYW1lcyBzcGluIHsKICAgICAgICAgICAgMCUgeyB0cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTsgfQogICAgICAgICAgICAxMDAlIHsgdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTsgfQogICAgICAgIH0KCiAgICAgICAgLmVycm9yIHsKICAgICAgICAgICAgYmFja2dyb3VuZDogI2ZmZjVmNTsKICAgICAgICAgICAgYm9yZGVyOiAycHggc29saWQgI2ZjODE4MTsKICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogOHB4OwogICAgICAgICAgICBwYWRkaW5nOiAxNXB4OwogICAgICAgICAgICBjb2xvcjogI2M1MzAzMDsKICAgICAgICAgICAgbWFyZ2luOiAyMHB4IDA7CiAgICAgICAgfQoKICAgICAgICAuc3VjY2VzcyB7CiAgICAgICAgICAgIGJhY2tncm91bmQ6ICNmMGZmZjQ7CiAgICAgICAgICAgIGJvcmRlcjogMnB4IHNvbGlkICM2OGQzOTE7CiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDhweDsKICAgICAgICAgICAgcGFkZGluZzogMTVweDsKICAgICAgICAgICAgY29sb3I6ICMyMjU0M2Q7CiAgICAgICAgICAgIG1hcmdpbjogMjBweCAwOwogICAgICAgIH0KCiAgICAgICAgLmNvbGxhcHNpYmxlIHsKICAgICAgICAgICAgY3Vyc29yOiBwb2ludGVyOwogICAgICAgICAgICB1c2VyLXNlbGVjdDogbm9uZTsKICAgICAgICB9CgogICAgICAgIC5jb2xsYXBzaWJsZTo6YmVmb3JlIHsKICAgICAgICAgICAgY29udGVudDogJ+KWvCAnOwogICAgICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7CiAgICAgICAgICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSAwLjNzIGVhc2U7CiAgICAgICAgfQoKICAgICAgICAuY29sbGFwc2libGUuY29sbGFwc2VkOjpiZWZvcmUgewogICAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgtOTBkZWcpOwogICAgICAgIH0KCiAgICAgICAgLmNvbGxhcHNpYmxlLWNvbnRlbnQgewogICAgICAgICAgICBtYXgtaGVpZ2h0OiAxMDAwcHg7CiAgICAgICAgICAgIG92ZXJmbG93OiBoaWRkZW47CiAgICAgICAgICAgIHRyYW5zaXRpb246IG1heC1oZWlnaHQgMC4zcyBlYXNlOwogICAgICAgIH0KCiAgICAgICAgLmNvbGxhcHNpYmxlLWNvbnRlbnQuaGlkZGVuIHsKICAgICAgICAgICAgbWF4LWhlaWdodDogMDsKICAgICAgICB9CgogICAgICAgIC5zdW1tYXJ5LWdyaWQgewogICAgICAgICAgICBkaXNwbGF5OiBncmlkOwogICAgICAgICAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IHJlcGVhdChhdXRvLWZpdCwgbWlubWF4KDIwMHB4LCAxZnIpKTsKICAgICAgICAgICAgZ2FwOiAxNXB4OwogICAgICAgICAgICBtYXJnaW46IDIwcHggMDsKICAgICAgICB9CgogICAgICAgIC5zdW1tYXJ5LWNhcmQgewogICAgICAgICAgICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoMTM1ZGVnLCAjNjY3ZWVhIDAlLCAjNzY0YmEyIDEwMCUpOwogICAgICAgICAgICBjb2xvcjogd2hpdGU7CiAgICAgICAgICAgIHBhZGRpbmc6IDIwcHg7CiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDhweDsKICAgICAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyOwogICAgICAgIH0KCiAgICAgICAgLnN1bW1hcnktbnVtYmVyIHsKICAgICAgICAgICAgZm9udC1zaXplOiAzMnB4OwogICAgICAgICAgICBmb250LXdlaWdodDogNzAwOwogICAgICAgICAgICBtYXJnaW4tYm90dG9tOiA1cHg7CiAgICAgICAgfQoKICAgICAgICAuc3VtbWFyeS1sYWJlbCB7CiAgICAgICAgICAgIGZvbnQtc2l6ZTogMTRweDsKICAgICAgICAgICAgb3BhY2l0eTogMC45OwogICAgICAgIH0KCiAgICAgICAgLnJlc2VuZC13YXJuaW5nIHsKICAgICAgICAgICAgYmFja2dyb3VuZDogI2ZmZmFmMDsKICAgICAgICAgICAgYm9yZGVyOiAycHggc29saWQgI2VkODkzNjsKICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogOHB4OwogICAgICAgICAgICBwYWRkaW5nOiAxMnB4IDE1cHg7CiAgICAgICAgICAgIG1hcmdpbjogMTBweCAwOwogICAgICAgICAgICBkaXNwbGF5OiBmbGV4OwogICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyOwogICAgICAgICAgICBnYXA6IDEwcHg7CiAgICAgICAgICAgIGZvbnQtc2l6ZTogMTNweDsKICAgICAgICAgICAgY29sb3I6ICM3NDQyMTA7CiAgICAgICAgfQoKICAgICAgICAucmVzZW5kLXdhcm5pbmc6OmJlZm9yZSB7CiAgICAgICAgICAgIGNvbnRlbnQ6ICfimqDvuI8nOwogICAgICAgICAgICBmb250LXNpemU6IDE4cHg7CiAgICAgICAgfQogICAgPC9zdHlsZT4KPC9oZWFkPgo8Ym9keT4KICAgIDxkaXYgY2xhc3M9ImNvbnRhaW5lciI+CiAgICAgICAgPGRpdiBjbGFzcz0iaGVhZGVyIj4KICAgICAgICAgICAgPGgxPvCfjq8gV0lMTE9XIFY1MCAtIENNQSBXb3JrYmVuY2g8L2gxPgogICAgICAgICAgICA8ZGl2IGNsYXNzPSJzdWJ0aXRsZSI+SG9tZWJlYXQtQ2VudHJpYyBJbnRlbGxpZ2VuY2UgfCBMZWFkOiA8c3BhbiBpZD0ibGVhZE5hbWUiPkxvYWRpbmcuLi48L3NwYW4+PC9kaXY+CiAgICAgICAgPC9kaXY+CgogICAgICAgIDxkaXYgY2xhc3M9InRhYnMiPgogICAgICAgICAgICA8YnV0dG9uIGNsYXNzPSJ0YWItYnV0dG9uIGFjdGl2ZSIgb25jbGljaz0ic3dpdGNoVGFiKCdjbWEtd29ya2JlbmNoJykiPgogICAgICAgICAgICAgICAg8J+TiiBDTUEgV29ya2JlbmNoCiAgICAgICAgICAgIDwvYnV0dG9uPgogICAgICAgICAgICA8YnV0dG9uIGNsYXNzPSJ0YWItYnV0dG9uIiBvbmNsaWNrPSJzd2l0Y2hUYWIoJ2hvbWViZWF0LW1hbmFnZXInKSI+CiAgICAgICAgICAgICAgICDwn4+gIEhvbWViZWF0IE1hbmFnZXIKICAgICAgICAgICAgPC9idXR0b24+CiAgICAgICAgICAgIDxidXR0b24gY2xhc3M9InRhYi1idXR0b24iIG9uY2xpY2s9InN3aXRjaFRhYignYWN0aW9uLXBsYW5uZXInKSI+CiAgICAgICAgICAgICAgICDimqEgQWN0aW9uIFBsYW5uZXIKICAgICAgICAgICAgPC9idXR0b24+CiAgICAgICAgPC9kaXY+CgogICAgICAgIDwhLS0gVEFCIDE6IENNQSBXT1JLQkVOQ0ggLS0+CiAgICAgICAgPGRpdiBpZD0iY21hLXdvcmtiZW5jaCIgY2xhc3M9InRhYi1jb250ZW50IGFjdGl2ZSI+CiAgICAgICAgICAgIDxkaXYgY2xhc3M9InNlY3Rpb24iPgogICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0ic2VjdGlvbi10aXRsZSI+8J+TiyBFeGlzdGluZyBDTUEgU3RhdHVzPC9kaXY+CiAgICAgICAgICAgICAgICA8ZGl2IGlkPSJleGlzdGluZ0NNQSIgY2xhc3M9ImluZm8tY2FyZCI+CiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0ibG9hZGluZyI+CiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InNwaW5uZXIiPjwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICBMb2FkaW5nIENNQSBkYXRhLi4uCiAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgPC9kaXY+CgogICAgICAgICAgICA8ZGl2IGNsYXNzPSJzZWN0aW9uIj4KICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InNlY3Rpb24tdGl0bGUiPvCfmoAgR2VuZXJhdGUgTmV3IENNQTwvZGl2PgogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJmb3JtLWdyb3VwIj4KICAgICAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9ImZvcm0tbGFiZWwiPlByb3BlcnR5IEFkZHJlc3MgKjwvbGFiZWw+CiAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9InRleHQiIGlkPSJjbWFBZGRyZXNzIiBjbGFzcz0iZm9ybS1pbnB1dCIgcGxhY2Vob2xkZXI9IjEyMyBNYWluIFN0LCBIdW50aW5ndG9uIEJlYWNoLCBDQSA5MjY0OCI+CiAgICAgICAgICAgICAgICA8L2Rpdj4KCiAgICAgICAgICAgICAgICA8ZGl2IGlkPSJhdXRvT3B0aW1pemVkUGFyYW1zIiBjbGFzcz0iaW5mby1jYXJkIj4KICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJpbmZvLWNhcmQtdGl0bGUiPkF1dG8tT3B0aW1pemVkIFBhcmFtZXRlcnMgKEJhc2VkIG9uIEJlaGF2aW9yYWwgU2NvcmU6IDxzcGFuIGlkPSJiZWhhdmlvcmFsU2NvcmUiPi0tPC9zcGFuPik8L2Rpdj4KICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJpbmZvLWNhcmQtY29udGVudCI+CiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImZvcm0tcm93IiBzdHlsZT0ibWFyZ2luLXRvcDogMTVweDsiPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9ImZvcm0tbGFiZWwiPkJlZHM8L2xhYmVsPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPSJudW1iZXIiIGlkPSJjbWFCZWRzIiBjbGFzcz0iZm9ybS1pbnB1dCIgdmFsdWU9IjMiPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2PgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz0iZm9ybS1sYWJlbCI+QmF0aHM8L2xhYmVsPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPSJudW1iZXIiIGlkPSJjbWFCYXRocyIgY2xhc3M9ImZvcm0taW5wdXQiIHZhbHVlPSIyIj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9ImZvcm0tbGFiZWwiPlNxRnQ8L2xhYmVsPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPSJudW1iZXIiIGlkPSJjbWFTcWZ0IiBjbGFzcz0iZm9ybS1pbnB1dCIgdmFsdWU9IjIwMDAiPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJmb3JtLXJvdyIgc3R5bGU9Im1hcmdpbi10b3A6IDE1cHg7Ij4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXY+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPSJmb3JtLWxhYmVsIj5TZWFyY2ggUmFkaXVzIChtaSkg8J+kljwvbGFiZWw+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9Im51bWJlciIgc3RlcD0iMC4yNSIgaWQ9ImNtYVJhZGl1cyIgY2xhc3M9ImZvcm0taW5wdXQiIHZhbHVlPSIwLjc1IiByZWFkb25seT4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c21hbGwgc3R5bGU9ImNvbG9yOiAjNzE4MDk2OyI+U2NvcmUtb3B0aW1pemVkPC9zbWFsbD4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9ImZvcm0tbGFiZWwiPk1vbnRocyBCYWNrIPCfpJY8L2xhYmVsPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPSJudW1iZXIiIGlkPSJjbWFNb250aHNCYWNrIiBjbGFzcz0iZm9ybS1pbnB1dCIgdmFsdWU9IjkiIHJlYWRvbmx5PgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzbWFsbCBzdHlsZT0iY29sb3I6ICM3MTgwOTY7Ij5TY29yZS1vcHRpbWl6ZWQ8L3NtYWxsPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2PgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz0iZm9ybS1sYWJlbCI+TWluIENvbXBhcmFibGVzPC9sYWJlbD4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT0ibnVtYmVyIiBpZD0iY21hTWluTGlzdGluZ3MiIGNsYXNzPSJmb3JtLWlucHV0IiB2YWx1ZT0iMTAiPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgPC9kaXY+CgogICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iY29sbGFwc2libGUgY29sbGFwc2VkIiBvbmNsaWNrPSJ0b2dnbGVDb2xsYXBzaWJsZSh0aGlzKSI+CiAgICAgICAgICAgICAgICAgICAgPHNwYW4gc3R5bGU9ImZvbnQtd2VpZ2h0OiA2MDA7IGNvbG9yOiAjNjY3ZWVhOyI+RWRpdCBQYXJhbWV0ZXJzIE1hbnVhbGx5PC9zcGFuPgogICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJjb2xsYXBzaWJsZS1jb250ZW50IGhpZGRlbiI+CiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iZm9ybS1yb3ciIHN0eWxlPSJtYXJnaW4tdG9wOiAxNXB4OyI+CiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXY+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9ImZvcm0tbGFiZWwiPlByb3BlcnR5IFR5cGU8L2xhYmVsPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNlbGVjdCBpZD0iY21hUHJvcFR5cGUiIGNsYXNzPSJmb3JtLXNlbGVjdCI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT0iIj5Bbnk8L29wdGlvbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPSJSZXNpZGVudGlhbCI+UmVzaWRlbnRpYWw8L29wdGlvbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPSJSZXNpZGVudGlhbCBJbmNvbWUiPlJlc2lkZW50aWFsIEluY29tZTwvb3B0aW9uPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9IkxhbmQiPkxhbmQ8L29wdGlvbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPSJNYW51ZmFjdHVyZWQgSW4gUGFyayI+TWFudWZhY3R1cmVkIEluIFBhcms8L29wdGlvbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc2VsZWN0PgogICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgICAgICAgICAgPGRpdj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz0iZm9ybS1sYWJlbCI+VmFyaWFuY2UgKCUpPC9sYWJlbD4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPSJudW1iZXIiIGlkPSJjbWFWYXJpYW5jZSIgY2xhc3M9ImZvcm0taW5wdXQiIHZhbHVlPSIxMCI+CiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgPC9kaXY+CgogICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iZm9ybS1ncm91cCIgc3R5bGU9Im1hcmdpbi10b3A6IDIwcHg7Ij4KICAgICAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9ImZvcm0tbGFiZWwiPkNNQSBUaXRsZSAoT3B0aW9uYWwpPC9sYWJlbD4KICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT0idGV4dCIgaWQ9ImNtYVRpdGxlIiBjbGFzcz0iZm9ybS1pbnB1dCIgcGxhY2Vob2xkZXI9IkxlYXZlIGJsYW5rIHRvIGF1dG8tZ2VuZXJhdGUiPgogICAgICAgICAgICAgICAgPC9kaXY+CgogICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iY2hlY2tib3gtZ3JvdXAiPgogICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPSJjaGVja2JveCIgaWQ9ImNyZWF0ZUhvbWViZWF0IiBjaGVja2VkPgogICAgICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9ImNyZWF0ZUhvbWViZWF0Ij5DcmVhdGUgSG9tZWJlYXQgd2l0aCB0aGlzIENNQTwvbGFiZWw+CiAgICAgICAgICAgICAgICA8L2Rpdj4KCiAgICAgICAgICAgICAgICA8ZGl2IGlkPSJob21lYmVhdE9wdGlvbnMiIGNsYXNzPSJmb3JtLWdyb3VwIj4KICAgICAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9ImZvcm0tbGFiZWwiPkhvbWViZWF0IEZyZXF1ZW5jeTwvbGFiZWw+CiAgICAgICAgICAgICAgICAgICAgPHNlbGVjdCBpZD0iaG9tZWJlYXRGcmVxdWVuY3kiIGNsYXNzPSJmb3JtLXNlbGVjdCI+CiAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9InF1YXJ0ZXJseSI+UXVhcnRlcmx5PC9vcHRpb24+CiAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9Im1vbnRobHkiPk1vbnRobHk8L29wdGlvbj4KICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT0ic2VtaS1hbm51YWxseSI+U2VtaS1Bbm51YWxseTwvb3B0aW9uPgogICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPSJhbm51YWxseSI+QW5udWFsbHk8L29wdGlvbj4KICAgICAgICAgICAgICAgICAgICA8L3NlbGVjdD4KICAgICAgICAgICAgICAgIDwvZGl2PgoKICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImJ0bi1ncm91cCI+CiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz0iYnRuIGJ0bi1wcmltYXJ5IiBvbmNsaWNrPSJnZW5lcmF0ZUNNQSgpIj4KICAgICAgICAgICAgICAgICAgICAgICAg8J+agCBHRU5FUkFURSBDTUEgJiBDUkVBVEUgSE9NRUJFQVQKICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj4KICAgICAgICAgICAgICAgIDwvZGl2PgoKICAgICAgICAgICAgICAgIDxkaXYgaWQ9ImNtYVJlc3VsdCI+PC9kaXY+CiAgICAgICAgICAgIDwvZGl2PgogICAgICAgIDwvZGl2PgoKICAgICAgICA8IS0tIFRBQiAyOiBIT01FQkVBVCBNQU5BR0VSIC0tPgogICAgICAgIDxkaXYgaWQ9ImhvbWViZWF0LW1hbmFnZXIiIGNsYXNzPSJ0YWItY29udGVudCI+CiAgICAgICAgICAgIDxkaXYgY2xhc3M9InNlY3Rpb24iPgogICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0ic2VjdGlvbi10aXRsZSI+8J+PoCBBY3RpdmUgSG9tZWJlYXRzPC9kaXY+CiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImJ0bi1ncm91cCI+CiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz0iYnRuIGJ0bi1wcmltYXJ5IiBvbmNsaWNrPSJyZWZyZXNoSG9tZWJlYXRBbmFseXRpY3MoKSI+CiAgICAgICAgICAgICAgICAgICAgICAgIPCflIQgUmVmcmVzaCBBbmFseXRpY3MKICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj4KICAgICAgICAgICAgICAgIDwvZGl2PgoKICAgICAgICAgICAgICAgIDxkaXYgaWQ9ImhvbWViZWF0TGlzdCIgY2xhc3M9ImxvYWRpbmciIHN0eWxlPSJtYXJnaW4tdG9wOiAyMHB4OyI+CiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0ic3Bpbm5lciI+PC9kaXY+CiAgICAgICAgICAgICAgICAgICAgTG9hZGluZyBIb21lYmVhdCBkYXRhLi4uCiAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgPC9kaXY+CgogICAgICAgICAgICA8ZGl2IGNsYXNzPSJzZWN0aW9uIj4KICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InNlY3Rpb24tdGl0bGUiPvCfk4ogRW5nYWdlbWVudCBTdW1tYXJ5PC9kaXY+CiAgICAgICAgICAgICAgICA8ZGl2IGlkPSJlbmdhZ2VtZW50U3VtbWFyeSIgY2xhc3M9InN1bW1hcnktZ3JpZCI+CiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0ic3VtbWFyeS1jYXJkIj4KICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0ic3VtbWFyeS1udW1iZXIiIGlkPSJoaWdoRW5nYWdlbWVudENvdW50Ij4wPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InN1bW1hcnktbGFiZWwiPkhpZ2ggRW5nYWdlbWVudCAoMjArIHZpZXdzKTwvZGl2PgogICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InN1bW1hcnktY2FyZCI+CiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InN1bW1hcnktbnVtYmVyIiBpZD0ibWVkaXVtRW5nYWdlbWVudENvdW50Ij4wPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InN1bW1hcnktbGFiZWwiPk1lZGl1bSBFbmdhZ2VtZW50ICg1LTE5IHZpZXdzKTwvZGl2PgogICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InN1bW1hcnktY2FyZCI+CiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InN1bW1hcnktbnVtYmVyIiBpZD0ibG93RW5nYWdlbWVudENvdW50Ij4wPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InN1bW1hcnktbGFiZWwiPkxvdyBFbmdhZ2VtZW50ICgxLTQgdmlld3MpPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0ic3VtbWFyeS1jYXJkIj4KICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0ic3VtbWFyeS1udW1iZXIiIGlkPSJub3RBY2NlcHRlZENvdW50Ij4wPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InN1bW1hcnktbGFiZWwiPk5vdCBBY2NlcHRlZCAoMCB2aWV3cyk8L2Rpdj4KICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICA8L2Rpdj4KICAgICAgICA8L2Rpdj4KCiAgICAgICAgPCEtLSBUQUIgMzogQUNUSU9OIFBMQU5ORVIgLS0+CiAgICAgICAgPGRpdiBpZD0iYWN0aW9uLXBsYW5uZXIiIGNsYXNzPSJ0YWItY29udGVudCI+CiAgICAgICAgICAgIDxkaXYgY2xhc3M9InNlY3Rpb24iPgogICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0ic2VjdGlvbi10aXRsZSI+4pqhIFRyaWdnZXJlZCBBY3Rpb25zIChCYXNlZCBvbiBFbmdhZ2VtZW50KTwvZGl2PgogICAgICAgICAgICAgICAgPGRpdiBpZD0idHJpZ2dlcmVkQWN0aW9ucyI+CiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0ibG9hZGluZyI+CiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InNwaW5uZXIiPjwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICBBbmFseXppbmcgZW5nYWdlbWVudCBkYXRhLi4uCiAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgPC9kaXY+CgogICAgICAgICAgICA8ZGl2IGNsYXNzPSJzZWN0aW9uIj4KICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InNlY3Rpb24tdGl0bGUiPvCfk50gTWFudWFsIEFjdGlvbiBDcmVhdGlvbjwvZGl2PgogICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iZm9ybS1yb3ciPgogICAgICAgICAgICAgICAgICAgIDxkaXY+CiAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz0iZm9ybS1sYWJlbCI+QWN0aW9uIFR5cGU8L2xhYmVsPgogICAgICAgICAgICAgICAgICAgICAgICA8c2VsZWN0IGlkPSJhY3Rpb25UeXBlIiBjbGFzcz0iZm9ybS1zZWxlY3QiPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT0iVGFzayI+VGFzazwvb3B0aW9uPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT0iQ2FsbCI+Q2FsbDwvb3B0aW9uPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT0iRW1haWwiPkVtYWlsPC9vcHRpb24+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPSJOb3RlIj5Ob3RlPC9vcHRpb24+CiAgICAgICAgICAgICAgICAgICAgICAgIDwvc2VsZWN0PgogICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgIDxkaXY+CiAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz0iZm9ybS1sYWJlbCI+QXNzaWduIFRvPC9sYWJlbD4KICAgICAgICAgICAgICAgICAgICAgICAgPHNlbGVjdCBpZD0iYXNzaWduVG8iIGNsYXNzPSJmb3JtLXNlbGVjdCI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPSJHbGVubiI+R2xlbm48L29wdGlvbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9Ikp1c3RpbiI+SnVzdGluPC9vcHRpb24+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPSJIZWF0aGVyIj5IZWF0aGVyPC9vcHRpb24+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPSJMbG95ZCI+TGxveWQ8L29wdGlvbj4KICAgICAgICAgICAgICAgICAgICAgICAgPC9zZWxlY3Q+CiAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgPGRpdj4KICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPSJmb3JtLWxhYmVsIj5VcmdlbmN5PC9sYWJlbD4KICAgICAgICAgICAgICAgICAgICAgICAgPHNlbGVjdCBpZD0idXJnZW5jeSIgY2xhc3M9ImZvcm0tc2VsZWN0Ij4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9IklNTUVESUFURSI+SW1tZWRpYXRlICgyNGgpPC9vcHRpb24+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPSJTQU1FX0RBWSI+U2FtZSBEYXk8L29wdGlvbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9Ik5FWFRfREFZIj5OZXh0IERheTwvb3B0aW9uPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT0iV0VFS0xZIj5UaGlzIFdlZWs8L29wdGlvbj4KICAgICAgICAgICAgICAgICAgICAgICAgPC9zZWxlY3Q+CiAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImZvcm0tZ3JvdXAiIHN0eWxlPSJtYXJnaW4tdG9wOiAxNXB4OyI+CiAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPSJmb3JtLWxhYmVsIj5Ob3RlczwvbGFiZWw+CiAgICAgICAgICAgICAgICAgICAgPHRleHRhcmVhIGlkPSJhY3Rpb25Ob3RlcyIgY2xhc3M9ImZvcm0taW5wdXQiIHJvd3M9IjMiIHBsYWNlaG9sZGVyPSJFbnRlciBhY3Rpb24gZGV0YWlscy4uLiI+PC90ZXh0YXJlYT4KICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz0iYnRuIGJ0bi1wcmltYXJ5IiBvbmNsaWNrPSJjcmVhdGVNYW51YWxBY3Rpb24oKSI+CiAgICAgICAgICAgICAgICAgICAg4pyFIENSRUFURSBBQ1RJT04gSU4gRlVCCiAgICAgICAgICAgICAgICA8L2J1dHRvbj4KICAgICAgICAgICAgICAgIDxkaXYgaWQ9Im1hbnVhbEFjdGlvblJlc3VsdCI+PC9kaXY+CiAgICAgICAgICAgIDwvZGl2PgogICAgICAgIDwvZGl2PgogICAgPC9kaXY+CgogICAgPHNjcmlwdD4KICAgICAgICAvLyBHbG9iYWwgc3RhdGUKICAgICAgICBjb25zdCBBUElfQkFTRV9VUkwgPSAnaHR0cHM6Ly93aWxsb3ctdjUwLXN1cGVydmlzZWQtY21hLm5ldGxpZnkuYXBwJzsKICAgICAgICBsZXQgcGVyc29uSWQgPSBudWxsOwogICAgICAgIGxldCBwZXJzb25EYXRhID0gbnVsbDsKICAgICAgICBsZXQgaG9tZWJlYXREYXRhID0gbnVsbDsKCiAgICAgICAgLy8gSW5pdGlhbGl6ZSBhcHAKICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGFzeW5jICgpID0+IHsKICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSBGVUIgRW1iZWRkZWQgQXBwcyBTREsgYW5kIGdldCBwZXJzb24gY29udGV4dAogICAgICAgICAgICBpZiAod2luZG93LkVtYmVkZGVkQXBwcykgewogICAgICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICAgICAgICBhd2FpdCB3aW5kb3cuRW1iZWRkZWRBcHBzLmluaXQoKTsKICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygn4pyFIEZVQiBTREsgaW5pdGlhbGl6ZWQnKTsKICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAvLyBHZXQgY29udGV4dCBmcm9tIEZVQiBwYXJlbnQgd2luZG93CiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IGF3YWl0IHdpbmRvdy5FbWJlZGRlZEFwcHMuZ2V0Q29udGV4dCgpOwogICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5OmIEZVQiBDb250ZXh0OicsIGNvbnRleHQpOwogICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgcGVyc29uX2lkIGZyb20gY29udGV4dAogICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQucGVyc29uICYmIGNvbnRleHQucGVyc29uLmlkKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNvbklkID0gY29udGV4dC5wZXJzb24uaWQ7CiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCfinIUgR290IHBlcnNvbl9pZCBmcm9tIEZVQiBjb250ZXh0OicsIHBlcnNvbklkKTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikgewogICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybign4pqg77iPIEZVQiBTREsgZXJyb3I6JywgZXJyb3IpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIAogICAgICAgICAgICAvLyBGYWxsYmFjayB0byBVUkwgcGFyYW1ldGVyIGlmIFNESyBkaWRuJ3QgcHJvdmlkZSBwZXJzb25faWQKICAgICAgICAgICAgaWYgKCFwZXJzb25JZCkgewogICAgICAgICAgICAgICAgY29uc3QgdXJsUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh3aW5kb3cubG9jYXRpb24uc2VhcmNoKTsKICAgICAgICAgICAgICAgIHBlcnNvbklkID0gdXJsUGFyYW1zLmdldCgncGVyc29uX2lkJyk7CiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygn4pqg77iPIFVzaW5nIFVSTCBwZXJzb25faWQgKGZhbGxiYWNrKTonLCBwZXJzb25JZCk7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGlmICghcGVyc29uSWQpIHsKICAgICAgICAgICAgICAgIHNob3dFcnJvcignTm8gcGVyc29uIElEIHByb3ZpZGVkIGluIEZVQiBjb250ZXh0IG9yIFVSTCcpOwogICAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICB9CgogICAgICAgICAgICBhd2FpdCBsb2FkUGVyc29uRGF0YSgpOwogICAgICAgICAgICBhd2FpdCBsb2FkSG9tZWJlYXREYXRhKCk7CiAgICAgICAgfSk7CgogICAgICAgIC8vIFRhYiBzd2l0Y2hpbmcKICAgICAgICBmdW5jdGlvbiBzd2l0Y2hUYWIodGFiSWQpIHsKICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnRhYi1jb250ZW50JykuZm9yRWFjaCh0YWIgPT4gdGFiLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpKTsKICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnRhYi1idXR0b24nKS5mb3JFYWNoKGJ0biA9PiBidG4uY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJykpOwogICAgICAgICAgICAKICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGFiSWQpLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpOwogICAgICAgICAgICBldmVudC50YXJnZXQuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7CgogICAgICAgICAgICAvLyBSZWZyZXNoIGRhdGEgd2hlbiBzd2l0Y2hpbmcgdG8gc3BlY2lmaWMgdGFicwogICAgICAgICAgICBpZiAodGFiSWQgPT09ICdob21lYmVhdC1tYW5hZ2VyJykgewogICAgICAgICAgICAgICAgcmVmcmVzaEhvbWViZWF0QW5hbHl0aWNzKCk7CiAgICAgICAgICAgIH0gZWxzZSBpZiAodGFiSWQgPT09ICdhY3Rpb24tcGxhbm5lcicpIHsKICAgICAgICAgICAgICAgIGdlbmVyYXRlVHJpZ2dlcmVkQWN0aW9ucygpOwogICAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICAvLyBUb2dnbGUgY29sbGFwc2libGUgc2VjdGlvbnMKICAgICAgICBmdW5jdGlvbiB0b2dnbGVDb2xsYXBzaWJsZShlbGVtZW50KSB7CiAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZSgnY29sbGFwc2VkJyk7CiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBlbGVtZW50Lm5leHRFbGVtZW50U2libGluZzsKICAgICAgICAgICAgY29udGVudC5jbGFzc0xpc3QudG9nZ2xlKCdoaWRkZW4nKTsKICAgICAgICB9CgogICAgICAgIC8vIExvYWQgcGVyc29uIGRhdGEgZnJvbSBGVUIKICAgICAgICBhc3luYyBmdW5jdGlvbiBsb2FkUGVyc29uRGF0YSgpIHsKICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS8ubmV0bGlmeS9mdW5jdGlvbnMvd2lsbG93LWNtYS13b3JrYmVuY2g/YWN0aW9uPWdldFBlcnNvbkRhdGEmcGVyc29uSWQ9JHtwZXJzb25JZH1gKTsKICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7CiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgIGlmIChkYXRhLmVycm9yKSB7CiAgICAgICAgICAgICAgICAgICAgc2hvd0Vycm9yKGRhdGEuZXJyb3IpOwogICAgICAgICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICBwZXJzb25EYXRhID0gZGF0YTsKICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsZWFkTmFtZScpLnRleHRDb250ZW50ID0gZGF0YS5uYW1lIHx8ICdVbmtub3duJzsKICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgLy8gVXBkYXRlIGJlaGF2aW9yYWwgc2NvcmUKICAgICAgICAgICAgICAgIGNvbnN0IHNjb3JlID0gZGF0YS5jdXN0b21XSUxMT1dCZWhhdmlvcmFsU2NvcmVWNDAgfHwgNTA7CiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYmVoYXZpb3JhbFNjb3JlJykudGV4dENvbnRlbnQgPSBgJHtzY29yZX0vMTAwYDsKICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgLy8gQXV0by1vcHRpbWl6ZSBwYXJhbWV0ZXJzIGJhc2VkIG9uIHNjb3JlCiAgICAgICAgICAgICAgICBvcHRpbWl6ZUNNQVBhcmFtZXRlcnMoc2NvcmUpOwogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAvLyBEaXNwbGF5IGV4aXN0aW5nIENNQSBpZiBhdmFpbGFibGUKICAgICAgICAgICAgICAgIGRpc3BsYXlFeGlzdGluZ0NNQShkYXRhKTsKICAgICAgICAgICAgICAgIAogICAgICAgICAgICB9IGNhdGNoIChlcnJvcikgewogICAgICAgICAgICAgICAgc2hvd0Vycm9yKCdGYWlsZWQgdG8gbG9hZCBwZXJzb24gZGF0YTogJyArIGVycm9yLm1lc3NhZ2UpOwogICAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICAvLyBPcHRpbWl6ZSBDTUEgcGFyYW1ldGVycyBiYXNlZCBvbiBiZWhhdmlvcmFsIHNjb3JlCiAgICAgICAgZnVuY3Rpb24gb3B0aW1pemVDTUFQYXJhbWV0ZXJzKHNjb3JlKSB7CiAgICAgICAgICAgIGxldCByYWRpdXMsIG1vbnRoc0JhY2s7CiAgICAgICAgICAgIAogICAgICAgICAgICBpZiAoc2NvcmUgPj0gOTApIHsKICAgICAgICAgICAgICAgIHJhZGl1cyA9IDAuMjU7CiAgICAgICAgICAgICAgICBtb250aHNCYWNrID0gMzsKICAgICAgICAgICAgfSBlbHNlIGlmIChzY29yZSA+PSA3NSkgewogICAgICAgICAgICAgICAgcmFkaXVzID0gMC41OwogICAgICAgICAgICAgICAgbW9udGhzQmFjayA9IDY7CiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2NvcmUgPj0gNjApIHsKICAgICAgICAgICAgICAgIHJhZGl1cyA9IDAuNzU7CiAgICAgICAgICAgICAgICBtb250aHNCYWNrID0gOTsKICAgICAgICAgICAgfSBlbHNlIGlmIChzY29yZSA+PSA0MCkgewogICAgICAgICAgICAgICAgcmFkaXVzID0gMS4wOwogICAgICAgICAgICAgICAgbW9udGhzQmFjayA9IDEyOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgcmFkaXVzID0gMS41OwogICAgICAgICAgICAgICAgbW9udGhzQmFjayA9IDE4OwogICAgICAgICAgICB9CiAgICAgICAgICAgIAogICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY21hUmFkaXVzJykudmFsdWUgPSByYWRpdXM7CiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjbWFNb250aHNCYWNrJykudmFsdWUgPSBtb250aHNCYWNrOwogICAgICAgIH0KCiAgICAgICAgLy8gRGlzcGxheSBleGlzdGluZyBDTUEKICAgICAgICBmdW5jdGlvbiBkaXNwbGF5RXhpc3RpbmdDTUEoZGF0YSkgewogICAgICAgICAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZXhpc3RpbmdDTUEnKTsKICAgICAgICAgICAgCiAgICAgICAgICAgIGlmIChkYXRhLmN1c3RvbVdJTExPV0NNQURhdGUgJiYgZGF0YS5jdXN0b21XSUxMT1dDTUFMaW5rKSB7CiAgICAgICAgICAgICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gYAogICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImluZm8tY2FyZC10aXRsZSI+TGFzdCBDTUEgR2VuZXJhdGVkPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iaW5mby1jYXJkLWNvbnRlbnQiPgogICAgICAgICAgICAgICAgICAgICAgICA8ZGl2PjxzdHJvbmc+RGF0ZTo8L3N0cm9uZz4gJHtuZXcgRGF0ZShkYXRhLmN1c3RvbVdJTExPV0NNQURhdGUpLnRvTG9jYWxlRGF0ZVN0cmluZygpfTwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICA8ZGl2PjxzdHJvbmc+UHJvcGVydHk6PC9zdHJvbmc+ICR7ZGF0YS5jdXN0b21XSUxMT1dDTUFBZGRyZXNzIHx8ICdOL0EnfTwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICA8ZGl2PjxzdHJvbmc+RXN0aW1hdGVkIFZhbHVlOjwvc3Ryb25nPiAke2RhdGEuY3VzdG9tV0lMTE9XQ2VudGVyVmFsdWUgPyAnJCcgKyBwYXJzZUludChkYXRhLmN1c3RvbVdJTExPV0NlbnRlclZhbHVlKS50b0xvY2FsZVN0cmluZygpIDogJ04vQSd9PC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImJ0bi1ncm91cCIgc3R5bGU9Im1hcmdpbi10b3A6IDE1cHg7Ij4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9ImJ0biBidG4tc2Vjb25kYXJ5IiBvbmNsaWNrPSJ3aW5kb3cub3BlbignJHtkYXRhLmN1c3RvbVdJTExPV0NNQUxpbmt9JywgJ19ibGFuaycpIj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDwn5OEIFZpZXcgQ01BCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9ImJ0biBidG4tc2Vjb25kYXJ5IiBvbmNsaWNrPSJyZWdlbmVyYXRlQ01BKCkiPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIPCflIQgUmVnZW5lcmF0ZQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+CiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgYDsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSBgCiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iaW5mby1jYXJkLXRpdGxlIj5ObyBDTUEgR2VuZXJhdGVkIFlldDwvZGl2PgogICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImluZm8tY2FyZC1jb250ZW50Ij5HZW5lcmF0ZSB5b3VyIGZpcnN0IENNQSBiZWxvdyB0byBnZXQgc3RhcnRlZC48L2Rpdj4KICAgICAgICAgICAgICAgIGA7CiAgICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIC8vIEdlbmVyYXRlIENNQQogICAgICAgIGFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlQ01BKCkgewogICAgICAgICAgICBjb25zdCBhZGRyZXNzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NtYUFkZHJlc3MnKS52YWx1ZS50cmltKCk7CiAgICAgICAgICAgIAogICAgICAgICAgICBpZiAoIWFkZHJlc3MpIHsKICAgICAgICAgICAgICAgIHNob3dFcnJvcignUGxlYXNlIGVudGVyIGEgcHJvcGVydHkgYWRkcmVzcycpOwogICAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICB9CgogICAgICAgICAgICBjb25zdCByZXN1bHREaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY21hUmVzdWx0Jyk7CiAgICAgICAgICAgIHJlc3VsdERpdi5pbm5lckhUTUwgPSAnPGRpdiBjbGFzcz0ibG9hZGluZyI+PGRpdiBjbGFzcz0ic3Bpbm5lciI+PC9kaXY+R2VuZXJhdGluZyBDTUEgYW5kIGNyZWF0aW5nIEhvbWViZWF0Li4uPC9kaXY+JzsKCiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHsKICAgICAgICAgICAgICAgIGFjdGlvbjogJ2dlbmVyYXRlQ01BJywKICAgICAgICAgICAgICAgIHBlcnNvbklkOiBwZXJzb25JZCwKICAgICAgICAgICAgICAgIGFkZHJlc3M6IGFkZHJlc3MsCiAgICAgICAgICAgICAgICBiZWRzOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY21hQmVkcycpLnZhbHVlLAogICAgICAgICAgICAgICAgYmF0aHM6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjbWFCYXRocycpLnZhbHVlLAogICAgICAgICAgICAgICAgc3FmdDogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NtYVNxZnQnKS52YWx1ZSwKICAgICAgICAgICAgICAgIHJhZGl1czogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NtYVJhZGl1cycpLnZhbHVlLAogICAgICAgICAgICAgICAgbW9udGhzQmFjazogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NtYU1vbnRoc0JhY2snKS52YWx1ZSwKICAgICAgICAgICAgICAgIG1pbkxpc3RpbmdzOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY21hTWluTGlzdGluZ3MnKS52YWx1ZSwKICAgICAgICAgICAgICAgIHByb3BUeXBlOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY21hUHJvcFR5cGUnKS52YWx1ZSwKICAgICAgICAgICAgICAgIHRpdGxlOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY21hVGl0bGUnKS52YWx1ZSwKICAgICAgICAgICAgICAgIGNyZWF0ZUhvbWViZWF0OiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY3JlYXRlSG9tZWJlYXQnKS5jaGVja2VkLAogICAgICAgICAgICAgICAgaG9tZWJlYXRGcmVxdWVuY3k6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdob21lYmVhdEZyZXF1ZW5jeScpLnZhbHVlCiAgICAgICAgICAgIH07CgogICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9Ly5uZXRsaWZ5L2Z1bmN0aW9ucy93aWxsb3ctY21hLXdvcmtiZW5jaGAsIHsKICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJywKICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSwKICAgICAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShwYXJhbXMpCiAgICAgICAgICAgICAgICB9KTsKCiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpOwoKICAgICAgICAgICAgICAgIGlmIChkYXRhLmVycm9yKSB7CiAgICAgICAgICAgICAgICAgICAgcmVzdWx0RGl2LmlubmVySFRNTCA9IGA8ZGl2IGNsYXNzPSJlcnJvciI+4p2MICR7ZGF0YS5lcnJvcn08L2Rpdj5gOwogICAgICAgICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICByZXN1bHREaXYuaW5uZXJIVE1MID0gYAogICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InN1Y2Nlc3MiPgogICAgICAgICAgICAgICAgICAgICAgICDinIUgPHN0cm9uZz5DTUEgR2VuZXJhdGVkIFN1Y2Nlc3NmdWxseSE8L3N0cm9uZz48YnI+CiAgICAgICAgICAgICAgICAgICAgICAgICR7ZGF0YS5ob21lYmVhdENyZWF0ZWQgPyAn4pyFIEhvbWViZWF0IHN1YnNjcmlwdGlvbiBjcmVhdGVkJyA6ICcnfTxicj4KICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iYnRuLWdyb3VwIiBzdHlsZT0ibWFyZ2luLXRvcDogMTBweDsiPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz0iYnRuIGJ0bi1zZWNvbmRhcnkiIG9uY2xpY2s9IndpbmRvdy5vcGVuKCcke2RhdGEuY21hVXJsfScsICdfYmxhbmsnKSI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg8J+ThCBWaWV3IENNQQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAke2RhdGEuaG9tZWJlYXRVcmwgPyBgPGJ1dHRvbiBjbGFzcz0iYnRuIGJ0bi1zZWNvbmRhcnkiIG9uY2xpY2s9IndpbmRvdy5vcGVuKCcke2RhdGEuaG9tZWJlYXRVcmx9JywgJ19ibGFuaycpIj7wn4+gIFZpZXcgSG9tZWJlYXQ8L2J1dHRvbj5gIDogJyd9CiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgYDsKCiAgICAgICAgICAgICAgICAvLyBSZWxvYWQgcGVyc29uIGRhdGEgdG8gc2hvdyB1cGRhdGVkIENNQQogICAgICAgICAgICAgICAgYXdhaXQgbG9hZFBlcnNvbkRhdGEoKTsKICAgICAgICAgICAgICAgIGF3YWl0IGxvYWRIb21lYmVhdERhdGEoKTsKCiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7CiAgICAgICAgICAgICAgICByZXN1bHREaXYuaW5uZXJIVE1MID0gYDxkaXYgY2xhc3M9ImVycm9yIj7inYwgRmFpbGVkIHRvIGdlbmVyYXRlIENNQTogJHtlcnJvci5tZXNzYWdlfTwvZGl2PmA7CiAgICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIC8vIExvYWQgSG9tZWJlYXQgZGF0YQogICAgICAgIGFzeW5jIGZ1bmN0aW9uIGxvYWRIb21lYmVhdERhdGEoKSB7CiAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vLm5ldGxpZnkvZnVuY3Rpb25zL3dpbGxvdy1jbWEtd29ya2JlbmNoP2FjdGlvbj1nZXRIb21lYmVhdERhdGEmcGVyc29uSWQ9JHtwZXJzb25JZH1gKTsKICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7CgogICAgICAgICAgICAgICAgaWYgKGRhdGEuZXJyb3IpIHsKICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaG9tZWJlYXRMaXN0JykuaW5uZXJIVE1MID0gYDxkaXYgY2xhc3M9ImVycm9yIj4ke2RhdGEuZXJyb3J9PC9kaXY+YDsKICAgICAgICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgaG9tZWJlYXREYXRhID0gZGF0YS5ob21lYmVhdHMgfHwgW107CiAgICAgICAgICAgICAgICBkaXNwbGF5SG9tZWJlYXRzKGhvbWViZWF0RGF0YSk7CiAgICAgICAgICAgICAgICB1cGRhdGVFbmdhZ2VtZW50U3VtbWFyeShob21lYmVhdERhdGEpOwoKICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHsKICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdob21lYmVhdExpc3QnKS5pbm5lckhUTUwgPSBgPGRpdiBjbGFzcz0iZXJyb3IiPkZhaWxlZCB0byBsb2FkIEhvbWViZWF0IGRhdGE6ICR7ZXJyb3IubWVzc2FnZX08L2Rpdj5gOwogICAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICAvLyBEaXNwbGF5IEhvbWViZWF0cwogICAgICAgIGZ1bmN0aW9uIGRpc3BsYXlIb21lYmVhdHMoaG9tZWJlYXRzKSB7CiAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdob21lYmVhdExpc3QnKTsKCiAgICAgICAgICAgIGlmICghaG9tZWJlYXRzIHx8IGhvbWViZWF0cy5sZW5ndGggPT09IDApIHsKICAgICAgICAgICAgICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSAnPGRpdiBjbGFzcz0iaW5mby1jYXJkIj48ZGl2IGNsYXNzPSJpbmZvLWNhcmQtdGl0bGUiPk5vIEhvbWViZWF0cyBGb3VuZDwvZGl2PjxkaXYgY2xhc3M9ImluZm8tY2FyZC1jb250ZW50Ij5HZW5lcmF0ZSBhIENNQSB3aXRoIEhvbWViZWF0IHN1YnNjcmlwdGlvbiB0byBnZXQgc3RhcnRlZC48L2Rpdj48L2Rpdj4nOwogICAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICB9CgogICAgICAgICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gaG9tZWJlYXRzLm1hcChoYiA9PiB7CiAgICAgICAgICAgICAgICBjb25zdCB2aWV3cyA9IGhiLnRvdGFsX3ZpZXdzIHx8IDA7CiAgICAgICAgICAgICAgICBjb25zdCBkYXlzU2luY2VGaXJzdFNlbmQgPSBoYi5maXJzdF9zZW5kX2RhdGUgPyBNYXRoLmZsb29yKChEYXRlLm5vdygpIC0gbmV3IERhdGUoaGIuZmlyc3Rfc2VuZF9kYXRlKS5nZXRUaW1lKCkpIC8gKDEwMDAgKiA2MCAqIDYwICogMjQpKSA6IDA7CiAgICAgICAgICAgICAgICBjb25zdCBuZWVkc1Jlc2VuZCA9IHZpZXdzID09PSAwICYmIGRheXNTaW5jZUZpcnN0U2VuZCA+PSA2MDsKICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgbGV0IGVuZ2FnZW1lbnRDbGFzcywgZW5nYWdlbWVudEJhZGdlOwogICAgICAgICAgICAgICAgaWYgKHZpZXdzID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgZW5nYWdlbWVudENsYXNzID0gJ25vdC1hY2NlcHRlZCc7CiAgICAgICAgICAgICAgICAgICAgZW5nYWdlbWVudEJhZGdlID0gJzxzcGFuIGNsYXNzPSJlbmdhZ2VtZW50LWJhZGdlIGJhZGdlLW5vdC1hY2NlcHRlZCI+Tk9UIEFDQ0VQVEVEPC9zcGFuPic7CiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZpZXdzID49IDIwKSB7CiAgICAgICAgICAgICAgICAgICAgZW5nYWdlbWVudENsYXNzID0gJ2hpZ2gtZW5nYWdlbWVudCc7CiAgICAgICAgICAgICAgICAgICAgZW5nYWdlbWVudEJhZGdlID0gJzxzcGFuIGNsYXNzPSJlbmdhZ2VtZW50LWJhZGdlIGJhZGdlLWNyaXRpY2FsIj7wn5SlIEhJR0g8L3NwYW4+JzsKICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodmlld3MgPj0gNSkgewogICAgICAgICAgICAgICAgICAgIGVuZ2FnZW1lbnRDbGFzcyA9ICdtZWRpdW0tZW5nYWdlbWVudCc7CiAgICAgICAgICAgICAgICAgICAgZW5nYWdlbWVudEJhZGdlID0gJzxzcGFuIGNsYXNzPSJlbmdhZ2VtZW50LWJhZGdlIGJhZGdlLWhpZ2giPuKaoO+4jyBNRURJVU08L3NwYW4+JzsKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgZW5nYWdlbWVudENsYXNzID0gJ2xvdy1lbmdhZ2VtZW50JzsKICAgICAgICAgICAgICAgICAgICBlbmdhZ2VtZW50QmFkZ2UgPSAnPHNwYW4gY2xhc3M9ImVuZ2FnZW1lbnQtYmFkZ2UgYmFkZ2UtbWVkaXVtIj7wn5OKIExPVzwvc3Bhbj4nOwogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgIHJldHVybiBgCiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iaG9tZWJlYXQtaXRlbSAke2VuZ2FnZW1lbnRDbGFzc30iPgogICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJob21lYmVhdC1oZWFkZXIiPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iaG9tZWJlYXQtdGl0bGUiPvCfj6AgJHtoYi5wcm9wZXJ0eV9hZGRyZXNzIHx8ICdVbmtub3duIEFkZHJlc3MnfTwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICAgICAgJHtlbmdhZ2VtZW50QmFkZ2V9CiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICAke25lZWRzUmVzZW5kID8gYAogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0icmVzZW5kLXdhcm5pbmciPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEhvbWViZWF0IG5vdCBhY2NlcHRlZCBmb3IgJHtkYXlzU2luY2VGaXJzdFNlbmR9IGRheXMgLSByZXNlbmQgcmVjb21tZW5kZWQKICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICBgIDogJyd9CiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImhvbWViZWF0LXN0YXRzIj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InN0YXQtaXRlbSI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9InN0YXQtbGFiZWwiPlRvdGFsIFZpZXdzOjwvc3Bhbj4gJHt2aWV3c30KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0ic3RhdC1pdGVtIj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0ic3RhdC1sYWJlbCI+TGFzdCBWaWV3Ojwvc3Bhbj4gJHtoYi5sYXN0X3ZpZXcgPyBuZXcgRGF0ZShoYi5sYXN0X3ZpZXcpLnRvTG9jYWxlRGF0ZVN0cmluZygpIDogJ05ldmVyJ30KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0ic3RhdC1pdGVtIj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0ic3RhdC1sYWJlbCI+RnJlcXVlbmN5Ojwvc3Bhbj4gJHtoYi5mcmVxdWVuY3kgfHwgJ04vQSd9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InN0YXQtaXRlbSI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9InN0YXQtbGFiZWwiPk5leHQgUmVwb3J0Ojwvc3Bhbj4gJHtoYi5uZXh0X3JlcG9ydCA/IG5ldyBEYXRlKGhiLm5leHRfcmVwb3J0KS50b0xvY2FsZURhdGVTdHJpbmcoKSA6ICdOL0EnfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAke2RheXNTaW5jZUZpcnN0U2VuZCA+IDAgPyBgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0ic3RhdC1pdGVtIj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9InN0YXQtbGFiZWwiPkRheXMgU2luY2UgRmlyc3QgU2VuZDo8L3NwYW4+ICR7ZGF5c1NpbmNlRmlyc3RTZW5kfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICAgICAgYCA6ICcnfQogICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iYnRuLWdyb3VwIj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9ImJ0biBidG4tc2Vjb25kYXJ5IiBvbmNsaWNrPSJ3aW5kb3cub3BlbignJHtoYi5ob21lYmVhdF91cmx9JywgJ19ibGFuaycpIj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDwn5GB77iPIFZpZXcgSG9tZWJlYXQKICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgJHt2aWV3cyA9PT0gMCB8fCBuZWVkc1Jlc2VuZCA/IGAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPSJidG4gYnRuLXByaW1hcnkiIG9uY2xpY2s9InJlc2VuZEhvbWViZWF0KCcke2hiLmlkfScpIj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg8J+TpyBSZXNlbmQgSG9tZWJlYXQKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGAgOiAnJ30KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9ImJ0biBidG4tc2Vjb25kYXJ5IiBvbmNsaWNrPSJlZGl0SG9tZWJlYXQoJyR7aGIuaWR9JykiPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKcj++4jyBFZGl0CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9ImJ0biBidG4tZGFuZ2VyIiBvbmNsaWNrPSJ1bnN1YnNjcmliZUhvbWViZWF0KCcke2hiLmlkfScpIj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDwn5qrIFVuc3Vic2NyaWJlCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj4KICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICBgOwogICAgICAgICAgICB9KS5qb2luKCcnKTsKICAgICAgICB9CgogICAgICAgIC8vIFVwZGF0ZSBlbmdhZ2VtZW50IHN1bW1hcnkKICAgICAgICBmdW5jdGlvbiB1cGRhdGVFbmdhZ2VtZW50U3VtbWFyeShob21lYmVhdHMpIHsKICAgICAgICAgICAgbGV0IGhpZ2ggPSAwLCBtZWRpdW0gPSAwLCBsb3cgPSAwLCBub3RBY2NlcHRlZCA9IDA7CgogICAgICAgICAgICBob21lYmVhdHMuZm9yRWFjaChoYiA9PiB7CiAgICAgICAgICAgICAgICBjb25zdCB2aWV3cyA9IGhiLnRvdGFsX3ZpZXdzIHx8IDA7CiAgICAgICAgICAgICAgICBpZiAodmlld3MgPT09IDApIG5vdEFjY2VwdGVkKys7CiAgICAgICAgICAgICAgICBlbHNlIGlmICh2aWV3cyA+PSAyMCkgaGlnaCsrOwogICAgICAgICAgICAgICAgZWxzZSBpZiAodmlld3MgPj0gNSkgbWVkaXVtKys7CiAgICAgICAgICAgICAgICBlbHNlIGxvdysrOwogICAgICAgICAgICB9KTsKCiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdoaWdoRW5nYWdlbWVudENvdW50JykudGV4dENvbnRlbnQgPSBoaWdoOwogICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWVkaXVtRW5nYWdlbWVudENvdW50JykudGV4dENvbnRlbnQgPSBtZWRpdW07CiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsb3dFbmdhZ2VtZW50Q291bnQnKS50ZXh0Q29udGVudCA9IGxvdzsKICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ25vdEFjY2VwdGVkQ291bnQnKS50ZXh0Q29udGVudCA9IG5vdEFjY2VwdGVkOwogICAgICAgIH0KCiAgICAgICAgLy8gUmVmcmVzaCBIb21lYmVhdCBhbmFseXRpY3MKICAgICAgICBhc3luYyBmdW5jdGlvbiByZWZyZXNoSG9tZWJlYXRBbmFseXRpY3MoKSB7CiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdob21lYmVhdExpc3QnKS5pbm5lckhUTUwgPSAnPGRpdiBjbGFzcz0ibG9hZGluZyI+PGRpdiBjbGFzcz0ic3Bpbm5lciI+PC9kaXY+UmVmcmVzaGluZyBhbmFseXRpY3MuLi48L2Rpdj4nOwogICAgICAgICAgICBhd2FpdCBsb2FkSG9tZWJlYXREYXRhKCk7CiAgICAgICAgfQoKICAgICAgICAvLyBSZXNlbmQgSG9tZWJlYXQKICAgICAgICBhc3luYyBmdW5jdGlvbiByZXNlbmRIb21lYmVhdChob21lYmVhdElkKSB7CiAgICAgICAgICAgIGlmICghY29uZmlybSgnUmVzZW5kIHRoaXMgSG9tZWJlYXQgdG8gdGhlIGxlYWQ/JykpIHJldHVybjsKCiAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vLm5ldGxpZnkvZnVuY3Rpb25zL3dpbGxvdy1jbWEtd29ya2JlbmNoYCwgewogICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLAogICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LAogICAgICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsKICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiAncmVzZW5kSG9tZWJlYXQnLAogICAgICAgICAgICAgICAgICAgICAgICBob21lYmVhdElkOiBob21lYmVhdElkLAogICAgICAgICAgICAgICAgICAgICAgICBwZXJzb25JZDogcGVyc29uSWQKICAgICAgICAgICAgICAgICAgICB9KQogICAgICAgICAgICAgICAgfSk7CgogICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTsKCiAgICAgICAgICAgICAgICBpZiAoZGF0YS5lcnJvcikgewogICAgICAgICAgICAgICAgICAgIGFsZXJ0KCdGYWlsZWQgdG8gcmVzZW5kIEhvbWViZWF0OiAnICsgZGF0YS5lcnJvcik7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgIGFsZXJ0KCfinIUgSG9tZWJlYXQgcmVzZW50IHN1Y2Nlc3NmdWxseSEnKTsKICAgICAgICAgICAgICAgIGF3YWl0IGxvYWRIb21lYmVhdERhdGEoKTsKCiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7CiAgICAgICAgICAgICAgICBhbGVydCgnRmFpbGVkIHRvIHJlc2VuZCBIb21lYmVhdDogJyArIGVycm9yLm1lc3NhZ2UpOwogICAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICAvLyBHZW5lcmF0ZSB0cmlnZ2VyZWQgYWN0aW9ucwogICAgICAgIGFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlVHJpZ2dlcmVkQWN0aW9ucygpIHsKICAgICAgICAgICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RyaWdnZXJlZEFjdGlvbnMnKTsKICAgICAgICAgICAgY29udGFpbmVyLmlubmVySFRNTCA9ICc8ZGl2IGNsYXNzPSJsb2FkaW5nIj48ZGl2IGNsYXNzPSJzcGlubmVyIj48L2Rpdj5BbmFseXppbmcgZW5nYWdlbWVudCBkYXRhLi4uPC9kaXY+JzsKCiAgICAgICAgICAgIGlmICghaG9tZWJlYXREYXRhIHx8IGhvbWViZWF0RGF0YS5sZW5ndGggPT09IDApIHsKICAgICAgICAgICAgICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSAnPGRpdiBjbGFzcz0iaW5mby1jYXJkIj48ZGl2IGNsYXNzPSJpbmZvLWNhcmQtdGl0bGUiPk5vIEFjdGlvbnMgVHJpZ2dlcmVkPC9kaXY+PGRpdiBjbGFzcz0iaW5mby1jYXJkLWNvbnRlbnQiPkdlbmVyYXRlIEhvbWViZWF0cyBhbmQgdHJhY2sgZW5nYWdlbWVudCB0byBzZWUgdHJpZ2dlcmVkIGFjdGlvbnMgaGVyZS48L2Rpdj48L2Rpdj4nOwogICAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICB9CgogICAgICAgICAgICBjb25zdCBhY3Rpb25zID0gW107CgogICAgICAgICAgICBob21lYmVhdERhdGEuZm9yRWFjaChoYiA9PiB7CiAgICAgICAgICAgICAgICBjb25zdCB2aWV3cyA9IGhiLnRvdGFsX3ZpZXdzIHx8IDA7CiAgICAgICAgICAgICAgICBjb25zdCBkYXlzU2luY2VGaXJzdFNlbmQgPSBoYi5maXJzdF9zZW5kX2RhdGUgPyBNYXRoLmZsb29yKChEYXRlLm5vdygpIC0gbmV3IERhdGUoaGIuZmlyc3Rfc2VuZF9kYXRlKS5nZXRUaW1lKCkpIC8gKDEwMDAgKiA2MCAqIDYwICogMjQpKSA6IDA7CgogICAgICAgICAgICAgICAgaWYgKHZpZXdzID49IDIwKSB7CiAgICAgICAgICAgICAgICAgICAgYWN0aW9ucy5wdXNoKHsKICAgICAgICAgICAgICAgICAgICAgICAgcHJpb3JpdHk6ICdjcml0aWNhbCcsCiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBoYi5wcm9wZXJ0eV9hZGRyZXNzLAogICAgICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyOiBgSG9tZWJlYXQgdmlld3MgKCR7dmlld3N9KSBleGNlZWQgY3JpdGljYWwgdGhyZXNob2xkYCwKICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiAnU2NoZWR1bGUgbGlzdGluZyBwcmVzZW50YXRpb24nLAogICAgICAgICAgICAgICAgICAgICAgICB1cmdlbmN5OiAnSU1NRURJQVRFJywKICAgICAgICAgICAgICAgICAgICAgICAgc2NyaXB0OiAiSSBub3RpY2VkIHlvdSd2ZSBiZWVuIG1vbml0b3JpbmcgeW91ciBob21lIHZhbHVlIGNsb3NlbHkgd2l0aCB0aGUgSG9tZWJlYXQgcmVwb3J0cy4gV2l0aCAiICsgdmlld3MgKyAiIHZpZXdzLCBpdCdzIGNsZWFyIHlvdSdyZSBzZXJpb3VzIGFib3V0IHVuZGVyc3RhbmRpbmcgeW91ciBwcm9wZXJ0eSdzIHdvcnRoLiBUaGUgbWFya2V0IGlzIG1vdmluZyBmYXN0IHJpZ2h0IG5vdyAtIGxldCdzIGRpc2N1c3Mgd2hhdCB0aGlzIG1lYW5zIGZvciB5b3UgYW5kIHlvdXIgdGltZWxpbmUuIgogICAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2aWV3cyA+PSAxMCkgewogICAgICAgICAgICAgICAgICAgIGFjdGlvbnMucHVzaCh7CiAgICAgICAgICAgICAgICAgICAgICAgIHByaW9yaXR5OiAnaG90JywKICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IGhiLnByb3BlcnR5X2FkZHJlc3MsCiAgICAgICAgICAgICAgICAgICAgICAgIHRyaWdnZXI6IGBIb21lYmVhdCB2aWV3cyAoJHt2aWV3c30pIHNob3cgc3Ryb25nIGVuZ2FnZW1lbnRgLAogICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246ICdDYWxsIHRvIGRpc2N1c3MgbWFya2V0IGNoYW5nZXMnLAogICAgICAgICAgICAgICAgICAgICAgICB1cmdlbmN5OiAnU0FNRV9EQVknLAogICAgICAgICAgICAgICAgICAgICAgICBzY3JpcHQ6ICJJIHNlZSB5b3UndmUgYmVlbiBrZWVwaW5nIGFuIGV5ZSBvbiB0aGUgbWFya2V0IHRocm91Z2ggeW91ciBIb21lYmVhdCByZXBvcnRzLiBBbnkgcXVlc3Rpb25zIGFib3V0IHRoZSByZWNlbnQgY2hhbmdlcyBvciBjb21wYXJhYmxlIHNhbGVzIGluIHlvdXIgYXJlYT8iCiAgICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZpZXdzID49IDUpIHsKICAgICAgICAgICAgICAgICAgICBhY3Rpb25zLnB1c2goewogICAgICAgICAgICAgICAgICAgICAgICBwcmlvcml0eTogJ3dhcm0nLAogICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogaGIucHJvcGVydHlfYWRkcmVzcywKICAgICAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcjogYEhvbWViZWF0IHZpZXdzICgke3ZpZXdzfSkgc2hvdyBtb2RlcmF0ZSBpbnRlcmVzdGAsCiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogJ0VtYWlsIGNoZWNrLWluIGFib3V0IHByb3BlcnR5IHZhbHVlJywKICAgICAgICAgICAgICAgICAgICAgICAgdXJnZW5jeTogJ1dFRUtMWScsCiAgICAgICAgICAgICAgICAgICAgICAgIHNjcmlwdDogIkp1c3Qgd2FudGVkIHRvIGNoZWNrIGluIGFib3V0IHlvdXIgSG9tZWJlYXQgcmVwb3J0cy4gQXJlIHlvdSBmaW5kaW5nIHRoZSBtYXJrZXQgdXBkYXRlcyBoZWxwZnVsPyBMZXQgbWUga25vdyBpZiB5b3UnZCBsaWtlIHRvIGRpc2N1c3MgYW55IHNwZWNpZmljIHRyZW5kcy4iCiAgICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZpZXdzID09PSAwICYmIGRheXNTaW5jZUZpcnN0U2VuZCA+PSA2MCkgewogICAgICAgICAgICAgICAgICAgIGFjdGlvbnMucHVzaCh7CiAgICAgICAgICAgICAgICAgICAgICAgIHByaW9yaXR5OiAnd2FybScsCiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBoYi5wcm9wZXJ0eV9hZGRyZXNzLAogICAgICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyOiBgSG9tZWJlYXQgbm90IG9wZW5lZCBmb3IgJHtkYXlzU2luY2VGaXJzdFNlbmR9IGRheXNgLAogICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246ICdSZS1lbmdhZ2Ugd2l0aCB1cGRhdGVkIEhvbWViZWF0JywKICAgICAgICAgICAgICAgICAgICAgICAgdXJnZW5jeTogJ1dFRUtMWScsCiAgICAgICAgICAgICAgICAgICAgICAgIHNjcmlwdDogIkkgd2FudGVkIHRvIG1ha2Ugc3VyZSB5b3UncmUgc3RpbGwgcmVjZWl2aW5nIHlvdXIgSG9tZWJlYXQgbWFya2V0IHVwZGF0ZXMuIFdvdWxkIHlvdSBsaWtlIG1lIHRvIHJlc2VuZCB0aGUgbGF0ZXN0IHJlcG9ydCBvciBhZGp1c3QgdGhlIGZyZXF1ZW5jeT8iCiAgICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0pOwoKICAgICAgICAgICAgaWYgKGFjdGlvbnMubGVuZ3RoID09PSAwKSB7CiAgICAgICAgICAgICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gJzxkaXYgY2xhc3M9ImluZm8tY2FyZCI+PGRpdiBjbGFzcz0iaW5mby1jYXJkLXRpdGxlIj5ObyBBY3Rpb25zIFRyaWdnZXJlZDwvZGl2PjxkaXYgY2xhc3M9ImluZm8tY2FyZC1jb250ZW50Ij5Db250aW51ZSBtb25pdG9yaW5nIEhvbWViZWF0IGVuZ2FnZW1lbnQuIEFjdGlvbnMgd2lsbCBhcHBlYXIgaGVyZSB3aGVuIGVuZ2FnZW1lbnQgdGhyZXNob2xkcyBhcmUgbWV0LjwvZGl2PjwvZGl2Pic7CiAgICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSBhY3Rpb25zLm1hcChhY3Rpb24gPT4gYAogICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iYWN0aW9uLWNhcmQgJHthY3Rpb24ucHJpb3JpdHl9Ij4KICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJhY3Rpb24taGVhZGVyIj4KICAgICAgICAgICAgICAgICAgICAgICAgJHthY3Rpb24ucHJpb3JpdHkgPT09ICdjcml0aWNhbCcgPyAn8J+UpSBDUklUSUNBTCBBQ1RJT04gUkVDT01NRU5ERUQnIDogYWN0aW9uLnByaW9yaXR5ID09PSAnaG90JyA/ICfimqDvuI8gSE9UIEFDVElPTiBTVUdHRVNURUQnIDogJ/Cfk4ogV0FSTSBBQ1RJT04gU1VHR0VTVEVEJ30KICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJhY3Rpb24tY29udGVudCI+CiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXY+PHN0cm9uZz5Qcm9wZXJ0eTo8L3N0cm9uZz4gJHthY3Rpb24ucHJvcGVydHl9PC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXY+PHN0cm9uZz5UcmlnZ2VyOjwvc3Ryb25nPiAke2FjdGlvbi50cmlnZ2VyfTwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICA8ZGl2PjxzdHJvbmc+U3VnZ2VzdGVkIEFjdGlvbjo8L3N0cm9uZz4gJHthY3Rpb24uYWN0aW9ufTwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICA8ZGl2PjxzdHJvbmc+VXJnZW5jeTo8L3N0cm9uZz4gJHthY3Rpb24udXJnZW5jeX08L2Rpdj4KICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJzY3JpcHQtYm94Ij4KICAgICAgICAgICAgICAgICAgICAgICAgPHN0cm9uZz5TdWdnZXN0ZWQgU2NyaXB0Ojwvc3Ryb25nPjxicj4KICAgICAgICAgICAgICAgICAgICAgICAgIiR7YWN0aW9uLnNjcmlwdH0iCiAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iZm9ybS1ncm91cCI+CiAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz0iZm9ybS1sYWJlbCI+QXNzaWduIFBhcnRuZXI8L2xhYmVsPgogICAgICAgICAgICAgICAgICAgICAgICA8c2VsZWN0IGNsYXNzPSJmb3JtLXNlbGVjdCIgaWQ9InBhcnRuZXItJHthY3Rpb24ucHJvcGVydHl9Ij4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9IkdsZW5uIj5HbGVubjwvb3B0aW9uPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT0iSnVzdGluIj5KdXN0aW48L29wdGlvbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9IkhlYXRoZXIiPkhlYXRoZXI8L29wdGlvbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9Ikxsb3lkIj5MbG95ZDwvb3B0aW9uPgogICAgICAgICAgICAgICAgICAgICAgICA8L3NlbGVjdD4KICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJidG4tZ3JvdXAiPgogICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPSJidG4gYnRuLXByaW1hcnkiIG9uY2xpY2s9ImNyZWF0ZVRhc2soJyR7YWN0aW9uLnByb3BlcnR5fScsICcke2FjdGlvbi5hY3Rpb259JywgJyR7YWN0aW9uLnVyZ2VuY3l9JykiPgogICAgICAgICAgICAgICAgICAgICAgICAgICAg4pyFIENyZWF0ZSBUYXNrIGluIEZVQgogICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj4KICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz0iYnRuIGJ0bi1zZWNvbmRhcnkiIG9uY2xpY2s9ImNyZWF0ZUNhbGwoJyR7YWN0aW9uLnByb3BlcnR5fScpIj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIPCfk54gTG9nIENhbGwKICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+CiAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9ImJ0biBidG4tc2Vjb25kYXJ5IiBvbmNsaWNrPSJjcmVhdGVFbWFpbCgnJHthY3Rpb24ucHJvcGVydHl9JywgJyR7YWN0aW9uLnNjcmlwdH0nKSI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICDwn5OnIFNlbmQgRW1haWwKICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+CiAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgYCkuam9pbignJyk7CiAgICAgICAgfQoKICAgICAgICAvLyBDcmVhdGUgdGFzayBpbiBGVUIKICAgICAgICBhc3luYyBmdW5jdGlvbiBjcmVhdGVUYXNrKHByb3BlcnR5LCBhY3Rpb24sIHVyZ2VuY3kpIHsKICAgICAgICAgICAgY29uc3QgcGFydG5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGBwYXJ0bmVyLSR7cHJvcGVydHl9YCk/LnZhbHVlIHx8ICdHbGVubic7CiAgICAgICAgICAgIAogICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9Ly5uZXRsaWZ5L2Z1bmN0aW9ucy93aWxsb3ctY21hLXdvcmtiZW5jaGAsIHsKICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJywKICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSwKICAgICAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7CiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogJ2NyZWF0ZVRhc2snLAogICAgICAgICAgICAgICAgICAgICAgICBwZXJzb25JZDogcGVyc29uSWQsCiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2tEZXNjcmlwdGlvbjogYCR7YWN0aW9ufSAtIFByb3BlcnR5OiAke3Byb3BlcnR5fWAsCiAgICAgICAgICAgICAgICAgICAgICAgIHVyZ2VuY3k6IHVyZ2VuY3ksCiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2lnbmVkVG86IHBhcnRuZXIKICAgICAgICAgICAgICAgICAgICB9KQogICAgICAgICAgICAgICAgfSk7CgogICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTsKCiAgICAgICAgICAgICAgICBpZiAoZGF0YS5lcnJvcikgewogICAgICAgICAgICAgICAgICAgIGFsZXJ0KCdGYWlsZWQgdG8gY3JlYXRlIHRhc2s6ICcgKyBkYXRhLmVycm9yKTsKICAgICAgICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgYWxlcnQoYOKchSBUYXNrIGNyZWF0ZWQgYW5kIGFzc2lnbmVkIHRvICR7cGFydG5lcn0hYCk7CgogICAgICAgICAgICB9IGNhdGNoIChlcnJvcikgewogICAgICAgICAgICAgICAgYWxlcnQoJ0ZhaWxlZCB0byBjcmVhdGUgdGFzazogJyArIGVycm9yLm1lc3NhZ2UpOwogICAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICAvLyBDcmVhdGUgbWFudWFsIGFjdGlvbgogICAgICAgIGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZU1hbnVhbEFjdGlvbigpIHsKICAgICAgICAgICAgY29uc3QgYWN0aW9uVHlwZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhY3Rpb25UeXBlJykudmFsdWU7CiAgICAgICAgICAgIGNvbnN0IGFzc2lnblRvID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Fzc2lnblRvJykudmFsdWU7CiAgICAgICAgICAgIGNvbnN0IHVyZ2VuY3kgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndXJnZW5jeScpLnZhbHVlOwogICAgICAgICAgICBjb25zdCBub3RlcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhY3Rpb25Ob3RlcycpLnZhbHVlLnRyaW0oKTsKCiAgICAgICAgICAgIGlmICghbm90ZXMpIHsKICAgICAgICAgICAgICAgIGFsZXJ0KCdQbGVhc2UgZW50ZXIgYWN0aW9uIG5vdGVzJyk7CiAgICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGNvbnN0IHJlc3VsdERpdiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtYW51YWxBY3Rpb25SZXN1bHQnKTsKICAgICAgICAgICAgcmVzdWx0RGl2LmlubmVySFRNTCA9ICc8ZGl2IGNsYXNzPSJsb2FkaW5nIj48ZGl2IGNsYXNzPSJzcGlubmVyIj48L2Rpdj5DcmVhdGluZyBhY3Rpb24uLi48L2Rpdj4nOwoKICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS8ubmV0bGlmeS9mdW5jdGlvbnMvd2lsbG93LWNtYS13b3JrYmVuY2hgLCB7CiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsCiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sCiAgICAgICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoewogICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246ICdjcmVhdGVNYW51YWxBY3Rpb24nLAogICAgICAgICAgICAgICAgICAgICAgICBwZXJzb25JZDogcGVyc29uSWQsCiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvblR5cGU6IGFjdGlvblR5cGUsCiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2lnbmVkVG86IGFzc2lnblRvLAogICAgICAgICAgICAgICAgICAgICAgICB1cmdlbmN5OiB1cmdlbmN5LAogICAgICAgICAgICAgICAgICAgICAgICBub3Rlczogbm90ZXMKICAgICAgICAgICAgICAgICAgICB9KQogICAgICAgICAgICAgICAgfSk7CgogICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTsKCiAgICAgICAgICAgICAgICBpZiAoZGF0YS5lcnJvcikgewogICAgICAgICAgICAgICAgICAgIHJlc3VsdERpdi5pbm5lckhUTUwgPSBgPGRpdiBjbGFzcz0iZXJyb3IiPuKdjCAke2RhdGEuZXJyb3J9PC9kaXY+YDsKICAgICAgICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgcmVzdWx0RGl2LmlubmVySFRNTCA9IGA8ZGl2IGNsYXNzPSJzdWNjZXNzIj7inIUgJHthY3Rpb25UeXBlfSBjcmVhdGVkIHN1Y2Nlc3NmdWxseSBhbmQgYXNzaWduZWQgdG8gJHthc3NpZ25Ub30hPC9kaXY+YDsKICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhY3Rpb25Ob3RlcycpLnZhbHVlID0gJyc7CgogICAgICAgICAgICB9IGNhdGNoIChlcnJvcikgewogICAgICAgICAgICAgICAgcmVzdWx0RGl2LmlubmVySFRNTCA9IGA8ZGl2IGNsYXNzPSJlcnJvciI+4p2MIEZhaWxlZCB0byBjcmVhdGUgYWN0aW9uOiAke2Vycm9yLm1lc3NhZ2V9PC9kaXY+YDsKICAgICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgLy8gSGVscGVyIGZ1bmN0aW9ucwogICAgICAgIGZ1bmN0aW9uIHNob3dFcnJvcihtZXNzYWdlKSB7CiAgICAgICAgICAgIGFsZXJ0KCdFcnJvcjogJyArIG1lc3NhZ2UpOwogICAgICAgIH0KCiAgICAgICAgLy8gRWRpdCBIb21lYmVhdCAocGxhY2Vob2xkZXIpCiAgICAgICAgZnVuY3Rpb24gZWRpdEhvbWViZWF0KGhvbWViZWF0SWQpIHsKICAgICAgICAgICAgYWxlcnQoJ0VkaXQgSG9tZWJlYXQgZnVuY3Rpb25hbGl0eSBjb21pbmcgc29vbi4gSG9tZWJlYXQgSUQ6ICcgKyBob21lYmVhdElkKTsKICAgICAgICB9CgogICAgICAgIC8vIFVuc3Vic2NyaWJlIEhvbWViZWF0IChwbGFjZWhvbGRlcikKICAgICAgICBhc3luYyBmdW5jdGlvbiB1bnN1YnNjcmliZUhvbWViZWF0KGhvbWViZWF0SWQpIHsKICAgICAgICAgICAgaWYgKCFjb25maXJtKCdBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gdW5zdWJzY3JpYmUgdGhpcyBIb21lYmVhdD8nKSkgcmV0dXJuOwogICAgICAgICAgICBhbGVydCgnVW5zdWJzY3JpYmUgZnVuY3Rpb25hbGl0eSBjb21pbmcgc29vbi4gSG9tZWJlYXQgSUQ6ICcgKyBob21lYmVhdElkKTsKICAgICAgICB9CgogICAgICAgIC8vIENyZWF0ZSBjYWxsIChwbGFjZWhvbGRlcikKICAgICAgICBmdW5jdGlvbiBjcmVhdGVDYWxsKHByb3BlcnR5KSB7CiAgICAgICAgICAgIGFsZXJ0KCdDYWxsIGxvZ2dpbmcgZnVuY3Rpb25hbGl0eSBjb21pbmcgc29vbiBmb3IgcHJvcGVydHk6ICcgKyBwcm9wZXJ0eSk7CiAgICAgICAgfQoKICAgICAgICAvLyBDcmVhdGUgZW1haWwgKHBsYWNlaG9sZGVyKQogICAgICAgIGZ1bmN0aW9uIGNyZWF0ZUVtYWlsKHByb3BlcnR5LCBzY3JpcHQpIHsKICAgICAgICAgICAgYWxlcnQoJ0VtYWlsIGNyZWF0aW9uIGZ1bmN0aW9uYWxpdHkgY29taW5nIHNvb24gZm9yIHByb3BlcnR5OiAnICsgcHJvcGVydHkpOwogICAgICAgIH0KCiAgICAgICAgLy8gUmVnZW5lcmF0ZSBDTUEgKHBsYWNlaG9sZGVyKQogICAgICAgIGZ1bmN0aW9uIHJlZ2VuZXJhdGVDTUEoKSB7CiAgICAgICAgICAgIGFsZXJ0KCdSZWdlbmVyYXRlIENNQSBmdW5jdGlvbmFsaXR5IGNvbWluZyBzb29uLicpOwogICAgICAgIH0KICAgIDwvc2NyaXB0Pgo8L2JvZHk+CjwvaHRtbD4K';
            const html = Buffer.from(htmlBase64, 'base64').toString('utf8');
            
            return {
                statusCode: 200,
                headers: {
                    'Content-Type': 'text/html',
                    'Access-Control-Allow-Origin': '*'
                },
                body: html
            };
        }

        // Route to appropriate API handler
        switch (action) {
            case 'getPersonData':
                return await getPersonData(params.personId, headers);
            
            case 'generateCMA':
                return await generateCMA(params, headers);
            
            case 'getHomebeatData':
                return await getHomebeatData(params.personId, headers);
            
            case 'resendHomebeat':
                return await resendHomebeat(params, headers);
            
            case 'createTask':
                return await createTask(params, headers);
            
            case 'createManualAction':
                return await createManualAction(params, headers);
            
            default:
                return {
                    statusCode: 400,
                    headers,
                    body: JSON.stringify({ error: 'Invalid action' })
                };
        }

    } catch (error) {
        console.error('Function error:', error);
        return {
            statusCode: 500,
            headers,
            body: JSON.stringify({ error: error.message })
        };
    }
};

// Get person data from FUB
async function getPersonData(personId, headers) {
    try {
        const personData = await fubAPIRequest('GET', `/v1/people/${personId}`);
        
        return {
            statusCode: 200,
            headers,
            body: JSON.stringify(personData)
        };
    } catch (error) {
        return {
            statusCode: 500,
            headers,
            body: JSON.stringify({ error: 'Failed to fetch person data: ' + error.message })
        };
    }
}

// Generate CMA with CloudCMA API
async function generateCMA(params, headers) {
    try {
        const {
            personId,
            address,
            beds,
            baths,
            sqft,
            radius,
            monthsBack,
            minListings,
            propType,
            title,
            createHomebeat,
            homebeatFrequency
        } = params;

        // Get person data for lead info
        const personData = await fubAPIRequest('GET', `/v1/people/${personId}`);

        // Build CMA URL
        const cmaParams = new URLSearchParams({
            api_key: CLOUDCMA_API_KEY,
            address: address,
            beds: beds || '',
            baths: baths || '',
            sqft: sqft || '',
            radius: radius || '0.75',
            months_back: monthsBack || '9',
            min_listings: minListings || '10',
            prop_type: propType || '',
            title: title || `${personData.name || 'Client'} - ${address}`,
            callback_url: WEBHOOK_URL
        });

        const cmaUrl = `https://cloudcma.com/cmas/new?${cmaParams.toString()}`;

        // Update FUB custom fields
        const updatePayload = {
            customWILLOWCMADate: new Date().toISOString(),
            customWILLOWCMAAddress: address,
            customWILLOWCMALink: cmaUrl
        };

        await fubAPIRequest('PUT', `/v1/people/${personId}`, updatePayload);

        // Create FUB activity
        await fubAPIRequest('POST', '/v1/events', {
            person_id: parseInt(personId),
            type: 'Note',
            body: `CMA generated for ${address}. Parameters: ${beds}bd/${baths}ba, ${sqft}sqft, ${radius}mi radius, ${monthsBack}mo back.`
        });

        let homebeatUrl = null;
        let homebeatCreated = false;

        // Create Homebeat if requested
        if (createHomebeat === true || createHomebeat === 'true') {
            try {
                const homebeatPayload = {
                    automation: {
                        api_key: CLOUDCMA_API_KEY,
                        frequency: homebeatFrequency || 'quarterly',
                        welcome_email: 'true',
                        report: {
                            prop_type: propType || null,
                            callback_url: null
                        },
                        subject_property: {
                            address: address,
                            sqft: sqft || null,
                            beds: beds || null,
                            baths: baths || null
                        },
                        lead: {
                            name: personData.name || '',
                            email_address: personData.emails?.[0]?.value || '',
                            phone: personData.phones?.[0]?.value || ''
                        }
                    }
                };

                const homebeatResponse = await cloudCMAAPIRequest('POST', '/homebeats/widget', homebeatPayload);
                homebeatCreated = true;
                homebeatUrl = homebeatResponse.homebeat_url || null;

                // Update FUB with Homebeat info
                await fubAPIRequest('PUT', `/v1/people/${personId}`, {
                    customWILLOWCloudCMAHomeBeatURL: homebeatUrl,
                    customWILLOWHomebeatFirstSendDate: new Date().toISOString()
                });

                // Create FUB activity for Homebeat
                await fubAPIRequest('POST', '/v1/events', {
                    person_id: parseInt(personId),
                    type: 'Note',
                    body: `Homebeat subscription created for ${address}. Frequency: ${homebeatFrequency}. Lead will receive automated market updates.`
                });

            } catch (homebeatError) {
                console.error('Homebeat creation failed:', homebeatError);
            }
        }

        return {
            statusCode: 200,
            headers,
            body: JSON.stringify({
                success: true,
                cmaUrl: cmaUrl,
                homebeatCreated: homebeatCreated,
                homebeatUrl: homebeatUrl
            })
        };

    } catch (error) {
        return {
            statusCode: 500,
            headers,
            body: JSON.stringify({ error: 'Failed to generate CMA: ' + error.message })
        };
    }
}

// Get Homebeat data from CloudCMA
async function getHomebeatData(personId, headers) {
    try {
        const homebeatReport = await cloudCMAAPIRequest('GET', `/homebeats/report?api_key=${CLOUDCMA_API_KEY}&format=json`);

        const personData = await fubAPIRequest('GET', `/v1/people/${personId}`);
        const personEmail = personData.emails?.[0]?.value?.toLowerCase();

        if (!personEmail) {
            return {
                statusCode: 200,
                headers,
                body: JSON.stringify({ homebeats: [] })
            };
        }

        const leadHomebeats = (homebeatReport || []).filter(hb => 
            hb.lead_email?.toLowerCase() === personEmail
        );

        const enrichedHomebeats = leadHomebeats.map(hb => ({
            ...hb,
            first_send_date: personData.customWILLOWHomebeatFirstSendDate || hb.created_at,
            status: (hb.total_views || 0) === 0 ? 'pending' : 'active'
        }));

        if (enrichedHomebeats.length > 0) {
            const totalViews = enrichedHomebeats.reduce((sum, hb) => sum + (hb.total_views || 0), 0);
            const latestView = enrichedHomebeats
                .map(hb => hb.last_view)
                .filter(v => v)
                .sort()
                .reverse()[0];

            await fubAPIRequest('PUT', `/v1/people/${personId}`, {
                customWILLOWHomebeatViews: totalViews,
                customWILLOWHomebeatLastView: latestView || null
            });
        }

        return {
            statusCode: 200,
            headers,
            body: JSON.stringify({ homebeats: enrichedHomebeats })
        };

    } catch (error) {
        return {
            statusCode: 500,
            headers,
            body: JSON.stringify({ error: 'Failed to fetch Homebeat data: ' + error.message })
        };
    }
}

// Resend Homebeat
async function resendHomebeat(params, headers) {
    try {
        const { homebeatId, personId } = params;

        const personData = await fubAPIRequest('GET', `/v1/people/${personId}`);
        
        const homebeatReport = await cloudCMAAPIRequest('GET', `/homebeats/report?api_key=${CLOUDCMA_API_KEY}&format=json`);
        const homebeat = (homebeatReport || []).find(hb => hb.id === homebeatId);

        if (!homebeat) {
            throw new Error('Homebeat not found');
        }

        const homebeatPayload = {
            automation: {
                api_key: CLOUDCMA_API_KEY,
                frequency: homebeat.frequency || 'quarterly',
                welcome_email: 'true',
                subject_property: {
                    address: homebeat.property_address,
                    sqft: homebeat.sqft || null,
                    beds: homebeat.beds || null,
                    baths: homebeat.baths || null
                },
                lead: {
                    name: personData.name || '',
                    email_address: personData.emails?.[0]?.value || '',
                    phone: personData.phones?.[0]?.value || ''
                }
            }
        };

        await cloudCMAAPIRequest('POST', '/homebeats/widget', homebeatPayload);

        await fubAPIRequest('PUT', `/v1/people/${personId}`, {
            customWILLOWHomebeatLastResend: new Date().toISOString()
        });

        await fubAPIRequest('POST', '/v1/events', {
            person_id: parseInt(personId),
            type: 'Note',
            body: `Homebeat resent for ${homebeat.property_address}. Status was pending (0 views). Manual resend triggered.`
        });

        return {
            statusCode: 200,
            headers,
            body: JSON.stringify({ success: true })
        };

    } catch (error) {
        return {
            statusCode: 500,
            headers,
            body: JSON.stringify({ error: 'Failed to resend Homebeat: ' + error.message })
        };
    }
}

// Create task in FUB
async function createTask(params, headers) {
    try {
        const { personId, taskDescription, urgency, assignedTo } = params;

        const now = new Date();
        let dueDate = new Date(now);
        
        switch (urgency) {
            case 'IMMEDIATE':
                dueDate.setHours(now.getHours() + 24);
                break;
            case 'SAME_DAY':
                dueDate.setHours(23, 59, 59);
                break;
            case 'NEXT_DAY':
                dueDate.setDate(now.getDate() + 1);
                break;
            case 'WEEKLY':
                dueDate.setDate(now.getDate() + 7);
                break;
            default:
                dueDate.setDate(now.getDate() + 1);
        }

        const taskPayload = {
            person_id: parseInt(personId),
            type: 'Task',
            body: `${taskDescription}\n\nAssigned to: ${assignedTo}\nUrgency: ${urgency}`,
            dueDate: dueDate.toISOString()
        };

        await fubAPIRequest('POST', '/v1/events', taskPayload);

        return {
            statusCode: 200,
            headers,
            body: JSON.stringify({ success: true })
        };

    } catch (error) {
        return {
            statusCode: 500,
            headers,
            body: JSON.stringify({ error: 'Failed to create task: ' + error.message })
        };
    }
}

// Create manual action in FUB
async function createManualAction(params, headers) {
    try {
        const { personId, actionType, assignedTo, urgency, notes } = params;

        const now = new Date();
        let dueDate = new Date(now);
        
        switch (urgency) {
            case 'IMMEDIATE':
                dueDate.setHours(now.getHours() + 24);
                break;
            case 'SAME_DAY':
                dueDate.setHours(23, 59, 59);
                break;
            case 'NEXT_DAY':
                dueDate.setDate(now.getDate() + 1);
                break;
            case 'WEEKLY':
                dueDate.setDate(now.getDate() + 7);
                break;
            default:
                dueDate.setDate(now.getDate() + 1);
        }

        const actionPayload = {
            person_id: parseInt(personId),
            type: actionType,
            body: `${notes}\n\nAssigned to: ${assignedTo}\nUrgency: ${urgency}`,
            dueDate: actionType === 'Task' ? dueDate.toISOString() : undefined
        };

        await fubAPIRequest('POST', '/v1/events', actionPayload);

        return {
            statusCode: 200,
            headers,
            body: JSON.stringify({ success: true })
        };

    } catch (error) {
        return {
            statusCode: 500,
            headers,
            body: JSON.stringify({ error: 'Failed to create action: ' + error.message })
        };
    }
}

// FUB API Request Helper
function fubAPIRequest(method, path, data = null) {
    return new Promise((resolve, reject) => {
        const options = {
            hostname: 'api.followupboss.com',
            port: 443,
            path: path,
            method: method,
            headers: {
                'Authorization': `Basic ${Buffer.from(FUB_API_KEY + ':').toString('base64')}`,
                'Content-Type': 'application/json'
            }
        };

        const req = https.request(options, (res) => {
            let body = '';
            res.on('data', (chunk) => body += chunk);
            res.on('end', () => {
                try {
                    const parsed = JSON.parse(body);
                    if (res.statusCode >= 200 && res.statusCode < 300) {
                        resolve(parsed);
                    } else {
                        reject(new Error(`FUB API error: ${res.statusCode} - ${body}`));
                    }
                } catch (e) {
                    reject(new Error(`Failed to parse FUB response: ${body}`));
                }
            });
        });

        req.on('error', reject);
        
        if (data) {
            req.write(JSON.stringify(data));
        }
        
        req.end();
    });
}

// CloudCMA API Request Helper
function cloudCMAAPIRequest(method, path, data = null) {
    return new Promise((resolve, reject) => {
        const options = {
            hostname: 'cloudcma.com',
            port: 443,
            path: path,
            method: method,
            headers: {
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            }
        };

        const req = https.request(options, (res) => {
            let body = '';
            res.on('data', (chunk) => body += chunk);
            res.on('end', () => {
                try {
                    const parsed = body ? JSON.parse(body) : {};
                    if (res.statusCode >= 200 && res.statusCode < 300) {
                        resolve(parsed);
                    } else {
                        reject(new Error(`CloudCMA API error: ${res.statusCode} - ${body}`));
                    }
                } catch (e) {
                    if (res.statusCode >= 200 && res.statusCode < 300) {
                        resolve({});
                    } else {
                        reject(new Error(`Failed to parse CloudCMA response: ${body}`));
                    }
                }
            });
        });

        req.on('error', reject);
        
        if (data) {
            req.write(JSON.stringify(data));
        }
        
        req.end();
    });
}
