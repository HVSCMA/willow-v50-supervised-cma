// WILLOW V50 CMA Workbench - Complete Netlify Function
// Purpose: Server-side FUB/CloudCMA API integration with HTML serving

const https = require('https');

// API Credentials
const FUB_API_KEY = process.env.FUB_API_KEY || 'fka_0oHt62NxmsExO6x69p08ix82zx8ii1hzrj';
const CLOUDCMA_API_KEY = process.env.CLOUDCMA_API_KEY || '742f4a46e1780904da090d721a9bae7b';
const WEBHOOK_URL = 'https://willow-v50-supervised-cma.netlify.app/.netlify/functions/cloudcma-webhook';

exports.handler = async (event, context) => {
    // CORS headers
    const headers = {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': 'Content-Type',
        'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
        'Content-Type': 'application/json'
    };

    if (event.httpMethod === 'OPTIONS') {
        return { statusCode: 200, headers, body: '' };
    }

    try {
        // Parse request
        const params = event.httpMethod === 'GET' 
            ? event.queryStringParameters || {}
            : JSON.parse(event.body || '{}');

        const action = params.action;

        // If no action parameter, serve HTML interface (Base64 decoded)
        if (!action) {
            const htmlBase64 = 'PCFET0NUWVBFIGh0bWw+CjxodG1sIGxhbmc9ImVuIj4KPGhlYWQ+CiAgICA8bWV0YSBjaGFyc2V0PSJVVEYtOCI+CiAgICA8bWV0YSBuYW1lPSJ2aWV3cG9ydCIgY29udGVudD0id2lkdGg9ZGV2aWNlLXdpZHRoLCBpbml0aWFsLXNjYWxlPTEuMCwgdXNlci1zY2FsYWJsZT15ZXMiPgogICAgPHRpdGxlPkNNQSBXb3JrYmVuY2g8L3RpdGxlPgogICAgPHNjcmlwdCB0eXBlPSJ0ZXh0L2phdmFzY3JpcHQiIHNyYz0iaHR0cHM6Ly9laWEuZm9sbG93dXBib3NzLmNvbS9lbWJlZGRlZEFwcHMtdjEuMC4xLmpzIj48L3NjcmlwdD4KICAgIDxzdHlsZT4KICAgICAgICAqIHsKICAgICAgICAgICAgbWFyZ2luOiAwOwogICAgICAgICAgICBwYWRkaW5nOiAwOwogICAgICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94OwogICAgICAgIH0KCiAgICAgICAgYm9keSB7CiAgICAgICAgICAgIGZvbnQtZmFtaWx5OiAtYXBwbGUtc3lzdGVtLCBCbGlua01hY1N5c3RlbUZvbnQsICdTZWdvZSBVSScsIFJvYm90bywgc2Fucy1zZXJpZjsKICAgICAgICAgICAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KDEzNWRlZywgIzY2N2VlYSAwJSwgIzc2NGJhMiAxMDAlKTsKICAgICAgICAgICAgY29sb3I6ICMyZDM3NDg7CiAgICAgICAgICAgIGxpbmUtaGVpZ2h0OiAxLjQ7CiAgICAgICAgICAgIGZvbnQtc2l6ZTogMTNweDsKICAgICAgICAgICAgbWluLWhlaWdodDogMTAwdmg7CiAgICAgICAgICAgIHBhZGRpbmctYm90dG9tOiAzMHB4OwogICAgICAgIH0KCiAgICAgICAgLmNvbnRhaW5lciB7CiAgICAgICAgICAgIG1heC13aWR0aDogMTYwMHB4OwogICAgICAgICAgICBtYXJnaW46IDAgYXV0bzsKICAgICAgICAgICAgcGFkZGluZzogMTVweDsKICAgICAgICB9CgogICAgICAgIC5oZWFkZXIgewogICAgICAgICAgICBiYWNrZ3JvdW5kOiB3aGl0ZTsKICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogOHB4OwogICAgICAgICAgICBwYWRkaW5nOiAxNXB4IDIwcHg7CiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDE1cHg7CiAgICAgICAgICAgIGJveC1zaGFkb3c6IDAgMnB4IDRweCByZ2JhKDAsMCwwLDAuMSk7CiAgICAgICAgfQoKICAgICAgICAuaGVhZGVyIGgxIHsKICAgICAgICAgICAgZm9udC1zaXplOiAyMHB4OwogICAgICAgICAgICBjb2xvcjogIzY2N2VlYTsKICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogM3B4OwogICAgICAgIH0KCiAgICAgICAgLmhlYWRlciAuc3VidGl0bGUgewogICAgICAgICAgICBmb250LXNpemU6IDEycHg7CiAgICAgICAgICAgIGNvbG9yOiAjNzE4MDk2OwogICAgICAgIH0KCiAgICAgICAgLyogVEFCUyAqLwogICAgICAgIC50YWJzIHsKICAgICAgICAgICAgZGlzcGxheTogZmxleDsKICAgICAgICAgICAgZ2FwOiA4cHg7CiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDE1cHg7CiAgICAgICAgICAgIGZsZXgtd3JhcDogd3JhcDsKICAgICAgICB9CgogICAgICAgIC50YWItYnV0dG9uIHsKICAgICAgICAgICAgZmxleDogMTsKICAgICAgICAgICAgbWluLXdpZHRoOiAxMjBweDsKICAgICAgICAgICAgYmFja2dyb3VuZDogd2hpdGU7CiAgICAgICAgICAgIGJvcmRlcjogbm9uZTsKICAgICAgICAgICAgcGFkZGluZzogMTJweCAxNnB4OwogICAgICAgICAgICBib3JkZXItcmFkaXVzOiA4cHg7CiAgICAgICAgICAgIGZvbnQtc2l6ZTogMTRweDsKICAgICAgICAgICAgZm9udC13ZWlnaHQ6IDYwMDsKICAgICAgICAgICAgY3Vyc29yOiBwb2ludGVyOwogICAgICAgICAgICB0cmFuc2l0aW9uOiBhbGwgMC4zcyBlYXNlOwogICAgICAgICAgICBib3gtc2hhZG93OiAwIDJweCA0cHggcmdiYSgwLDAsMCwwLjEpOwogICAgICAgICAgICBjb2xvcjogIzRhNTU2ODsKICAgICAgICB9CgogICAgICAgIC50YWItYnV0dG9uOmhvdmVyIHsKICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC0ycHgpOwogICAgICAgICAgICBib3gtc2hhZG93OiAwIDRweCA4cHggcmdiYSgwLDAsMCwwLjE1KTsKICAgICAgICB9CgogICAgICAgIC50YWItYnV0dG9uLmFjdGl2ZSB7CiAgICAgICAgICAgIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCgxMzVkZWcsICM2NjdlZWEgMCUsICM3NjRiYTIgMTAwJSk7CiAgICAgICAgICAgIGNvbG9yOiB3aGl0ZTsKICAgICAgICB9CgogICAgICAgIC50YWItY29udGVudCB7CiAgICAgICAgICAgIGRpc3BsYXk6IG5vbmU7CiAgICAgICAgfQoKICAgICAgICAudGFiLWNvbnRlbnQuYWN0aXZlIHsKICAgICAgICAgICAgZGlzcGxheTogYmxvY2s7CiAgICAgICAgfQoKICAgICAgICAud29ya2JlbmNoIHsKICAgICAgICAgICAgYmFja2dyb3VuZDogd2hpdGU7CiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDhweDsKICAgICAgICAgICAgcGFkZGluZzogMjBweDsKICAgICAgICAgICAgYm94LXNoYWRvdzogMCAycHggNHB4IHJnYmEoMCwwLDAsMC4xKTsKICAgICAgICB9CgogICAgICAgIC8qIFBPV0VSRUQgQlkgRk9PVEVSICovCiAgICAgICAgLnBvd2VyZWQtYnkgewogICAgICAgICAgICBwb3NpdGlvbjogZml4ZWQ7CiAgICAgICAgICAgIGJvdHRvbTogMTBweDsKICAgICAgICAgICAgcmlnaHQ6IDE1cHg7CiAgICAgICAgICAgIGZvbnQtc2l6ZTogMTBweDsKICAgICAgICAgICAgY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC44KTsKICAgICAgICAgICAgZm9udC13ZWlnaHQ6IDYwMDsKICAgICAgICAgICAgei1pbmRleDogMTAwMDsKICAgICAgICAgICAgdGV4dC1zaGFkb3c6IDAgMXB4IDJweCByZ2JhKDAsMCwwLDAuMyk7CiAgICAgICAgICAgIGJhY2tncm91bmQ6IHJnYmEoMCwwLDAsMC4yKTsKICAgICAgICAgICAgcGFkZGluZzogNHB4IDEwcHg7CiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDRweDsKICAgICAgICB9CgogICAgICAgIC8qIERFTlNFIEdSSUQgTEFZT1VUIC0gUkVTUE9OU0lWRSAqLwogICAgICAgIC5wcm9wZXJ0eS1ncmlkIHsKICAgICAgICAgICAgZGlzcGxheTogZ3JpZDsKICAgICAgICAgICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiAxZnIgMWZyOwogICAgICAgICAgICBnYXA6IDE1cHg7CiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDE1cHg7CiAgICAgICAgfQoKICAgICAgICAuc2VjdGlvbi1jb21wYWN0IHsKICAgICAgICAgICAgYmFja2dyb3VuZDogI2Y3ZmFmYzsKICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogNnB4OwogICAgICAgICAgICBwYWRkaW5nOiAxMnB4OwogICAgICAgIH0KCiAgICAgICAgLnNlY3Rpb24tdGl0bGUtY29tcGFjdCB7CiAgICAgICAgICAgIGZvbnQtc2l6ZTogMTNweDsKICAgICAgICAgICAgZm9udC13ZWlnaHQ6IDcwMDsKICAgICAgICAgICAgY29sb3I6ICMyZDM3NDg7CiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDEwcHg7CiAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7CiAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7CiAgICAgICAgICAgIGdhcDogNnB4OwogICAgICAgICAgICBib3JkZXItYm90dG9tOiAycHggc29saWQgI2UyZThmMDsKICAgICAgICAgICAgcGFkZGluZy1ib3R0b206IDVweDsKICAgICAgICB9CgogICAgICAgIC8qIElORk8gQ0FSRCAqLwogICAgICAgIC5pbmZvLWNhcmQgewogICAgICAgICAgICBiYWNrZ3JvdW5kOiAjZjdmYWZjOwogICAgICAgICAgICBib3JkZXItbGVmdDogNHB4IHNvbGlkICM2NjdlZWE7CiAgICAgICAgICAgIHBhZGRpbmc6IDEycHggMTVweDsKICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogNnB4OwogICAgICAgICAgICBtYXJnaW46IDEwcHggMDsKICAgICAgICB9CgogICAgICAgIC5pbmZvLWNhcmQtdGl0bGUgewogICAgICAgICAgICBmb250LXdlaWdodDogNzAwOwogICAgICAgICAgICBjb2xvcjogIzJkMzc0ODsKICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogNXB4OwogICAgICAgICAgICBmb250LXNpemU6IDEzcHg7CiAgICAgICAgfQoKICAgICAgICAuaW5mby1jYXJkLWNvbnRlbnQgewogICAgICAgICAgICBjb2xvcjogIzcxODA5NjsKICAgICAgICAgICAgZm9udC1zaXplOiAxMnB4OwogICAgICAgIH0KCiAgICAgICAgLyogQVZNIENPTkZJREVOQ0UgQkFER0UgKi8KICAgICAgICAuYXZtLWhlYWRlciB7CiAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7CiAgICAgICAgICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjsKICAgICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjsKICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMTBweDsKICAgICAgICB9CgogICAgICAgIC5jb25maWRlbmNlLWJhZGdlIHsKICAgICAgICAgICAgcGFkZGluZzogM3B4IDEwcHg7CiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDRweDsKICAgICAgICAgICAgZm9udC1zaXplOiAxMHB4OwogICAgICAgICAgICBmb250LXdlaWdodDogNzAwOwogICAgICAgICAgICB0ZXh0LXRyYW5zZm9ybTogdXBwZXJjYXNlOwogICAgICAgICAgICBsZXR0ZXItc3BhY2luZzogMC41cHg7CiAgICAgICAgfQoKICAgICAgICAuY29uZmlkZW5jZS1ISUdIIHsKICAgICAgICAgICAgYmFja2dyb3VuZDogIzQ4YmI3ODsKICAgICAgICAgICAgY29sb3I6IHdoaXRlOwogICAgICAgIH0KCiAgICAgICAgLmNvbmZpZGVuY2UtTUVESVVNIHsKICAgICAgICAgICAgYmFja2dyb3VuZDogI2VkODkzNjsKICAgICAgICAgICAgY29sb3I6IHdoaXRlOwogICAgICAgIH0KCiAgICAgICAgLmNvbmZpZGVuY2UtTE9XIHsKICAgICAgICAgICAgYmFja2dyb3VuZDogI2ZjODE4MTsKICAgICAgICAgICAgY29sb3I6IHdoaXRlOwogICAgICAgIH0KCiAgICAgICAgLmNvbmZpZGVuY2UtVU5LTk9XTiB7CiAgICAgICAgICAgIGJhY2tncm91bmQ6ICNhMGFlYzA7CiAgICAgICAgICAgIGNvbG9yOiB3aGl0ZTsKICAgICAgICB9CgogICAgICAgIC8qIEVESVRBQkxFIENFTlRFUiBWQUxVRSAqLwogICAgICAgIC52YWx1ZS1jb250cm9sIHsKICAgICAgICAgICAgZGlzcGxheTogZ3JpZDsKICAgICAgICAgICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiAxZnIgMWZyOwogICAgICAgICAgICBnYXA6IDEwcHg7CiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDEycHg7CiAgICAgICAgfQoKICAgICAgICAudmFsdWUtaW5wdXQtZ3JvdXAgewogICAgICAgICAgICBkaXNwbGF5OiBmbGV4OwogICAgICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uOwogICAgICAgICAgICBnYXA6IDRweDsKICAgICAgICB9CgogICAgICAgIC52YWx1ZS1pbnB1dC1sYWJlbCB7CiAgICAgICAgICAgIGZvbnQtc2l6ZTogMTBweDsKICAgICAgICAgICAgZm9udC13ZWlnaHQ6IDYwMDsKICAgICAgICAgICAgY29sb3I6ICM3MTgwOTY7CiAgICAgICAgICAgIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7CiAgICAgICAgfQoKICAgICAgICAudmFsdWUtaW5wdXQgewogICAgICAgICAgICBwYWRkaW5nOiA4cHggMTBweDsKICAgICAgICAgICAgYm9yZGVyOiAycHggc29saWQgI2UyZThmMDsKICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogNnB4OwogICAgICAgICAgICBmb250LXNpemU6IDE0cHg7CiAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiA3MDA7CiAgICAgICAgICAgIGNvbG9yOiAjMmQzNzQ4OwogICAgICAgICAgICBiYWNrZ3JvdW5kOiB3aGl0ZTsKICAgICAgICB9CgogICAgICAgIC52YWx1ZS1pbnB1dDpmb2N1cyB7CiAgICAgICAgICAgIG91dGxpbmU6IG5vbmU7CiAgICAgICAgICAgIGJvcmRlci1jb2xvcjogIzY2N2VlYTsKICAgICAgICB9CgogICAgICAgIC52YWx1ZS1pbnB1dC5zdWdnZXN0ZWQgewogICAgICAgICAgICBiYWNrZ3JvdW5kOiAjZjBmZmY0OwogICAgICAgICAgICBib3JkZXItY29sb3I6ICM0OGJiNzg7CiAgICAgICAgfQoKICAgICAgICAudmFsdWUtaW5wdXQudXNlci1vdmVycmlkZSB7CiAgICAgICAgICAgIGJhY2tncm91bmQ6ICNmZmZhZjA7CiAgICAgICAgICAgIGJvcmRlci1jb2xvcjogI2VkODkzNjsKICAgICAgICB9CgogICAgICAgIC8qIERFTlNFIERBVEEgUk9XUyAqLwogICAgICAgIC5kYXRhLXJvdyB7CiAgICAgICAgICAgIGRpc3BsYXk6IGdyaWQ7CiAgICAgICAgICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogMTAwcHggMWZyOwogICAgICAgICAgICBnYXA6IDhweDsKICAgICAgICAgICAgcGFkZGluZzogNXB4IDA7CiAgICAgICAgICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjZWRmMmY3OwogICAgICAgICAgICBmb250LXNpemU6IDEycHg7CiAgICAgICAgfQoKICAgICAgICAuZGF0YS1yb3c6bGFzdC1jaGlsZCB7CiAgICAgICAgICAgIGJvcmRlci1ib3R0b206IG5vbmU7CiAgICAgICAgfQoKICAgICAgICAuZGF0YS1sYWJlbCB7CiAgICAgICAgICAgIGZvbnQtc2l6ZTogMTBweDsKICAgICAgICAgICAgZm9udC13ZWlnaHQ6IDYwMDsKICAgICAgICAgICAgY29sb3I6ICM3MTgwOTY7CiAgICAgICAgICAgIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7CiAgICAgICAgfQoKICAgICAgICAuZGF0YS12YWx1ZSB7CiAgICAgICAgICAgIGZvbnQtc2l6ZTogMTJweDsKICAgICAgICAgICAgZm9udC13ZWlnaHQ6IDYwMDsKICAgICAgICAgICAgY29sb3I6ICMyZDM3NDg7CiAgICAgICAgfQoKICAgICAgICAuZGF0YS12YWx1ZS5oaWdobGlnaHQgewogICAgICAgICAgICBjb2xvcjogIzY2N2VlYTsKICAgICAgICAgICAgZm9udC13ZWlnaHQ6IDcwMDsKICAgICAgICB9CgogICAgICAgIC5kYXRhLXZhbHVlLndhcm5pbmcgewogICAgICAgICAgICBjb2xvcjogI2VkODkzNjsKICAgICAgICAgICAgZm9udC13ZWlnaHQ6IDcwMDsKICAgICAgICB9CgogICAgICAgIC5kYXRhLXZhbHVlLmRhbmdlciB7CiAgICAgICAgICAgIGNvbG9yOiAjZmM4MTgxOwogICAgICAgICAgICBmb250LXdlaWdodDogNzAwOwogICAgICAgIH0KCiAgICAgICAgLmRhdGEtdmFsdWUuc3VjY2VzcyB7CiAgICAgICAgICAgIGNvbG9yOiAjNDhiYjc4OwogICAgICAgICAgICBmb250LXdlaWdodDogNzAwOwogICAgICAgIH0KCiAgICAgICAgLyogQ09NUEFDVCBQUk9QRVJUWSBDSEFSQUNURVJJU1RJQ1MgKi8KICAgICAgICAuY2hhci1ncmlkIHsKICAgICAgICAgICAgZGlzcGxheTogZ3JpZDsKICAgICAgICAgICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiByZXBlYXQoNCwgMWZyKTsKICAgICAgICAgICAgZ2FwOiA4cHg7CiAgICAgICAgICAgIG1hcmdpbjogOHB4IDA7CiAgICAgICAgfQoKICAgICAgICAuY2hhci1pdGVtIHsKICAgICAgICAgICAgYmFja2dyb3VuZDogd2hpdGU7CiAgICAgICAgICAgIGJvcmRlcjogMXB4IHNvbGlkICNlMmU4ZjA7CiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDZweDsKICAgICAgICAgICAgcGFkZGluZzogOHB4OwogICAgICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7CiAgICAgICAgfQoKICAgICAgICAuY2hhci12YWx1ZSB7CiAgICAgICAgICAgIGZvbnQtc2l6ZTogMTVweDsKICAgICAgICAgICAgZm9udC13ZWlnaHQ6IDcwMDsKICAgICAgICAgICAgY29sb3I6ICMyZDM3NDg7CiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDJweDsKICAgICAgICB9CgogICAgICAgIC5jaGFyLWxhYmVsIHsKICAgICAgICAgICAgZm9udC1zaXplOiA5cHg7CiAgICAgICAgICAgIGNvbG9yOiAjNzE4MDk2OwogICAgICAgICAgICB0ZXh0LXRyYW5zZm9ybTogdXBwZXJjYXNlOwogICAgICAgIH0KCiAgICAgICAgLyogUklTSyBGTEFHUyAqLwogICAgICAgIC5yaXNrLWZsYWdzIHsKICAgICAgICAgICAgZGlzcGxheTogZmxleDsKICAgICAgICAgICAgZmxleC13cmFwOiB3cmFwOwogICAgICAgICAgICBnYXA6IDZweDsKICAgICAgICAgICAgbWFyZ2luOiA4cHggMDsKICAgICAgICB9CgogICAgICAgIC5yaXNrLWZsYWcgewogICAgICAgICAgICBwYWRkaW5nOiAzcHggOHB4OwogICAgICAgICAgICBib3JkZXItcmFkaXVzOiA0cHg7CiAgICAgICAgICAgIGZvbnQtc2l6ZTogOXB4OwogICAgICAgICAgICBmb250LXdlaWdodDogNzAwOwogICAgICAgICAgICB0ZXh0LXRyYW5zZm9ybTogdXBwZXJjYXNlOwogICAgICAgIH0KCiAgICAgICAgLmZsYWctZGFuZ2VyIHsKICAgICAgICAgICAgYmFja2dyb3VuZDogI2ZmZjVmNTsKICAgICAgICAgICAgYm9yZGVyOiAxcHggc29saWQgI2ZjODE4MTsKICAgICAgICAgICAgY29sb3I6ICNjNTMwMzA7CiAgICAgICAgfQoKICAgICAgICAuZmxhZy13YXJuaW5nIHsKICAgICAgICAgICAgYmFja2dyb3VuZDogI2ZmZmFmMDsKICAgICAgICAgICAgYm9yZGVyOiAxcHggc29saWQgI2VkODkzNjsKICAgICAgICAgICAgY29sb3I6ICM3NDQyMTA7CiAgICAgICAgfQoKICAgICAgICAuZmxhZy1pbmZvIHsKICAgICAgICAgICAgYmFja2dyb3VuZDogI2ViZjhmZjsKICAgICAgICAgICAgYm9yZGVyOiAxcHggc29saWQgIzQyOTllMTsKICAgICAgICAgICAgY29sb3I6ICMyYzUyODI7CiAgICAgICAgfQoKICAgICAgICAuZmxhZy1zdWNjZXNzIHsKICAgICAgICAgICAgYmFja2dyb3VuZDogI2YwZmZmNDsKICAgICAgICAgICAgYm9yZGVyOiAxcHggc29saWQgIzQ4YmI3ODsKICAgICAgICAgICAgY29sb3I6ICMyMjU0M2Q7CiAgICAgICAgfQoKICAgICAgICAvKiBGT1JNIElOUFVUUyAtIENPTVBBQ1QgKi8KICAgICAgICAuZm9ybS1jb21wYWN0IHsKICAgICAgICAgICAgZGlzcGxheTogZ3JpZDsKICAgICAgICAgICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiByZXBlYXQoMiwgMWZyKTsKICAgICAgICAgICAgZ2FwOiAxMHB4OwogICAgICAgICAgICBtYXJnaW4tYm90dG9tOiAxMnB4OwogICAgICAgIH0KCiAgICAgICAgLmZvcm0tZ3JvdXAtY29tcGFjdCB7CiAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7CiAgICAgICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47CiAgICAgICAgICAgIGdhcDogNHB4OwogICAgICAgIH0KCiAgICAgICAgLmZvcm0tbGFiZWwtY29tcGFjdCB7CiAgICAgICAgICAgIGZvbnQtc2l6ZTogMTBweDsKICAgICAgICAgICAgZm9udC13ZWlnaHQ6IDYwMDsKICAgICAgICAgICAgY29sb3I6ICM3MTgwOTY7CiAgICAgICAgICAgIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7CiAgICAgICAgfQoKICAgICAgICAuZm9ybS1pbnB1dC1jb21wYWN0IHsKICAgICAgICAgICAgcGFkZGluZzogOHB4IDEwcHg7CiAgICAgICAgICAgIGJvcmRlcjogMnB4IHNvbGlkICNlMmU4ZjA7CiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDZweDsKICAgICAgICAgICAgZm9udC1zaXplOiAxM3B4OwogICAgICAgIH0KCiAgICAgICAgLmZvcm0taW5wdXQtY29tcGFjdDpmb2N1cyB7CiAgICAgICAgICAgIG91dGxpbmU6IG5vbmU7CiAgICAgICAgICAgIGJvcmRlci1jb2xvcjogIzY2N2VlYTsKICAgICAgICB9CgogICAgICAgIC5mb3JtLXNlbGVjdC1jb21wYWN0IHsKICAgICAgICAgICAgcGFkZGluZzogOHB4IDEwcHg7CiAgICAgICAgICAgIGJvcmRlcjogMnB4IHNvbGlkICNlMmU4ZjA7CiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDZweDsKICAgICAgICAgICAgZm9udC1zaXplOiAxM3B4OwogICAgICAgICAgICBiYWNrZ3JvdW5kOiB3aGl0ZTsKICAgICAgICAgICAgY3Vyc29yOiBwb2ludGVyOwogICAgICAgIH0KCiAgICAgICAgLmJ0biB7CiAgICAgICAgICAgIHBhZGRpbmc6IDEwcHggMjBweDsKICAgICAgICAgICAgYm9yZGVyOiBub25lOwogICAgICAgICAgICBib3JkZXItcmFkaXVzOiA2cHg7CiAgICAgICAgICAgIGZvbnQtc2l6ZTogMTRweDsKICAgICAgICAgICAgZm9udC13ZWlnaHQ6IDYwMDsKICAgICAgICAgICAgY3Vyc29yOiBwb2ludGVyOwogICAgICAgICAgICB0cmFuc2l0aW9uOiBhbGwgMC4zcyBlYXNlOwogICAgICAgIH0KCiAgICAgICAgLmJ0bi1wcmltYXJ5IHsKICAgICAgICAgICAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KDEzNWRlZywgIzY2N2VlYSAwJSwgIzc2NGJhMiAxMDAlKTsKICAgICAgICAgICAgY29sb3I6IHdoaXRlOwogICAgICAgIH0KCiAgICAgICAgLmJ0bi1wcmltYXJ5OmhvdmVyIHsKICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC0ycHgpOwogICAgICAgICAgICBib3gtc2hhZG93OiAwIDRweCA4cHggcmdiYSgxMDIsIDEyNiwgMjM0LCAwLjMpOwogICAgICAgIH0KCiAgICAgICAgLmJ0bi1zZWNvbmRhcnkgewogICAgICAgICAgICBiYWNrZ3JvdW5kOiAjZTJlOGYwOwogICAgICAgICAgICBjb2xvcjogIzRhNTU2ODsKICAgICAgICB9CgogICAgICAgIC5idG4tc2Vjb25kYXJ5OmhvdmVyIHsKICAgICAgICAgICAgYmFja2dyb3VuZDogI2NiZDVlMDsKICAgICAgICB9CgogICAgICAgIC5idG4tZ3JvdXAgewogICAgICAgICAgICBkaXNwbGF5OiBmbGV4OwogICAgICAgICAgICBnYXA6IDEwcHg7CiAgICAgICAgICAgIG1hcmdpbi10b3A6IDEycHg7CiAgICAgICAgICAgIGZsZXgtd3JhcDogd3JhcDsKICAgICAgICB9CgogICAgICAgIC5sb2FkaW5nIHsKICAgICAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyOwogICAgICAgICAgICBwYWRkaW5nOiAzMHB4OwogICAgICAgICAgICBjb2xvcjogIzcxODA5NjsKICAgICAgICB9CgogICAgICAgIC5zcGlubmVyIHsKICAgICAgICAgICAgYm9yZGVyOiA0cHggc29saWQgI2UyZThmMDsKICAgICAgICAgICAgYm9yZGVyLXRvcDogNHB4IHNvbGlkICM2NjdlZWE7CiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDUwJTsKICAgICAgICAgICAgd2lkdGg6IDMwcHg7CiAgICAgICAgICAgIGhlaWdodDogMzBweDsKICAgICAgICAgICAgYW5pbWF0aW9uOiBzcGluIDFzIGxpbmVhciBpbmZpbml0ZTsKICAgICAgICAgICAgbWFyZ2luOiAwIGF1dG8gMTVweDsKICAgICAgICB9CgogICAgICAgIEBrZXlmcmFtZXMgc3BpbiB7CiAgICAgICAgICAgIDAlIHsgdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7IH0KICAgICAgICAgICAgMTAwJSB7IHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7IH0KICAgICAgICB9CgogICAgICAgIC5lcnJvciB7CiAgICAgICAgICAgIGJhY2tncm91bmQ6ICNmZmY1ZjU7CiAgICAgICAgICAgIGJvcmRlcjogMnB4IHNvbGlkICNmYzgxODE7CiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDZweDsKICAgICAgICAgICAgcGFkZGluZzogMTJweDsKICAgICAgICAgICAgY29sb3I6ICNjNTMwMzA7CiAgICAgICAgICAgIG1hcmdpbjogMTJweCAwOwogICAgICAgICAgICBmb250LXNpemU6IDEycHg7CiAgICAgICAgfQoKICAgICAgICAuc3VjY2VzcyB7CiAgICAgICAgICAgIGJhY2tncm91bmQ6ICNmMGZmZjQ7CiAgICAgICAgICAgIGJvcmRlcjogMnB4IHNvbGlkICM2OGQzOTE7CiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDZweDsKICAgICAgICAgICAgcGFkZGluZzogMTJweDsKICAgICAgICAgICAgY29sb3I6ICMyMjU0M2Q7CiAgICAgICAgICAgIG1hcmdpbjogMTJweCAwOwogICAgICAgICAgICBmb250LXNpemU6IDEycHg7CiAgICAgICAgfQoKICAgICAgICAvKiBDT0xMQVBTSUJMRSBTRUNUSU9OUyAqLwogICAgICAgIC5jb2xsYXBzaWJsZSB7CiAgICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjsKICAgICAgICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7CiAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7CiAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7CiAgICAgICAgICAgIGdhcDogNnB4OwogICAgICAgIH0KCiAgICAgICAgLmNvbGxhcHNpYmxlOjpiZWZvcmUgewogICAgICAgICAgICBjb250ZW50OiAn4pa8JzsKICAgICAgICAgICAgZm9udC1zaXplOiA5cHg7CiAgICAgICAgICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSAwLjNzIGVhc2U7CiAgICAgICAgfQoKICAgICAgICAuY29sbGFwc2libGUuY29sbGFwc2VkOjpiZWZvcmUgewogICAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgtOTBkZWcpOwogICAgICAgIH0KCiAgICAgICAgLmNvbGxhcHNpYmxlLWNvbnRlbnQgewogICAgICAgICAgICBtYXgtaGVpZ2h0OiAyMDAwcHg7CiAgICAgICAgICAgIG92ZXJmbG93OiBoaWRkZW47CiAgICAgICAgICAgIHRyYW5zaXRpb246IG1heC1oZWlnaHQgMC4zcyBlYXNlOwogICAgICAgIH0KCiAgICAgICAgLmNvbGxhcHNpYmxlLWNvbnRlbnQuaGlkZGVuIHsKICAgICAgICAgICAgbWF4LWhlaWdodDogMDsKICAgICAgICB9CgogICAgICAgIC8qIE1PQklMRSBSRVNQT05TSVZFIC0gVE9VQ0ggRlJJRU5ETFkgKi8KICAgICAgICBAbWVkaWEgKG1heC13aWR0aDogNzY4cHgpIHsKICAgICAgICAgICAgYm9keSB7CiAgICAgICAgICAgICAgICBmb250LXNpemU6IDE0cHg7CiAgICAgICAgICAgICAgICB0b3VjaC1hY3Rpb246IG1hbmlwdWxhdGlvbjsKICAgICAgICAgICAgfQogICAgICAgICAgICAKICAgICAgICAgICAgLnByb3BlcnR5LWdyaWQgewogICAgICAgICAgICAgICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiAxZnI7CiAgICAgICAgICAgICAgICBnYXA6IDEycHg7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgCiAgICAgICAgICAgIC5jaGFyLWdyaWQgewogICAgICAgICAgICAgICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiByZXBlYXQoMiwgMWZyKTsKICAgICAgICAgICAgfQogICAgICAgICAgICAKICAgICAgICAgICAgLmZvcm0tY29tcGFjdCB7CiAgICAgICAgICAgICAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IDFmcjsKICAgICAgICAgICAgfQogICAgICAgICAgICAKICAgICAgICAgICAgLmNvbnRhaW5lciB7CiAgICAgICAgICAgICAgICBwYWRkaW5nOiAxMHB4OwogICAgICAgICAgICB9CiAgICAgICAgICAgIAogICAgICAgICAgICAud29ya2JlbmNoIHsKICAgICAgICAgICAgICAgIHBhZGRpbmc6IDE1cHg7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgCiAgICAgICAgICAgIC52YWx1ZS1jb250cm9sIHsKICAgICAgICAgICAgICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogMWZyOwogICAgICAgICAgICB9CiAgICAgICAgICAgIAogICAgICAgICAgICAudGFiLWJ1dHRvbiB7CiAgICAgICAgICAgICAgICBmb250LXNpemU6IDEycHg7CiAgICAgICAgICAgICAgICBwYWRkaW5nOiAxMHB4IDEycHg7CiAgICAgICAgICAgICAgICBtaW4td2lkdGg6IDkwcHg7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgCiAgICAgICAgICAgIC5idG4gewogICAgICAgICAgICAgICAgcGFkZGluZzogMTJweCAyMHB4OwogICAgICAgICAgICAgICAgZm9udC1zaXplOiAxNXB4OwogICAgICAgICAgICAgICAgd2lkdGg6IDEwMCU7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgCiAgICAgICAgICAgIC5idG4tZ3JvdXAgewogICAgICAgICAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjsKICAgICAgICAgICAgfQogICAgICAgICAgICAKICAgICAgICAgICAgLmZvcm0taW5wdXQtY29tcGFjdCwKICAgICAgICAgICAgLmZvcm0tc2VsZWN0LWNvbXBhY3QsCiAgICAgICAgICAgIC52YWx1ZS1pbnB1dCB7CiAgICAgICAgICAgICAgICBwYWRkaW5nOiAxMHB4IDEycHg7CiAgICAgICAgICAgICAgICBmb250LXNpemU6IDE2cHg7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIC5kYXRhLXJvdyB7CiAgICAgICAgICAgICAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IDkwcHggMWZyOwogICAgICAgICAgICB9CiAgICAgICAgfQogICAgPC9zdHlsZT4KPC9oZWFkPgo8Ym9keT4KICAgIDxkaXYgY2xhc3M9ImNvbnRhaW5lciI+CiAgICAgICAgPGRpdiBjbGFzcz0iaGVhZGVyIj4KICAgICAgICAgICAgPGgxPvCfjq8gQ01BIFdvcmtiZW5jaDwvaDE+CiAgICAgICAgICAgIDxkaXYgY2xhc3M9InN1YnRpdGxlIj5BVFRPTSBJbnRlbGxpZ2VuY2UgfCBMZWFkOiA8c3BhbiBpZD0ibGVhZE5hbWUiPkxvYWRpbmcuLi48L3NwYW4+PC9kaXY+CiAgICAgICAgPC9kaXY+CgogICAgICAgIDwhLS0gVEFCUyAtLT4KICAgICAgICA8ZGl2IGNsYXNzPSJ0YWJzIj4KICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz0idGFiLWJ1dHRvbiBhY3RpdmUiIG9uY2xpY2s9InN3aXRjaFRhYigncHJvcGVydHktaW50ZWwnKSI+CiAgICAgICAgICAgICAgICDwn5OKIFByb3BlcnR5IEludGVsCiAgICAgICAgICAgIDwvYnV0dG9uPgogICAgICAgICAgICA8YnV0dG9uIGNsYXNzPSJ0YWItYnV0dG9uIiBvbmNsaWNrPSJzd2l0Y2hUYWIoJ2NtYS1nZW5lcmF0b3InKSI+CiAgICAgICAgICAgICAgICDwn4+gIENNQSBHZW5lcmF0b3IKICAgICAgICAgICAgPC9idXR0b24+CiAgICAgICAgICAgIDxidXR0b24gY2xhc3M9InRhYi1idXR0b24iIG9uY2xpY2s9InN3aXRjaFRhYignY29tcGFyYWJsZXMnKSI+CiAgICAgICAgICAgICAgICDwn5OIIENvbXBhcmFibGVzCiAgICAgICAgICAgIDwvYnV0dG9uPgogICAgICAgIDwvZGl2PgoKICAgICAgICA8ZGl2IGNsYXNzPSJ3b3JrYmVuY2giPgogICAgICAgICAgICA8IS0tIFRBQiAxOiBQUk9QRVJUWSBJTlRFTExJR0VOQ0UgLS0+CiAgICAgICAgICAgIDxkaXYgaWQ9InByb3BlcnR5LWludGVsIiBjbGFzcz0idGFiLWNvbnRlbnQgYWN0aXZlIj4KICAgICAgICAgICAgICAgIDwhLS0gU0VDVElPTiAxOiBTVUJKRUNUIFBST1BFUlRZIEFERFJFU1MgLS0+CiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJzZWN0aW9uLWNvbXBhY3QiPgogICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InNlY3Rpb24tdGl0bGUtY29tcGFjdCI+8J+TjSBTdWJqZWN0IFByb3BlcnR5IEFkZHJlc3M8L2Rpdj4KICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJmb3JtLWdyb3VwLWNvbXBhY3QiIHN0eWxlPSJncmlkLWNvbHVtbjogMSAvIC0xOyI+CiAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz0iZm9ybS1sYWJlbC1jb21wYWN0Ij5GdWxsIEFkZHJlc3MgKENpdHksIFN0YXRlLCBaSVAgcmVxdWlyZWQpPC9sYWJlbD4KICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IAogICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT0idGV4dCIgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZD0ic3ViamVjdEFkZHJlc3MiIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9ImZvcm0taW5wdXQtY29tcGFjdCIgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj0iMTIzIE1haW4gU3QsIFBvdWdoa2VlcHNpZSwgTlkgMTI2MDEiCiAgICAgICAgICAgICAgICAgICAgICAgID4KICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPSJidG4gYnRuLXByaW1hcnkiIG9uY2xpY2s9ImxvYWRQcm9wZXJ0eURhdGEoKSIgc3R5bGU9Im1hcmdpbi10b3A6IDEwcHg7IHdpZHRoOiAxMDAlOyI+CiAgICAgICAgICAgICAgICAgICAgICAgIPCflI0gTG9hZCBBVFRPTSBJbnRlbGxpZ2VuY2UKICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj4KICAgICAgICAgICAgICAgIDwvZGl2PgoKICAgICAgICAgICAgICAgIDxkaXYgaWQ9ImxvYWRpbmdJbmRpY2F0b3IiIGNsYXNzPSJsb2FkaW5nIiBzdHlsZT0iZGlzcGxheTogbm9uZTsiPgogICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InNwaW5uZXIiPjwvZGl2PgogICAgICAgICAgICAgICAgICAgIDxkaXY+TG9hZGluZyBwcm9wZXJ0eSBpbnRlbGxpZ2VuY2UuLi48L2Rpdj4KICAgICAgICAgICAgICAgIDwvZGl2PgoKICAgICAgICAgICAgICAgIDxkaXYgaWQ9ImVycm9yTWVzc2FnZSIgY2xhc3M9ImVycm9yIiBzdHlsZT0iZGlzcGxheTogbm9uZTsiPjwvZGl2PgoKICAgICAgICAgICAgICAgIDwhLS0gUFJPUEVSVFkgSU5URUxMSUdFTkNFIEdSSUQgKEhpZGRlbiB1bnRpbCBkYXRhIGxvYWRlZCkgLS0+CiAgICAgICAgICAgICAgICA8ZGl2IGlkPSJwcm9wZXJ0eUludGVsbGlnZW5jZSIgc3R5bGU9ImRpc3BsYXk6IG5vbmU7Ij4KICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJwcm9wZXJ0eS1ncmlkIj4KICAgICAgICAgICAgICAgICAgICAgICAgPCEtLSBMRUZUIENPTFVNTjogQVZNICYgVkFMVUFUSU9OIC0tPgogICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJzZWN0aW9uLWNvbXBhY3QiPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iYXZtLWhlYWRlciI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0ic2VjdGlvbi10aXRsZS1jb21wYWN0Ij7wn5KwIEFWTTwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGlkPSJhdm1Db25maWRlbmNlQmFkZ2UiIGNsYXNzPSJjb25maWRlbmNlLWJhZGdlIGNvbmZpZGVuY2UtVU5LTk9XTiI+VU5LTk9XTjwvc3Bhbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwhLS0gRURJVEFCTEUgQ0VOVEVSIFZBTFVFIC0tPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0idmFsdWUtY29udHJvbCI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0idmFsdWUtaW5wdXQtZ3JvdXAiPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9InZhbHVlLWlucHV0LWxhYmVsIj5BVFRPTSBTdWdnZXN0ZWQ8L2xhYmVsPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlPSJ0ZXh0IiAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkPSJhdm1TdWdnZXN0ZWRWYWx1ZSIgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz0idmFsdWUtaW5wdXQgc3VnZ2VzdGVkIiAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRvbmx5CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj0iJDAiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJ2YWx1ZS1pbnB1dC1ncm91cCI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz0idmFsdWUtaW5wdXQtbGFiZWwiPllvdXIgQ2VudGVyIFZhbHVlPC9sYWJlbD4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT0idGV4dCIgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZD0iY2VudGVyVmFsdWUiIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9InZhbHVlLWlucHV0IHVzZXItb3ZlcnJpZGUiIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9Ik92ZXJyaWRlIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25jaGFuZ2U9InVwZGF0ZUNlbnRlclZhbHVlKCkiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImRhdGEtcm93Ij4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0iZGF0YS1sYWJlbCI+Q29uZmlkZW5jZTwvc3Bhbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBpZD0iYXZtU2NvcmUiIGNsYXNzPSJkYXRhLXZhbHVlIj4tLTwvc3Bhbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iZGF0YS1yb3ciPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSJkYXRhLWxhYmVsIj5SYW5nZTwvc3Bhbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBpZD0iYXZtUmFuZ2UiIGNsYXNzPSJkYXRhLXZhbHVlIj4tLTwvc3Bhbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iZGF0YS1yb3ciPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSJkYXRhLWxhYmVsIj5BVk0gRGF0ZTwvc3Bhbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBpZD0iYXZtRGF0ZSIgY2xhc3M9ImRhdGEtdmFsdWUiPi0tPC9zcGFuPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PgoKICAgICAgICAgICAgICAgICAgICAgICAgPCEtLSBSSUdIVCBDT0xVTU46IFNBTEVTIEhJU1RPUlkgLS0+CiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InNlY3Rpb24tY29tcGFjdCI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJzZWN0aW9uLXRpdGxlLWNvbXBhY3QiPvCfk4ggU2FsZXMgJiBWZWxvY2l0eTwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iZGF0YS1yb3ciPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSJkYXRhLWxhYmVsIj5MYXN0IFNhbGU8L3NwYW4+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gaWQ9Imxhc3RTYWxlRGF0ZSIgY2xhc3M9ImRhdGEtdmFsdWUiPi0tPC9zcGFuPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJkYXRhLXJvdyI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9ImRhdGEtbGFiZWwiPlNhbGUgUHJpY2U8L3NwYW4+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gaWQ9Imxhc3RTYWxlUHJpY2UiIGNsYXNzPSJkYXRhLXZhbHVlIj4tLTwvc3Bhbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iZGF0YS1yb3ciPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSJkYXRhLWxhYmVsIj5QcmljZS9TcUZ0PC9zcGFuPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGlkPSJwcmljZVBlclNxZnQiIGNsYXNzPSJkYXRhLXZhbHVlIj4tLTwvc3Bhbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iZGF0YS1yb3ciPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSJkYXRhLWxhYmVsIj5BcHByZWNpYXRpb248L3NwYW4+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gaWQ9ImFwcHJlY2lhdGlvbiIgY2xhc3M9ImRhdGEtdmFsdWUiPi0tPC9zcGFuPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJkYXRhLXJvdyI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9ImRhdGEtbGFiZWwiPlZlbG9jaXR5PC9zcGFuPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGlkPSJtYXJrZXRWZWxvY2l0eSIgY2xhc3M9ImRhdGEtdmFsdWUiPi0tPC9zcGFuPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgIDwvZGl2PgoKICAgICAgICAgICAgICAgICAgICA8IS0tIFBST1BFUlRZIENIQVJBQ1RFUklTVElDUyAtIENPTVBBQ1QgLS0+CiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0ic2VjdGlvbi1jb21wYWN0IiBzdHlsZT0ibWFyZ2luLWJvdHRvbTogMTVweDsiPgogICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJzZWN0aW9uLXRpdGxlLWNvbXBhY3QiPvCfj6AgUHJvcGVydHkgQ2hhcmFjdGVyaXN0aWNzPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImNoYXItZ3JpZCI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJjaGFyLWl0ZW0iPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgaWQ9ImNoYXJCZWRzIiBjbGFzcz0iY2hhci12YWx1ZSI+LS08L2Rpdj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJjaGFyLWxhYmVsIj5CZWRzPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImNoYXItaXRlbSI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD0iY2hhckJhdGhzIiBjbGFzcz0iY2hhci12YWx1ZSI+LS08L2Rpdj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJjaGFyLWxhYmVsIj5CYXRoczwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJjaGFyLWl0ZW0iPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgaWQ9ImNoYXJTcWZ0IiBjbGFzcz0iY2hhci12YWx1ZSI+LS08L2Rpdj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJjaGFyLWxhYmVsIj5TcUZ0PC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImNoYXItaXRlbSI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD0iY2hhckFjcmVzIiBjbGFzcz0iY2hhci12YWx1ZSI+LS08L2Rpdj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJjaGFyLWxhYmVsIj5BY3JlczwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJjaGFyLWl0ZW0iPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgaWQ9ImNoYXJHYXJhZ2UiIGNsYXNzPSJjaGFyLXZhbHVlIj4tLTwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImNoYXItbGFiZWwiPkdhcmFnZTwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJjaGFyLWl0ZW0iPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgaWQ9ImNoYXJUeXBlIiBjbGFzcz0iY2hhci12YWx1ZSI+LS08L2Rpdj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJjaGFyLWxhYmVsIj5UeXBlPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImNoYXItaXRlbSI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD0iY2hhclllYXIiIGNsYXNzPSJjaGFyLXZhbHVlIj4tLTwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImNoYXItbGFiZWwiPkJ1aWx0PC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImNoYXItaXRlbSI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD0iY2hhckNvbmRpdGlvbiIgY2xhc3M9ImNoYXItdmFsdWUiPi0tPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iY2hhci1sYWJlbCI+Q29uZGl0aW9uPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgPC9kaXY+CgogICAgICAgICAgICAgICAgICAgIDwhLS0gRVFVSVRZICYgT1dORVIgSU5URUxMSUdFTkNFIC0tPgogICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InByb3BlcnR5LWdyaWQiPgogICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJzZWN0aW9uLWNvbXBhY3QiPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0ic2VjdGlvbi10aXRsZS1jb21wYWN0Ij7wn5K1IEVxdWl0eSBJbnRlbGxpZ2VuY2U8L2Rpdj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImRhdGEtcm93Ij4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0iZGF0YS1sYWJlbCI+RXF1aXR5ICQ8L3NwYW4+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gaWQ9ImVxdWl0eURvbGxhcnMiIGNsYXNzPSJkYXRhLXZhbHVlIj4tLTwvc3Bhbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iZGF0YS1yb3ciPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSJkYXRhLWxhYmVsIj5FcXVpdHkgJTwvc3Bhbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBpZD0iZXF1aXR5UGVyY2VudCIgY2xhc3M9ImRhdGEtdmFsdWUiPi0tPC9zcGFuPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJkYXRhLXJvdyI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9ImRhdGEtbGFiZWwiPkxUViBSYXRpbzwvc3Bhbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBpZD0ibHR2UmF0aW8iIGNsYXNzPSJkYXRhLXZhbHVlIj4tLTwvc3Bhbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iZGF0YS1yb3ciPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSJkYXRhLWxhYmVsIj5TdGF0dXM8L3NwYW4+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gaWQ9ImVxdWl0eVN0YXR1cyIgY2xhc3M9ImRhdGEtdmFsdWUiPi0tPC9zcGFuPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PgoKICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0ic2VjdGlvbi1jb21wYWN0Ij4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InNlY3Rpb24tdGl0bGUtY29tcGFjdCI+8J+RpCBPd25lciBJbnRlbDwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iZGF0YS1yb3ciPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSJkYXRhLWxhYmVsIj5Pd25lcjwvc3Bhbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBpZD0ib3duZXJOYW1lIiBjbGFzcz0iZGF0YS12YWx1ZSI+LS08L3NwYW4+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImRhdGEtcm93Ij4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0iZGF0YS1sYWJlbCI+VHlwZTwvc3Bhbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBpZD0ib3duZXJUeXBlIiBjbGFzcz0iZGF0YS12YWx1ZSI+LS08L3NwYW4+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImRhdGEtcm93Ij4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0iZGF0YS1sYWJlbCI+WWVhcnMgT3duZWQ8L3NwYW4+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gaWQ9Im93bmVyc2hpcExlbmd0aCIgY2xhc3M9ImRhdGEtdmFsdWUiPi0tPC9zcGFuPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGlkPSJvd25lckZsYWdzIiBjbGFzcz0icmlzay1mbGFncyIgc3R5bGU9Im1hcmdpbi10b3A6IDZweDsiPjwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KCiAgICAgICAgICAgICAgICAgICAgPCEtLSBSSVNLICYgRU5WSVJPTk1FTlRBTCAtLT4KICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJwcm9wZXJ0eS1ncmlkIj4KICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0ic2VjdGlvbi1jb21wYWN0Ij4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InNlY3Rpb24tdGl0bGUtY29tcGFjdCI+8J+MjSBFbnZpcm9ubWVudGFsPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJkYXRhLXJvdyI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9ImRhdGEtbGFiZWwiPkZsb29kIFpvbmU8L3NwYW4+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gaWQ9ImZsb29kWm9uZSIgY2xhc3M9ImRhdGEtdmFsdWUiPi0tPC9zcGFuPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJkYXRhLXJvdyI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9ImRhdGEtbGFiZWwiPkZsb29kIFJpc2s8L3NwYW4+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gaWQ9ImZsb29kUmlzayIgY2xhc3M9ImRhdGEtdmFsdWUiPi0tPC9zcGFuPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGlkPSJlbnZpcm9ubWVudGFsRmxhZ3MiIGNsYXNzPSJyaXNrLWZsYWdzIiBzdHlsZT0ibWFyZ2luLXRvcDogNnB4OyI+PC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PgoKICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0ic2VjdGlvbi1jb21wYWN0Ij4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InNlY3Rpb24tdGl0bGUtY29tcGFjdCI+8J+PqyBTY2hvb2xzPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJkYXRhLXJvdyI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9ImRhdGEtbGFiZWwiPkRpc3RyaWN0PC9zcGFuPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGlkPSJzY2hvb2xEaXN0cmljdCIgY2xhc3M9ImRhdGEtdmFsdWUiPi0tPC9zcGFuPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJkYXRhLXJvdyI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9ImRhdGEtbGFiZWwiPkVsZW1lbnRhcnk8L3NwYW4+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gaWQ9InNjaG9vbEVsZW1lbnRhcnkiIGNsYXNzPSJkYXRhLXZhbHVlIj4tLTwvc3Bhbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iZGF0YS1yb3ciPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSJkYXRhLWxhYmVsIj5IaWdoIFNjaG9vbDwvc3Bhbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBpZD0ic2Nob29sSGlnaCIgY2xhc3M9ImRhdGEtdmFsdWUiPi0tPC9zcGFuPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgIDwvZGl2PgoKICAgICAgICAgICAgICAgICAgICA8IS0tIERJU1RSRVNTIEZMQUdTIChJZiBhbnkpIC0tPgogICAgICAgICAgICAgICAgICAgIDxkaXYgaWQ9ImRpc3RyZXNzU2VjdGlvbiIgY2xhc3M9InNlY3Rpb24tY29tcGFjdCIgc3R5bGU9ImRpc3BsYXk6IG5vbmU7IG1hcmdpbi1ib3R0b206IDE1cHg7Ij4KICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0ic2VjdGlvbi10aXRsZS1jb21wYWN0Ij7imqDvuI8gRGlzdHJlc3MgSW5kaWNhdG9yczwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGlkPSJkaXN0cmVzc0ZsYWdzIiBjbGFzcz0icmlzay1mbGFncyI+PC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgaWQ9ImRpc3RyZXNzRGV0YWlscyIgc3R5bGU9Im1hcmdpbi10b3A6IDhweDsgZm9udC1zaXplOiAxMXB4OyBjb2xvcjogIzRhNTU2ODsiPjwvZGl2PgogICAgICAgICAgICAgICAgICAgIDwvZGl2PgoKICAgICAgICAgICAgICAgICAgICA8IS0tIENPTExBUFNJQkxFOiBBRERJVElPTkFMIERFVEFJTFMgLS0+CiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0ic2VjdGlvbi1jb21wYWN0Ij4KICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0ic2VjdGlvbi10aXRsZS1jb21wYWN0IGNvbGxhcHNpYmxlIiBvbmNsaWNrPSJ0b2dnbGVDb2xsYXBzaWJsZSgnYWRkaXRpb25hbERldGFpbHMnKSI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICDwn5OLIEFkZGl0aW9uYWwgRGV0YWlscwogICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD0iYWRkaXRpb25hbERldGFpbHMiIGNsYXNzPSJjb2xsYXBzaWJsZS1jb250ZW50Ij4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImRhdGEtcm93Ij4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0iZGF0YS1sYWJlbCI+U3Rvcmllczwvc3Bhbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBpZD0iZGV0YWlsU3RvcmllcyIgY2xhc3M9ImRhdGEtdmFsdWUiPi0tPC9zcGFuPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJkYXRhLXJvdyI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9ImRhdGEtbGFiZWwiPlF1YWxpdHk8L3NwYW4+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gaWQ9ImRldGFpbFF1YWxpdHkiIGNsYXNzPSJkYXRhLXZhbHVlIj4tLTwvc3Bhbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iZGF0YS1yb3ciPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSJkYXRhLWxhYmVsIj5Qb29sPC9zcGFuPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGlkPSJkZXRhaWxQb29sIiBjbGFzcz0iZGF0YS12YWx1ZSI+LS08L3NwYW4+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImRhdGEtcm93Ij4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0iZGF0YS1sYWJlbCI+RmlyZXBsYWNlPC9zcGFuPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGlkPSJkZXRhaWxGaXJlcGxhY2UiIGNsYXNzPSJkYXRhLXZhbHVlIj4tLTwvc3Bhbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iZGF0YS1yb3ciPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSJkYXRhLWxhYmVsIj5IZWF0aW5nPC9zcGFuPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGlkPSJkZXRhaWxIZWF0aW5nIiBjbGFzcz0iZGF0YS12YWx1ZSI+LS08L3NwYW4+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImRhdGEtcm93Ij4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0iZGF0YS1sYWJlbCI+Q29vbGluZzwvc3Bhbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBpZD0iZGV0YWlsQ29vbGluZyIgY2xhc3M9ImRhdGEtdmFsdWUiPi0tPC9zcGFuPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJkYXRhLXJvdyI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9ImRhdGEtbGFiZWwiPlRheCBBbW91bnQ8L3NwYW4+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gaWQ9ImRldGFpbFRheEFtb3VudCIgY2xhc3M9ImRhdGEtdmFsdWUiPi0tPC9zcGFuPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJkYXRhLXJvdyI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9ImRhdGEtbGFiZWwiPlRheC9TcUZ0PC9zcGFuPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGlkPSJkZXRhaWxUYXhQZXJTcWZ0IiBjbGFzcz0iZGF0YS12YWx1ZSI+LS08L3NwYW4+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImRhdGEtcm93Ij4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0iZGF0YS1sYWJlbCI+QVRUT00gSUQ8L3NwYW4+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gaWQ9ImRldGFpbEF0dG9tSWQiIGNsYXNzPSJkYXRhLXZhbHVlIj4tLTwvc3Bhbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICA8L2Rpdj4KCiAgICAgICAgICAgIDwhLS0gVEFCIDI6IENNQSBHRU5FUkFUT1IgLS0+CiAgICAgICAgICAgIDxkaXYgaWQ9ImNtYS1nZW5lcmF0b3IiIGNsYXNzPSJ0YWItY29udGVudCI+CiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJzZWN0aW9uLWNvbXBhY3QiPgogICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InNlY3Rpb24tdGl0bGUtY29tcGFjdCI+8J+TiiBHZW5lcmF0ZSBDTUEgUmVwb3J0PC9kaXY+CiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iZm9ybS1jb21wYWN0Ij4KICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iZm9ybS1ncm91cC1jb21wYWN0Ij4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz0iZm9ybS1sYWJlbC1jb21wYWN0Ij5TZWFyY2ggUmFkaXVzIChtaWxlcyk8L2xhYmVsPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9Im51bWJlciIgaWQ9ImNtYVJhZGl1cyIgY2xhc3M9ImZvcm0taW5wdXQtY29tcGFjdCIgdmFsdWU9IjMiIG1pbj0iMSIgbWF4PSIxMCI+CiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJmb3JtLWdyb3VwLWNvbXBhY3QiPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPSJmb3JtLWxhYmVsLWNvbXBhY3QiPkRheXMgQmFjazwvbGFiZWw+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT0ibnVtYmVyIiBpZD0iY21hRGF5c0JhY2siIGNsYXNzPSJmb3JtLWlucHV0LWNvbXBhY3QiIHZhbHVlPSIxODAiIG1pbj0iMzAiIG1heD0iNzMwIj4KICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImZvcm0tZ3JvdXAtY29tcGFjdCI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9ImZvcm0tbGFiZWwtY29tcGFjdCI+TWF4IENvbXBhcmFibGVzPC9sYWJlbD4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPSJudW1iZXIiIGlkPSJjbWFNYXhDb21wcyIgY2xhc3M9ImZvcm0taW5wdXQtY29tcGFjdCIgdmFsdWU9IjEwIiBtaW49IjMiIG1heD0iMjAiPgogICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iZm9ybS1ncm91cC1jb21wYWN0Ij4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz0iZm9ybS1sYWJlbC1jb21wYWN0Ij5QcmljZSBWYXJpYW5jZSAoJSk8L2xhYmVsPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9Im51bWJlciIgaWQ9ImNtYVByaWNlVmFyaWFuY2UiIGNsYXNzPSJmb3JtLWlucHV0LWNvbXBhY3QiIHZhbHVlPSIyNSIgbWluPSIxMCIgbWF4PSI1MCI+CiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImJ0bi1ncm91cCI+CiAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9ImJ0biBidG4tcHJpbWFyeSIgb25jbGljaz0iZ2VuZXJhdGVDTUEoKSI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICDwn5OKIEdlbmVyYXRlIENNQSBSZXBvcnQKICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+CiAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9ImJ0biBidG4tc2Vjb25kYXJ5IiBvbmNsaWNrPSJleHBvcnREYXRhKCkiPgogICAgICAgICAgICAgICAgICAgICAgICAgICAg8J+SviBFeHBvcnQgdG8gRlVCCiAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPgogICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgIDwvZGl2PgoKICAgICAgICAgICAgPCEtLSBUQUIgMzogQ09NUEFSQUJMRVMgKFBMQUNFSE9MREVSKSAtLT4KICAgICAgICAgICAgPGRpdiBpZD0iY29tcGFyYWJsZXMiIGNsYXNzPSJ0YWItY29udGVudCI+CiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJzZWN0aW9uLWNvbXBhY3QiPgogICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InNlY3Rpb24tdGl0bGUtY29tcGFjdCI+8J+TiCBDb21wYXJhYmxlIFByb3BlcnRpZXM8L2Rpdj4KICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJpbmZvLWNhcmQiPgogICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJpbmZvLWNhcmQtdGl0bGUiPkNvbWluZyBTb29uPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImluZm8tY2FyZC1jb250ZW50Ij4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoaXMgdGFiIHdpbGwgZGlzcGxheSBjb21wYXJhYmxlIHByb3BlcnRpZXMgZnJvbSBDbG91ZENNQSBhZnRlciBDTUEgZ2VuZXJhdGlvbi4KICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgPC9kaXY+CiAgICA8L2Rpdj4KCiAgICA8IS0tIFBvd2VyZWQgQnkgRm9vdGVyIC0tPgogICAgPGRpdiBjbGFzcz0icG93ZXJlZC1ieSI+UG93ZXJlZCBieSBXSUxMT1c8L2Rpdj4KCiAgICA8c2NyaXB0PgogICAgICAgIGxldCBjdXJyZW50UHJvcGVydHlEYXRhID0gbnVsbDsKICAgICAgICBsZXQgZnViQ29udGV4dCA9IG51bGw7CgogICAgICAgIC8vIEluaXRpYWxpemUgRlVCIGVtYmVkZGVkIGFwcAogICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgYXN5bmMgZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgICBmdWJDb250ZXh0ID0gYXdhaXQgRlVCLmdldENvbnRleHQoKTsKICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGVUIgQ29udGV4dDonLCBmdWJDb250ZXh0KTsKICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgaWYgKGZ1YkNvbnRleHQgJiYgZnViQ29udGV4dC5wZXJzb24pIHsKICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbGVhZE5hbWUnKS50ZXh0Q29udGVudCA9IAogICAgICAgICAgICAgICAgICAgICAgICBmdWJDb250ZXh0LnBlcnNvbi5uYW1lIHx8ICdVbmtub3duIExlYWQnOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9IGNhdGNoIChlcnJvcikgewogICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGxvYWQgRlVCIGNvbnRleHQ6JywgZXJyb3IpOwogICAgICAgICAgICB9CiAgICAgICAgfSk7CgogICAgICAgIC8vIFN3aXRjaCBiZXR3ZWVuIHRhYnMKICAgICAgICBmdW5jdGlvbiBzd2l0Y2hUYWIodGFiSWQpIHsKICAgICAgICAgICAgLy8gSGlkZSBhbGwgdGFiIGNvbnRlbnRzCiAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy50YWItY29udGVudCcpLmZvckVhY2godGFiID0+IHsKICAgICAgICAgICAgICAgIHRhYi5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTsKICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIAogICAgICAgICAgICAvLyBSZW1vdmUgYWN0aXZlIGZyb20gYWxsIHRhYiBidXR0b25zCiAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy50YWItYnV0dG9uJykuZm9yRWFjaChidXR0b24gPT4gewogICAgICAgICAgICAgICAgYnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpOwogICAgICAgICAgICB9KTsKICAgICAgICAgICAgCiAgICAgICAgICAgIC8vIFNob3cgc2VsZWN0ZWQgdGFiCiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRhYklkKS5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTsKICAgICAgICAgICAgCiAgICAgICAgICAgIC8vIEFjdGl2YXRlIGNvcnJlc3BvbmRpbmcgYnV0dG9uCiAgICAgICAgICAgIGV2ZW50LnRhcmdldC5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTsKICAgICAgICB9CgogICAgICAgIC8vIExvYWQgcHJvcGVydHkgZGF0YSBmcm9tIEFUVE9NIEFQSQogICAgICAgIGFzeW5jIGZ1bmN0aW9uIGxvYWRQcm9wZXJ0eURhdGEoKSB7CiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3ViamVjdEFkZHJlc3MnKS52YWx1ZS50cmltKCk7CiAgICAgICAgICAgIAogICAgICAgICAgICBpZiAoIWFkZHJlc3MpIHsKICAgICAgICAgICAgICAgIGFsZXJ0KCdQbGVhc2UgZW50ZXIgYSBwcm9wZXJ0eSBhZGRyZXNzJyk7CiAgICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIC8vIFNob3cgbG9hZGluZyBpbmRpY2F0b3IKICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xvYWRpbmdJbmRpY2F0b3InKS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJzsKICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Vycm9yTWVzc2FnZScpLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7CiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwcm9wZXJ0eUludGVsbGlnZW5jZScpLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7CgogICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgICAgY29uc3QgcGVyc29uSWQgPSBmdWJDb250ZXh0Py5wZXJzb24/LmlkIHx8IG51bGw7CiAgICAgICAgICAgICAgICBjb25zdCB1cmwgPSBgLy5uZXRsaWZ5L2Z1bmN0aW9ucy9hdHRvbS1wcm9wZXJ0eS1sb29rdXA/YWRkcmVzcz0ke2VuY29kZVVSSUNvbXBvbmVudChhZGRyZXNzKX0ke3BlcnNvbklkID8gJyZwZXJzb25JZD0nICsgcGVyc29uSWQgOiAnJ31gOwogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCk7CiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7CgogICAgICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vayB8fCAhcmVzdWx0LnN1Y2Nlc3MpIHsKICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVzdWx0Lm1lc3NhZ2UgfHwgJ0ZhaWxlZCB0byBsb2FkIHByb3BlcnR5IGRhdGEnKTsKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICBjdXJyZW50UHJvcGVydHlEYXRhID0gcmVzdWx0LmRhdGE7CiAgICAgICAgICAgICAgICBkaXNwbGF5UHJvcGVydHlEYXRhKGN1cnJlbnRQcm9wZXJ0eURhdGEpOwoKICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsb2FkaW5nSW5kaWNhdG9yJykuc3R5bGUuZGlzcGxheSA9ICdub25lJzsKICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwcm9wZXJ0eUludGVsbGlnZW5jZScpLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snOwoKICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHsKICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgcHJvcGVydHkgZGF0YTonLCBlcnJvcik7CiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbG9hZGluZ0luZGljYXRvcicpLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7CiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZXJyb3JNZXNzYWdlJykuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7CiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZXJyb3JNZXNzYWdlJykudGV4dENvbnRlbnQgPSAKICAgICAgICAgICAgICAgICAgICAnRXJyb3I6ICcgKyBlcnJvci5tZXNzYWdlOwogICAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICAvLyBEaXNwbGF5IHByb3BlcnR5IGRhdGEgaW4gVUkKICAgICAgICBmdW5jdGlvbiBkaXNwbGF5UHJvcGVydHlEYXRhKGRhdGEpIHsKICAgICAgICAgICAgLy8gQVZNIFNlY3Rpb24KICAgICAgICAgICAgaWYgKGRhdGEuYXZtKSB7CiAgICAgICAgICAgICAgICBjb25zdCBzdWdnZXN0ZWRWYWx1ZSA9IGRhdGEuYXZtLnZhbHVlIHx8IDA7CiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYXZtU3VnZ2VzdGVkVmFsdWUnKS52YWx1ZSA9IGZvcm1hdEN1cnJlbmN5KHN1Z2dlc3RlZFZhbHVlKTsKICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjZW50ZXJWYWx1ZScpLnZhbHVlID0gZm9ybWF0Q3VycmVuY3koc3VnZ2VzdGVkVmFsdWUpOwogICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NlbnRlclZhbHVlJykucGxhY2Vob2xkZXIgPSBmb3JtYXRDdXJyZW5jeShzdWdnZXN0ZWRWYWx1ZSk7CiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhdm1TY29yZScpLnRleHRDb250ZW50ID0gZGF0YS5hdm0uY29uZmlkZW5jZVNjb3JlIHx8ICctLSc7CiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYXZtQ29uZmlkZW5jZUJhZGdlJykudGV4dENvbnRlbnQgPSBkYXRhLmF2bS5jb25maWRlbmNlTGV2ZWwgfHwgJ1VOS05PV04nOwogICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2F2bUNvbmZpZGVuY2VCYWRnZScpLmNsYXNzTmFtZSA9IAogICAgICAgICAgICAgICAgICAgICdjb25maWRlbmNlLWJhZGdlIGNvbmZpZGVuY2UtJyArIChkYXRhLmF2bS5jb25maWRlbmNlTGV2ZWwgfHwgJ1VOS05PV04nKTsKICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2F2bVJhbmdlJykudGV4dENvbnRlbnQgPSAKICAgICAgICAgICAgICAgICAgICBgJHtmb3JtYXRDdXJyZW5jeShkYXRhLmF2bS52YWx1ZUxvdyl9IC0gJHtmb3JtYXRDdXJyZW5jeShkYXRhLmF2bS52YWx1ZUhpZ2gpfWA7CiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYXZtRGF0ZScpLnRleHRDb250ZW50ID0gCiAgICAgICAgICAgICAgICAgICAgZGF0YS5hdm0uZGF0ZSA/IG5ldyBEYXRlKGRhdGEuYXZtLmRhdGUpLnRvTG9jYWxlRGF0ZVN0cmluZygpIDogJy0tJzsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgLy8gU2FsZXMgSGlzdG9yeQogICAgICAgICAgICBpZiAoZGF0YS5zYWxlSGlzdG9yeSkgewogICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xhc3RTYWxlRGF0ZScpLnRleHRDb250ZW50ID0gCiAgICAgICAgICAgICAgICAgICAgZGF0YS5zYWxlSGlzdG9yeS5sYXN0U2FsZURhdGUgPyBuZXcgRGF0ZShkYXRhLnNhbGVIaXN0b3J5Lmxhc3RTYWxlRGF0ZSkudG9Mb2NhbGVEYXRlU3RyaW5nKCkgOiAnLS0nOwogICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xhc3RTYWxlUHJpY2UnKS50ZXh0Q29udGVudCA9IAogICAgICAgICAgICAgICAgICAgIGZvcm1hdEN1cnJlbmN5KGRhdGEuc2FsZUhpc3RvcnkubGFzdFNhbGVQcmljZSk7CiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncHJpY2VQZXJTcWZ0JykudGV4dENvbnRlbnQgPSAKICAgICAgICAgICAgICAgICAgICBkYXRhLnNhbGVIaXN0b3J5LnByaWNlUGVyU3FmdCA/ICckJyArIGRhdGEuc2FsZUhpc3RvcnkucHJpY2VQZXJTcWZ0IDogJy0tJzsKICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgaWYgKGRhdGEuc2FsZUhpc3RvcnkuYXBwcmVjaWF0aW9uKSB7CiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXBwRG9sbGFycyA9IGRhdGEuc2FsZUhpc3RvcnkuYXBwcmVjaWF0aW9uLmRvbGxhcnM7CiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXBwUGVyY2VudCA9IGRhdGEuc2FsZUhpc3RvcnkuYXBwcmVjaWF0aW9uLnBlcmNlbnRhZ2U7CiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FwcHJlY2lhdGlvbicpLmlubmVySFRNTCA9IAogICAgICAgICAgICAgICAgICAgICAgICBgPHNwYW4gY2xhc3M9IiR7YXBwRG9sbGFycyA+PSAwID8gJ3N1Y2Nlc3MnIDogJ2Rhbmdlcid9Ij4ke2Zvcm1hdEN1cnJlbmN5KGFwcERvbGxhcnMpfSAoJHthcHBQZXJjZW50fSUpPC9zcGFuPmA7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgIGNvbnN0IHZlbG9jaXR5ID0gZGF0YS5zYWxlSGlzdG9yeS5tYXJrZXRWZWxvY2l0eSB8fCAnVU5LTk9XTic7CiAgICAgICAgICAgICAgICBjb25zdCB2ZWxvY2l0eUNsYXNzID0gdmVsb2NpdHkgPT09ICdIT1QnID8gJ2RhbmdlcicgOiB2ZWxvY2l0eSA9PT0gJ1dBUk0nID8gJ3dhcm5pbmcnIDogJ2hpZ2hsaWdodCc7CiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWFya2V0VmVsb2NpdHknKS5pbm5lckhUTUwgPSAKICAgICAgICAgICAgICAgICAgICBgPHNwYW4gY2xhc3M9IiR7dmVsb2NpdHlDbGFzc30iPiR7dmVsb2NpdHl9PC9zcGFuPmA7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIC8vIFByb3BlcnR5IENoYXJhY3RlcmlzdGljcwogICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2hhckJlZHMnKS50ZXh0Q29udGVudCA9IGRhdGEuYmVkcyB8fCAnLS0nOwogICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2hhckJhdGhzJykudGV4dENvbnRlbnQgPSBkYXRhLmJhdGhzIHx8ICctLSc7CiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjaGFyU3FmdCcpLnRleHRDb250ZW50ID0gZGF0YS5zcWZ0ID8gZGF0YS5zcWZ0LnRvTG9jYWxlU3RyaW5nKCkgOiAnLS0nOwogICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2hhckFjcmVzJykudGV4dENvbnRlbnQgPSBkYXRhLmFjcmVzIHx8ICctLSc7CiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjaGFyR2FyYWdlJykudGV4dENvbnRlbnQgPSBkYXRhLmdhcmFnZSB8fCAnLS0nOwogICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2hhclR5cGUnKS50ZXh0Q29udGVudCA9IGRhdGEucHJvcGVydHlUeXBlIHx8ICctLSc7CiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjaGFyWWVhcicpLnRleHRDb250ZW50ID0gZGF0YS55ZWFyQnVpbHQgfHwgJy0tJzsKICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NoYXJDb25kaXRpb24nKS50ZXh0Q29udGVudCA9IGRhdGEuY29uZGl0aW9uIHx8ICctLSc7CgogICAgICAgICAgICAvLyBFcXVpdHkKICAgICAgICAgICAgaWYgKGRhdGEuZXF1aXR5KSB7CiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZXF1aXR5RG9sbGFycycpLnRleHRDb250ZW50ID0gZm9ybWF0Q3VycmVuY3koZGF0YS5lcXVpdHkuZXF1aXR5RG9sbGFycyk7CiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZXF1aXR5UGVyY2VudCcpLnRleHRDb250ZW50ID0gCiAgICAgICAgICAgICAgICAgICAgZGF0YS5lcXVpdHkuZXF1aXR5UGVyY2VudGFnZSA/IGRhdGEuZXF1aXR5LmVxdWl0eVBlcmNlbnRhZ2UgKyAnJScgOiAnLS0nOwogICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2x0dlJhdGlvJykudGV4dENvbnRlbnQgPSAKICAgICAgICAgICAgICAgICAgICBkYXRhLmVxdWl0eS5sdHZSYXRpbyA/IGRhdGEuZXF1aXR5Lmx0dlJhdGlvICsgJyUnIDogJy0tJzsKICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0gZGF0YS5lcXVpdHkuaXNVbmRlcndhdGVyID8gJ1VOREVSV0FURVInIDogCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmVxdWl0eS5oYXNFcXVpdHkgPyAnUE9TSVRJVkUgRVFVSVRZJyA6ICdVTktOT1dOJzsKICAgICAgICAgICAgICAgIGNvbnN0IHN0YXR1c0NsYXNzID0gZGF0YS5lcXVpdHkuaXNVbmRlcndhdGVyID8gJ2RhbmdlcicgOiAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuZXF1aXR5Lmhhc0VxdWl0eSA/ICdzdWNjZXNzJyA6ICcnOwogICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2VxdWl0eVN0YXR1cycpLmlubmVySFRNTCA9IAogICAgICAgICAgICAgICAgICAgIGA8c3BhbiBjbGFzcz0iJHtzdGF0dXNDbGFzc30iPiR7c3RhdHVzfTwvc3Bhbj5gOwogICAgICAgICAgICB9CgogICAgICAgICAgICAvLyBPd25lciBJbnRlbGxpZ2VuY2UKICAgICAgICAgICAgaWYgKGRhdGEub3duZXIpIHsKICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdvd25lck5hbWUnKS50ZXh0Q29udGVudCA9IGRhdGEub3duZXIubmFtZSB8fCAnLS0nOwogICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ293bmVyVHlwZScpLnRleHRDb250ZW50ID0gZGF0YS5vd25lci5vd25lcnNoaXBUeXBlIHx8ICctLSc7CiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnb3duZXJzaGlwTGVuZ3RoJykudGV4dENvbnRlbnQgPSAKICAgICAgICAgICAgICAgICAgICBkYXRhLm93bmVyLm93bmVyc2hpcExlbmd0aCA/IGRhdGEub3duZXIub3duZXJzaGlwTGVuZ3RoICsgJyB5ZWFycycgOiAnLS0nOwogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICBjb25zdCBvd25lckZsYWdzRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnb3duZXJGbGFncycpOwogICAgICAgICAgICAgICAgb3duZXJGbGFnc0VsLmlubmVySFRNTCA9ICcnOwogICAgICAgICAgICAgICAgaWYgKGRhdGEub3duZXIuaXNBYnNlbnRlZSkgewogICAgICAgICAgICAgICAgICAgIG93bmVyRmxhZ3NFbC5pbm5lckhUTUwgKz0gJzxzcGFuIGNsYXNzPSJyaXNrLWZsYWcgZmxhZy13YXJuaW5nIj5BQlNFTlRFRTwvc3Bhbj4nOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKGRhdGEub3duZXIuaXNDb3Jwb3JhdGVPd25lZCkgewogICAgICAgICAgICAgICAgICAgIG93bmVyRmxhZ3NFbC5pbm5lckhUTUwgKz0gJzxzcGFuIGNsYXNzPSJyaXNrLWZsYWcgZmxhZy1pbmZvIj5DT1JQT1JBVEU8L3NwYW4+JzsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQoKICAgICAgICAgICAgLy8gRW52aXJvbm1lbnRhbAogICAgICAgICAgICBpZiAoZGF0YS5lbnZpcm9ubWVudGFsKSB7CiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZmxvb2Rab25lJykudGV4dENvbnRlbnQgPSBkYXRhLmVudmlyb25tZW50YWwuZmxvb2Rab25lIHx8ICctLSc7CiAgICAgICAgICAgICAgICBjb25zdCBmbG9vZFJpc2sgPSBkYXRhLmVudmlyb25tZW50YWwuZmxvb2RSaXNrIHx8ICdVTktOT1dOJzsKICAgICAgICAgICAgICAgIGNvbnN0IHJpc2tDbGFzcyA9IGZsb29kUmlzayA9PT0gJ0hJR0gnID8gJ2RhbmdlcicgOiBmbG9vZFJpc2sgPT09ICdNT0RFUkFURScgPyAnd2FybmluZycgOiAnc3VjY2Vzcyc7CiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZmxvb2RSaXNrJykuaW5uZXJIVE1MID0gCiAgICAgICAgICAgICAgICAgICAgYDxzcGFuIGNsYXNzPSIke3Jpc2tDbGFzc30iPiR7Zmxvb2RSaXNrfTwvc3Bhbj5gOwogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICBjb25zdCBlbnZGbGFnc0VsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Vudmlyb25tZW50YWxGbGFncycpOwogICAgICAgICAgICAgICAgZW52RmxhZ3NFbC5pbm5lckhUTUwgPSAnJzsKICAgICAgICAgICAgICAgIGlmIChmbG9vZFJpc2sgPT09ICdISUdIJykgewogICAgICAgICAgICAgICAgICAgIGVudkZsYWdzRWwuaW5uZXJIVE1MICs9ICc8c3BhbiBjbGFzcz0icmlzay1mbGFnIGZsYWctZGFuZ2VyIj5ISUdIIEZMT09EIFJJU0s8L3NwYW4+JzsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQoKICAgICAgICAgICAgLy8gU2Nob29scwogICAgICAgICAgICBpZiAoZGF0YS5zY2hvb2xzKSB7CiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2Nob29sRGlzdHJpY3QnKS50ZXh0Q29udGVudCA9IGRhdGEuc2Nob29scy5kaXN0cmljdCB8fCAnLS0nOwogICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NjaG9vbEVsZW1lbnRhcnknKS50ZXh0Q29udGVudCA9IGRhdGEuc2Nob29scy5lbGVtZW50YXJ5U2Nob29sIHx8ICctLSc7CiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2Nob29sSGlnaCcpLnRleHRDb250ZW50ID0gZGF0YS5zY2hvb2xzLmhpZ2hTY2hvb2wgfHwgJy0tJzsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgLy8gRGlzdHJlc3MgSW5kaWNhdG9ycwogICAgICAgICAgICBpZiAoZGF0YS5kaXN0cmVzcyAmJiAoZGF0YS5kaXN0cmVzcy5pc0luRm9yZWNsb3N1cmUgfHwgZGF0YS5kaXN0cmVzcy5pc1JFTykpIHsKICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkaXN0cmVzc1NlY3Rpb24nKS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJzsKICAgICAgICAgICAgICAgIGNvbnN0IGRpc3RyZXNzRmxhZ3NFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkaXN0cmVzc0ZsYWdzJyk7CiAgICAgICAgICAgICAgICBkaXN0cmVzc0ZsYWdzRWwuaW5uZXJIVE1MID0gJyc7CiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgIGlmIChkYXRhLmRpc3RyZXNzLmlzSW5Gb3JlY2xvc3VyZSkgewogICAgICAgICAgICAgICAgICAgIGRpc3RyZXNzRmxhZ3NFbC5pbm5lckhUTUwgKz0gJzxzcGFuIGNsYXNzPSJyaXNrLWZsYWcgZmxhZy1kYW5nZXIiPkZPUkVDTE9TVVJFPC9zcGFuPic7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoZGF0YS5kaXN0cmVzcy5pc1JFTykgewogICAgICAgICAgICAgICAgICAgIGRpc3RyZXNzRmxhZ3NFbC5pbm5lckhUTUwgKz0gJzxzcGFuIGNsYXNzPSJyaXNrLWZsYWcgZmxhZy1kYW5nZXIiPlJFTzwvc3Bhbj4nOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICBsZXQgZGV0YWlscyA9ICcnOwogICAgICAgICAgICAgICAgaWYgKGRhdGEuZGlzdHJlc3MuZm9yZWNsb3N1cmVEYXRlKSB7CiAgICAgICAgICAgICAgICAgICAgZGV0YWlscyArPSBgRm9yZWNsb3N1cmU6ICR7bmV3IERhdGUoZGF0YS5kaXN0cmVzcy5mb3JlY2xvc3VyZURhdGUpLnRvTG9jYWxlRGF0ZVN0cmluZygpfTxicj5gOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKGRhdGEuZGlzdHJlc3MuYXVjdGlvbkRhdGUpIHsKICAgICAgICAgICAgICAgICAgICBkZXRhaWxzICs9IGBBdWN0aW9uOiAke25ldyBEYXRlKGRhdGEuZGlzdHJlc3MuYXVjdGlvbkRhdGUpLnRvTG9jYWxlRGF0ZVN0cmluZygpfWA7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGlzdHJlc3NEZXRhaWxzJykuaW5uZXJIVE1MID0gZGV0YWlsczsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgLy8gQWRkaXRpb25hbCBEZXRhaWxzCiAgICAgICAgICAgIGlmIChkYXRhLmJ1aWxkaW5nKSB7CiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGV0YWlsU3RvcmllcycpLnRleHRDb250ZW50ID0gZGF0YS5idWlsZGluZy5zdG9yaWVzIHx8ICctLSc7CiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGV0YWlsUXVhbGl0eScpLnRleHRDb250ZW50ID0gZGF0YS5idWlsZGluZy5xdWFsaXR5IHx8ICctLSc7CiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGV0YWlsUG9vbCcpLnRleHRDb250ZW50ID0gZGF0YS5idWlsZGluZy5wb29sID8gJ1llcycgOiAnTm8nOwogICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RldGFpbEZpcmVwbGFjZScpLnRleHRDb250ZW50ID0gZGF0YS5idWlsZGluZy5maXJlcGxhY2UgPyAnWWVzJyA6ICdObyc7CiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGV0YWlsSGVhdGluZycpLnRleHRDb250ZW50ID0gZGF0YS5idWlsZGluZy5oZWF0aW5nIHx8ICctLSc7CiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGV0YWlsQ29vbGluZycpLnRleHRDb250ZW50ID0gZGF0YS5idWlsZGluZy5jb29saW5nIHx8ICctLSc7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgCiAgICAgICAgICAgIGlmIChkYXRhLmFzc2Vzc21lbnQpIHsKICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkZXRhaWxUYXhBbW91bnQnKS50ZXh0Q29udGVudCA9IGZvcm1hdEN1cnJlbmN5KGRhdGEuYXNzZXNzbWVudC50YXhBbW91bnQpOwogICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RldGFpbFRheFBlclNxZnQnKS50ZXh0Q29udGVudCA9IAogICAgICAgICAgICAgICAgICAgIGRhdGEuYXNzZXNzbWVudC50YXhQZXJTcWZ0ID8gJyQnICsgZGF0YS5hc3Nlc3NtZW50LnRheFBlclNxZnQgOiAnLS0nOwogICAgICAgICAgICB9CiAgICAgICAgICAgIAogICAgICAgICAgICBpZiAoZGF0YS5tZXRhZGF0YSkgewogICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RldGFpbEF0dG9tSWQnKS50ZXh0Q29udGVudCA9IGRhdGEubWV0YWRhdGEuYXR0b21JZCB8fCAnLS0nOwogICAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICAvLyBGb3JtYXQgY3VycmVuY3kKICAgICAgICBmdW5jdGlvbiBmb3JtYXRDdXJyZW5jeSh2YWx1ZSkgewogICAgICAgICAgICBpZiAoIXZhbHVlICYmIHZhbHVlICE9PSAwKSByZXR1cm4gJy0tJzsKICAgICAgICAgICAgcmV0dXJuICckJyArIE1hdGgucm91bmQodmFsdWUpLnRvTG9jYWxlU3RyaW5nKCk7CiAgICAgICAgfQoKICAgICAgICAvLyBVcGRhdGUgY2VudGVyIHZhbHVlIHdoZW4gdXNlciBlZGl0cwogICAgICAgIGZ1bmN0aW9uIHVwZGF0ZUNlbnRlclZhbHVlKCkgewogICAgICAgICAgICBjb25zdCBpbnB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjZW50ZXJWYWx1ZScpOwogICAgICAgICAgICBpbnB1dC5jbGFzc0xpc3QuYWRkKCd1c2VyLW92ZXJyaWRlJyk7CiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdDZW50ZXIgdmFsdWUgdXBkYXRlZDonLCBpbnB1dC52YWx1ZSk7CiAgICAgICAgfQoKICAgICAgICAvLyBUb2dnbGUgY29sbGFwc2libGUgc2VjdGlvbnMKICAgICAgICBmdW5jdGlvbiB0b2dnbGVDb2xsYXBzaWJsZShpZCkgewogICAgICAgICAgICBjb25zdCBjb250ZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpOwogICAgICAgICAgICBjb25zdCB0cmlnZ2VyID0gY29udGVudC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nOwogICAgICAgICAgICAKICAgICAgICAgICAgY29udGVudC5jbGFzc0xpc3QudG9nZ2xlKCdoaWRkZW4nKTsKICAgICAgICAgICAgdHJpZ2dlci5jbGFzc0xpc3QudG9nZ2xlKCdjb2xsYXBzZWQnKTsKICAgICAgICB9CgogICAgICAgIC8vIEdlbmVyYXRlIENNQSAocGxhY2Vob2xkZXIpCiAgICAgICAgZnVuY3Rpb24gZ2VuZXJhdGVDTUEoKSB7CiAgICAgICAgICAgIGlmICghY3VycmVudFByb3BlcnR5RGF0YSkgewogICAgICAgICAgICAgICAgYWxlcnQoJ1BsZWFzZSBsb2FkIHByb3BlcnR5IGRhdGEgZmlyc3QnKTsKICAgICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgfQogICAgICAgICAgICAKICAgICAgICAgICAgY29uc3QgY2VudGVyVmFsdWUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2VudGVyVmFsdWUnKS52YWx1ZTsKICAgICAgICAgICAgY29uc3QgcmFkaXVzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NtYVJhZGl1cycpLnZhbHVlOwogICAgICAgICAgICBjb25zdCBkYXlzQmFjayA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjbWFEYXlzQmFjaycpLnZhbHVlOwogICAgICAgICAgICAKICAgICAgICAgICAgYWxlcnQoYENNQSBHZW5lcmF0aW9uXG5cbkNlbnRlciBWYWx1ZTogJHtjZW50ZXJWYWx1ZX1cblJhZGl1czogJHtyYWRpdXN9IG1pbGVzXG5EYXlzIEJhY2s6ICR7ZGF5c0JhY2t9XG5cbkludGVncmF0aW5nIHdpdGggQ2xvdWRDTUEuLi5gKTsKICAgICAgICB9CgogICAgICAgIC8vIEV4cG9ydCB0byBGVUIgKHBsYWNlaG9sZGVyKQogICAgICAgIGZ1bmN0aW9uIGV4cG9ydERhdGEoKSB7CiAgICAgICAgICAgIGlmICghY3VycmVudFByb3BlcnR5RGF0YSkgewogICAgICAgICAgICAgICAgYWxlcnQoJ1BsZWFzZSBsb2FkIHByb3BlcnR5IGRhdGEgZmlyc3QnKTsKICAgICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgfQogICAgICAgICAgICAKICAgICAgICAgICAgYWxlcnQoJ0V4cG9ydGluZyBwcm9wZXJ0eSBpbnRlbGxpZ2VuY2UgdG8gRlVCIGN1c3RvbSBmaWVsZHMuLi4nKTsKICAgICAgICB9CiAgICA8L3NjcmlwdD4KPC9ib2R5Pgo8L2h0bWw+Cg==';
            const html = Buffer.from(htmlBase64, 'base64').toString('utf8');
            
            return {
                statusCode: 200,
                headers: {
                    'Content-Type': 'text/html',
                    'Access-Control-Allow-Origin': '*'
                },
                body: html
            };
        }

        // Route to appropriate API handler
        switch (action) {
            case 'getPersonData':
                return await getPersonData(params.personId, headers);
            
            case 'generateCMA':
                return await generateCMA(params, headers);
            
            case 'getHomebeatData':
                return await getHomebeatData(params.personId, headers);
            
            case 'resendHomebeat':
                return await resendHomebeat(params, headers);
            
            case 'createTask':
                return await createTask(params, headers);
            
            case 'createManualAction':
                return await createManualAction(params, headers);
            
            default:
                return {
                    statusCode: 400,
                    headers,
                    body: JSON.stringify({ error: 'Invalid action' })
                };
        }

    } catch (error) {
        console.error('Function error:', error);
        return {
            statusCode: 500,
            headers,
            body: JSON.stringify({ error: error.message })
        };
    }
};

// Get person data from FUB
async function getPersonData(personId, headers) {
    try {
        const personData = await fubAPIRequest('GET', `/v1/people/${personId}`);
        
        return {
            statusCode: 200,
            headers,
            body: JSON.stringify(personData)
        };
    } catch (error) {
        return {
            statusCode: 500,
            headers,
            body: JSON.stringify({ error: 'Failed to fetch person data: ' + error.message })
        };
    }
}

// Generate CMA with CloudCMA API
async function generateCMA(params, headers) {
    try {
        const {
            personId,
            address,
            beds,
            baths,
            sqft,
            radius,
            monthsBack,
            minListings,
            propType,
            title,
            createHomebeat,
            homebeatFrequency
        } = params;

        // Get person data for lead info
        const personData = await fubAPIRequest('GET', `/v1/people/${personId}`);

        // Build CMA URL
        const cmaParams = new URLSearchParams({
            api_key: CLOUDCMA_API_KEY,
            address: address,
            beds: beds || '',
            baths: baths || '',
            sqft: sqft || '',
            radius: radius || '0.75',
            months_back: monthsBack || '9',
            min_listings: minListings || '10',
            prop_type: propType || '',
            title: title || `${personData.name || 'Client'} - ${address}`,
            callback_url: WEBHOOK_URL
        });

        const cmaUrl = `https://cloudcma.com/cmas/new?${cmaParams.toString()}`;

        // Update FUB custom fields
        const updatePayload = {
            customWILLOWCMADate: new Date().toISOString(),
            customWILLOWCMAAddress: address,
            customWILLOWCMALink: cmaUrl
        };

        await fubAPIRequest('PUT', `/v1/people/${personId}`, updatePayload);

        // Create FUB activity
        await fubAPIRequest('POST', '/v1/events', {
            person_id: parseInt(personId),
            type: 'Note',
            body: `CMA generated for ${address}. Parameters: ${beds}bd/${baths}ba, ${sqft}sqft, ${radius}mi radius, ${monthsBack}mo back.`
        });

        let homebeatUrl = null;
        let homebeatCreated = false;

        // Create Homebeat if requested
        if (createHomebeat === true || createHomebeat === 'true') {
            try {
                const homebeatPayload = {
                    automation: {
                        api_key: CLOUDCMA_API_KEY,
                        frequency: homebeatFrequency || 'quarterly',
                        welcome_email: 'true',
                        report: {
                            prop_type: propType || null,
                            callback_url: null
                        },
                        subject_property: {
                            address: address,
                            sqft: sqft || null,
                            beds: beds || null,
                            baths: baths || null
                        },
                        lead: {
                            name: personData.name || '',
                            email_address: personData.emails?.[0]?.value || '',
                            phone: personData.phones?.[0]?.value || ''
                        }
                    }
                };

                const homebeatResponse = await cloudCMAAPIRequest('POST', '/homebeats/widget', homebeatPayload);
                homebeatCreated = true;
                homebeatUrl = homebeatResponse.homebeat_url || null;

                // Update FUB with Homebeat info
                await fubAPIRequest('PUT', `/v1/people/${personId}`, {
                    customWILLOWCloudCMAHomeBeatURL: homebeatUrl,
                    customWILLOWHomebeatFirstSendDate: new Date().toISOString()
                });

                // Create FUB activity for Homebeat
                await fubAPIRequest('POST', '/v1/events', {
                    person_id: parseInt(personId),
                    type: 'Note',
                    body: `Homebeat subscription created for ${address}. Frequency: ${homebeatFrequency}. Lead will receive automated market updates.`
                });

            } catch (homebeatError) {
                console.error('Homebeat creation failed:', homebeatError);
            }
        }

        return {
            statusCode: 200,
            headers,
            body: JSON.stringify({
                success: true,
                cmaUrl: cmaUrl,
                homebeatCreated: homebeatCreated,
                homebeatUrl: homebeatUrl
            })
        };

    } catch (error) {
        return {
            statusCode: 500,
            headers,
            body: JSON.stringify({ error: 'Failed to generate CMA: ' + error.message })
        };
    }
}

// Get Homebeat data from CloudCMA
async function getHomebeatData(personId, headers) {
    try {
        // Try to fetch homebeat data, but gracefully handle CloudCMA auth failures
        let homebeatReport = [];
        try {
            homebeatReport = await cloudCMAAPIRequest('GET', `/homebeats/report?api_key=${CLOUDCMA_API_KEY}&format=json`);
        } catch (cloudCMAError) {
            console.warn('CloudCMA API unavailable:', cloudCMAError.message);
            // Return empty homebeats array instead of failing
            return {
                statusCode: 200,
                headers,
                body: JSON.stringify({ 
                    homebeats: [],
                    warning: 'CloudCMA API unavailable. Check API key configuration.'
                })
            };
        }

        const personData = await fubAPIRequest('GET', `/v1/people/${personId}`);
        const personEmail = personData.emails?.[0]?.value?.toLowerCase();

        if (!personEmail) {
            return {
                statusCode: 200,
                headers,
                body: JSON.stringify({ homebeats: [] })
            };
        }

        const leadHomebeats = (homebeatReport || []).filter(hb => 
            hb.lead_email?.toLowerCase() === personEmail
        );

        const enrichedHomebeats = leadHomebeats.map(hb => ({
            ...hb,
            first_send_date: personData.customWILLOWHomebeatFirstSendDate || hb.created_at,
            status: (hb.total_views || 0) === 0 ? 'pending' : 'active'
        }));

        if (enrichedHomebeats.length > 0) {
            const totalViews = enrichedHomebeats.reduce((sum, hb) => sum + (hb.total_views || 0), 0);
            const latestView = enrichedHomebeats
                .map(hb => hb.last_view)
                .filter(v => v)
                .sort()
                .reverse()[0];

            await fubAPIRequest('PUT', `/v1/people/${personId}`, {
                customWILLOWHomebeatViews: totalViews,
                customWILLOWHomebeatLastView: latestView || null
            });
        }

        return {
            statusCode: 200,
            headers,
            body: JSON.stringify({ homebeats: enrichedHomebeats })
        };

    } catch (error) {
        return {
            statusCode: 500,
            headers,
            body: JSON.stringify({ error: 'Failed to fetch Homebeat data: ' + error.message })
        };
    }
}

// Resend Homebeat
async function resendHomebeat(params, headers) {
    try {
        const { homebeatId, personId } = params;

        const personData = await fubAPIRequest('GET', `/v1/people/${personId}`);
        
        const homebeatReport = await cloudCMAAPIRequest('GET', `/homebeats/report?api_key=${CLOUDCMA_API_KEY}&format=json`);
        const homebeat = (homebeatReport || []).find(hb => hb.id === homebeatId);

        if (!homebeat) {
            throw new Error('Homebeat not found');
        }

        const homebeatPayload = {
            automation: {
                api_key: CLOUDCMA_API_KEY,
                frequency: homebeat.frequency || 'quarterly',
                welcome_email: 'true',
                subject_property: {
                    address: homebeat.property_address,
                    sqft: homebeat.sqft || null,
                    beds: homebeat.beds || null,
                    baths: homebeat.baths || null
                },
                lead: {
                    name: personData.name || '',
                    email_address: personData.emails?.[0]?.value || '',
                    phone: personData.phones?.[0]?.value || ''
                }
            }
        };

        await cloudCMAAPIRequest('POST', '/homebeats/widget', homebeatPayload);

        await fubAPIRequest('PUT', `/v1/people/${personId}`, {
            customWILLOWHomebeatLastResend: new Date().toISOString()
        });

        await fubAPIRequest('POST', '/v1/events', {
            person_id: parseInt(personId),
            type: 'Note',
            body: `Homebeat resent for ${homebeat.property_address}. Status was pending (0 views). Manual resend triggered.`
        });

        return {
            statusCode: 200,
            headers,
            body: JSON.stringify({ success: true })
        };

    } catch (error) {
        return {
            statusCode: 500,
            headers,
            body: JSON.stringify({ error: 'Failed to resend Homebeat: ' + error.message })
        };
    }
}

// Create task in FUB
async function createTask(params, headers) {
    try {
        const { personId, taskDescription, urgency, assignedTo } = params;

        const now = new Date();
        let dueDate = new Date(now);
        
        switch (urgency) {
            case 'IMMEDIATE':
                dueDate.setHours(now.getHours() + 24);
                break;
            case 'SAME_DAY':
                dueDate.setHours(23, 59, 59);
                break;
            case 'NEXT_DAY':
                dueDate.setDate(now.getDate() + 1);
                break;
            case 'WEEKLY':
                dueDate.setDate(now.getDate() + 7);
                break;
            default:
                dueDate.setDate(now.getDate() + 1);
        }

        // FUB tasks API doesn't accept description/body field
        // Task details should be added as a note after task creation
        const taskPayload = {
            personId: parseInt(personId),
            type: 'Follow Up',
            dueDate: dueDate.toISOString()
        };

        const taskResult = await fubAPIRequest('POST', '/v1/tasks', taskPayload);
        
        // Add task details as a note
        const notePayload = {
            personId: parseInt(personId),
            subject: `Task: ${taskDescription}`,
            body: `${taskDescription}\n\nAssigned to: ${assignedTo}\nUrgency: ${urgency}\nDue: ${dueDate.toLocaleDateString()}`,
            isHtml: false
        };
        await fubAPIRequest('POST', '/v1/notes', notePayload);

        return {
            statusCode: 200,
            headers,
            body: JSON.stringify({ success: true })
        };

    } catch (error) {
        return {
            statusCode: 500,
            headers,
            body: JSON.stringify({ error: 'Failed to create task: ' + error.message })
        };
    }
}

// Create manual action in FUB
async function createManualAction(params, headers) {
    try {
        const { personId, actionType, assignedTo, urgency, notes } = params;

        const now = new Date();
        let dueDate = new Date(now);
        
        switch (urgency) {
            case 'IMMEDIATE':
                dueDate.setHours(now.getHours() + 24);
                break;
            case 'SAME_DAY':
                dueDate.setHours(23, 59, 59);
                break;
            case 'NEXT_DAY':
                dueDate.setDate(now.getDate() + 1);
                break;
            case 'WEEKLY':
                dueDate.setDate(now.getDate() + 7);
                break;
            default:
                dueDate.setDate(now.getDate() + 1);
        }

        // Map action types to FUB task types
        const taskTypeMap = {
            'Task': 'Follow Up',
            'Call': 'Call',
            'Email': 'Email',
            'Text': 'Text',
            'Note': 'Note'
        };
        
        const fubType = taskTypeMap[actionType] || 'Follow Up';
        
        // If it's a Note, use /v1/notes endpoint, otherwise use /v1/tasks
        if (actionType === 'Note') {
            const notePayload = {
                personId: parseInt(personId),
                subject: `${urgency} Action`,
                body: `${notes}\n\nAssigned to: ${assignedTo}`,
                isHtml: false
            };
            await fubAPIRequest('POST', '/v1/notes', notePayload);
        } else {
            // FUB tasks API doesn't accept description field
            const taskPayload = {
                personId: parseInt(personId),
                type: fubType,
                dueDate: dueDate.toISOString()
            };
            await fubAPIRequest('POST', '/v1/tasks', taskPayload);
            
            // Add action details as a note
            const notePayload = {
                personId: parseInt(personId),
                subject: `${fubType} Action`,
                body: `${notes}\n\nAssigned to: ${assignedTo}\nUrgency: ${urgency}`,
                isHtml: false
            };
            await fubAPIRequest('POST', '/v1/notes', notePayload);
        }

        return {
            statusCode: 200,
            headers,
            body: JSON.stringify({ success: true })
        };

    } catch (error) {
        return {
            statusCode: 500,
            headers,
            body: JSON.stringify({ error: 'Failed to create action: ' + error.message })
        };
    }
}

// FUB API Request Helper
function fubAPIRequest(method, path, data = null) {
    return new Promise((resolve, reject) => {
        const options = {
            hostname: 'api.followupboss.com',
            port: 443,
            path: path,
            method: method,
            headers: {
                'Authorization': `Basic ${Buffer.from(FUB_API_KEY + ':').toString('base64')}`,
                'Content-Type': 'application/json'
            }
        };

        const req = https.request(options, (res) => {
            let body = '';
            res.on('data', (chunk) => body += chunk);
            res.on('end', () => {
                try {
                    const parsed = JSON.parse(body);
                    if (res.statusCode >= 200 && res.statusCode < 300) {
                        resolve(parsed);
                    } else {
                        reject(new Error(`FUB API error: ${res.statusCode} - ${body}`));
                    }
                } catch (e) {
                    reject(new Error(`Failed to parse FUB response: ${body}`));
                }
            });
        });

        req.on('error', reject);
        
        if (data) {
            req.write(JSON.stringify(data));
        }
        
        req.end();
    });
}

// CloudCMA API Request Helper
function cloudCMAAPIRequest(method, path, data = null) {
    return new Promise((resolve, reject) => {
        const options = {
            hostname: 'cloudcma.com',
            port: 443,
            path: path,
            method: method,
            headers: {
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            }
        };

        const req = https.request(options, (res) => {
            let body = '';
            res.on('data', (chunk) => body += chunk);
            res.on('end', () => {
                try {
                    const parsed = body ? JSON.parse(body) : {};
                    if (res.statusCode >= 200 && res.statusCode < 300) {
                        resolve(parsed);
                    } else {
                        reject(new Error(`CloudCMA API error: ${res.statusCode} - ${body}`));
                    }
                } catch (e) {
                    if (res.statusCode >= 200 && res.statusCode < 300) {
                        resolve({});
                    } else {
                        reject(new Error(`Failed to parse CloudCMA response: ${body}`));
                    }
                }
            });
        });

        req.on('error', reject);
        
        if (data) {
            req.write(JSON.stringify(data));
        }
        
        req.end();
    });
}
