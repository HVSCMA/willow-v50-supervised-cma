// WILLOW V50 CMA Workbench - Complete Netlify Function
// Purpose: Server-side FUB/CloudCMA API integration with HTML serving

const https = require('https');

// API Credentials
const FUB_API_KEY = process.env.FUB_API_KEY || 'fka_0oHt62NxmsExO6x69p08ix82zx8ii1hzrj';
const CLOUDCMA_API_KEY = process.env.CLOUDCMA_API_KEY || '742f4a46e1780904da090d721a9bae7b';
const WEBHOOK_URL = 'https://willow-v50-supervised-cma.netlify.app/.netlify/functions/cloudcma-webhook';

exports.handler = async (event, context) => {
    // CORS headers
    const headers = {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': 'Content-Type',
        'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
        'Content-Type': 'application/json'
    };

    if (event.httpMethod === 'OPTIONS') {
        return { statusCode: 200, headers, body: '' };
    }

    try {
        // Parse request
        const params = event.httpMethod === 'GET' 
            ? event.queryStringParameters || {}
            : JSON.parse(event.body || '{}');

        const action = params.action;

        // If no action parameter, serve HTML interface (Base64 decoded)
        if (!action) {
            const htmlBase64 = 'PCFET0NUWVBFIGh0bWw+CjxodG1sIGxhbmc9ImVuIj4KPGhlYWQ+CiAgICA8bWV0YSBjaGFyc2V0PSJVVEYtOCI+CiAgICA8bWV0YSBuYW1lPSJ2aWV3cG9ydCIgY29udGVudD0id2lkdGg9ZGV2aWNlLXdpZHRoLCBpbml0aWFsLXNjYWxlPTEuMCI+CiAgICA8dGl0bGU+V0lMTE9XIFY1MCAtIENNQSBXb3JrYmVuY2g8L3RpdGxlPgogICAgPCEtLSBGVUIgRW1iZWRkZWQgQXBwcyBTREsgLS0+CiAgICA8c2NyaXB0IHR5cGU9InRleHQvamF2YXNjcmlwdCIgc3JjPSJodHRwczovL2VpYS5mb2xsb3d1cGJvc3MuY29tL2VtYmVkZGVkQXBwcy12MS4wLjEuanMiPjwvc2NyaXB0PgogICAgPHN0eWxlPgogICAgICAgICogewogICAgICAgICAgICBtYXJnaW46IDA7CiAgICAgICAgICAgIHBhZGRpbmc6IDA7CiAgICAgICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7CiAgICAgICAgfQoKICAgICAgICBib2R5IHsKICAgICAgICAgICAgZm9udC1mYW1pbHk6IC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgJ1NlZ29lIFVJJywgUm9ib3RvLCBPeHlnZW4sIFVidW50dSwgQ2FudGFyZWxsLCBzYW5zLXNlcmlmOwogICAgICAgICAgICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoMTM1ZGVnLCAjNjY3ZWVhIDAlLCAjNzY0YmEyIDEwMCUpOwogICAgICAgICAgICBjb2xvcjogIzJkMzc0ODsKICAgICAgICAgICAgbGluZS1oZWlnaHQ6IDEuNjsKICAgICAgICB9CgogICAgICAgIC5jb250YWluZXIgewogICAgICAgICAgICBtYXgtd2lkdGg6IDE0MDBweDsKICAgICAgICAgICAgbWFyZ2luOiAwIGF1dG87CiAgICAgICAgICAgIHBhZGRpbmc6IDIwcHg7CiAgICAgICAgfQoKICAgICAgICAuaGVhZGVyIHsKICAgICAgICAgICAgYmFja2dyb3VuZDogd2hpdGU7CiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDEycHg7CiAgICAgICAgICAgIHBhZGRpbmc6IDIwcHggMzBweDsKICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMjBweDsKICAgICAgICAgICAgYm94LXNoYWRvdzogMCA0cHggNnB4IHJnYmEoMCwwLDAsMC4xKTsKICAgICAgICB9CgogICAgICAgIC5oZWFkZXIgaDEgewogICAgICAgICAgICBmb250LXNpemU6IDI0cHg7CiAgICAgICAgICAgIGNvbG9yOiAjNjY3ZWVhOwogICAgICAgICAgICBtYXJnaW4tYm90dG9tOiA1cHg7CiAgICAgICAgfQoKICAgICAgICAuaGVhZGVyIC5zdWJ0aXRsZSB7CiAgICAgICAgICAgIGZvbnQtc2l6ZTogMTRweDsKICAgICAgICAgICAgY29sb3I6ICM3MTgwOTY7CiAgICAgICAgfQoKICAgICAgICAudGFicyB7CiAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7CiAgICAgICAgICAgIGdhcDogMTBweDsKICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMjBweDsKICAgICAgICB9CgogICAgICAgIC50YWItYnV0dG9uIHsKICAgICAgICAgICAgZmxleDogMTsKICAgICAgICAgICAgYmFja2dyb3VuZDogd2hpdGU7CiAgICAgICAgICAgIGJvcmRlcjogbm9uZTsKICAgICAgICAgICAgcGFkZGluZzogMTVweCAyMHB4OwogICAgICAgICAgICBib3JkZXItcmFkaXVzOiAxMnB4OwogICAgICAgICAgICBmb250LXNpemU6IDE2cHg7CiAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiA2MDA7CiAgICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjsKICAgICAgICAgICAgdHJhbnNpdGlvbjogYWxsIDAuM3MgZWFzZTsKICAgICAgICAgICAgYm94LXNoYWRvdzogMCAycHggNHB4IHJnYmEoMCwwLDAsMC4xKTsKICAgICAgICB9CgogICAgICAgIC50YWItYnV0dG9uOmhvdmVyIHsKICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC0ycHgpOwogICAgICAgICAgICBib3gtc2hhZG93OiAwIDRweCA4cHggcmdiYSgwLDAsMCwwLjE1KTsKICAgICAgICB9CgogICAgICAgIC50YWItYnV0dG9uLmFjdGl2ZSB7CiAgICAgICAgICAgIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCgxMzVkZWcsICM2NjdlZWEgMCUsICM3NjRiYTIgMTAwJSk7CiAgICAgICAgICAgIGNvbG9yOiB3aGl0ZTsKICAgICAgICB9CgogICAgICAgIC50YWItY29udGVudCB7CiAgICAgICAgICAgIGRpc3BsYXk6IG5vbmU7CiAgICAgICAgICAgIGJhY2tncm91bmQ6IHdoaXRlOwogICAgICAgICAgICBib3JkZXItcmFkaXVzOiAxMnB4OwogICAgICAgICAgICBwYWRkaW5nOiAzMHB4OwogICAgICAgICAgICBib3gtc2hhZG93OiAwIDRweCA2cHggcmdiYSgwLDAsMCwwLjEpOwogICAgICAgICAgICBtaW4taGVpZ2h0OiA2MDBweDsKICAgICAgICB9CgogICAgICAgIC50YWItY29udGVudC5hY3RpdmUgewogICAgICAgICAgICBkaXNwbGF5OiBibG9jazsKICAgICAgICB9CgogICAgICAgIC5zZWN0aW9uIHsKICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMzBweDsKICAgICAgICAgICAgcGFkZGluZy1ib3R0b206IDMwcHg7CiAgICAgICAgICAgIGJvcmRlci1ib3R0b206IDJweCBzb2xpZCAjZTJlOGYwOwogICAgICAgIH0KCiAgICAgICAgLnNlY3Rpb246bGFzdC1jaGlsZCB7CiAgICAgICAgICAgIGJvcmRlci1ib3R0b206IG5vbmU7CiAgICAgICAgfQoKICAgICAgICAuc2VjdGlvbi10aXRsZSB7CiAgICAgICAgICAgIGZvbnQtc2l6ZTogMThweDsKICAgICAgICAgICAgZm9udC13ZWlnaHQ6IDcwMDsKICAgICAgICAgICAgY29sb3I6ICMyZDM3NDg7CiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDE1cHg7CiAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7CiAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7CiAgICAgICAgICAgIGdhcDogMTBweDsKICAgICAgICB9CgogICAgICAgIC5mb3JtLWdyb3VwIHsKICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMjBweDsKICAgICAgICB9CgogICAgICAgIC5mb3JtLWxhYmVsIHsKICAgICAgICAgICAgZGlzcGxheTogYmxvY2s7CiAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiA2MDA7CiAgICAgICAgICAgIGNvbG9yOiAjNGE1NTY4OwogICAgICAgICAgICBtYXJnaW4tYm90dG9tOiA4cHg7CiAgICAgICAgICAgIGZvbnQtc2l6ZTogMTRweDsKICAgICAgICB9CgogICAgICAgIC5mb3JtLWlucHV0IHsKICAgICAgICAgICAgd2lkdGg6IDEwMCU7CiAgICAgICAgICAgIHBhZGRpbmc6IDEycHggMTVweDsKICAgICAgICAgICAgYm9yZGVyOiAycHggc29saWQgI2UyZThmMDsKICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogOHB4OwogICAgICAgICAgICBmb250LXNpemU6IDE0cHg7CiAgICAgICAgICAgIHRyYW5zaXRpb246IGJvcmRlci1jb2xvciAwLjNzIGVhc2U7CiAgICAgICAgfQoKICAgICAgICAuZm9ybS1pbnB1dDpmb2N1cyB7CiAgICAgICAgICAgIG91dGxpbmU6IG5vbmU7CiAgICAgICAgICAgIGJvcmRlci1jb2xvcjogIzY2N2VlYTsKICAgICAgICB9CgogICAgICAgIC5mb3JtLXJvdyB7CiAgICAgICAgICAgIGRpc3BsYXk6IGdyaWQ7CiAgICAgICAgICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogcmVwZWF0KGF1dG8tZml0LCBtaW5tYXgoMjAwcHgsIDFmcikpOwogICAgICAgICAgICBnYXA6IDE1cHg7CiAgICAgICAgfQoKICAgICAgICAuZm9ybS1zZWxlY3QgewogICAgICAgICAgICB3aWR0aDogMTAwJTsKICAgICAgICAgICAgcGFkZGluZzogMTJweCAxNXB4OwogICAgICAgICAgICBib3JkZXI6IDJweCBzb2xpZCAjZTJlOGYwOwogICAgICAgICAgICBib3JkZXItcmFkaXVzOiA4cHg7CiAgICAgICAgICAgIGZvbnQtc2l6ZTogMTRweDsKICAgICAgICAgICAgYmFja2dyb3VuZDogd2hpdGU7CiAgICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjsKICAgICAgICB9CgogICAgICAgIC5jaGVja2JveC1ncm91cCB7CiAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7CiAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7CiAgICAgICAgICAgIGdhcDogMTBweDsKICAgICAgICAgICAgbWFyZ2luOiAxNXB4IDA7CiAgICAgICAgfQoKICAgICAgICAuY2hlY2tib3gtZ3JvdXAgaW5wdXRbdHlwZT0iY2hlY2tib3giXSB7CiAgICAgICAgICAgIHdpZHRoOiAyMHB4OwogICAgICAgICAgICBoZWlnaHQ6IDIwcHg7CiAgICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjsKICAgICAgICB9CgogICAgICAgIC5jaGVja2JveC1ncm91cCBsYWJlbCB7CiAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiA2MDA7CiAgICAgICAgICAgIGNvbG9yOiAjNGE1NTY4OwogICAgICAgICAgICBjdXJzb3I6IHBvaW50ZXI7CiAgICAgICAgfQoKICAgICAgICAuYnRuIHsKICAgICAgICAgICAgcGFkZGluZzogMTRweCAyOHB4OwogICAgICAgICAgICBib3JkZXI6IG5vbmU7CiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDhweDsKICAgICAgICAgICAgZm9udC1zaXplOiAxNnB4OwogICAgICAgICAgICBmb250LXdlaWdodDogNjAwOwogICAgICAgICAgICBjdXJzb3I6IHBvaW50ZXI7CiAgICAgICAgICAgIHRyYW5zaXRpb246IGFsbCAwLjNzIGVhc2U7CiAgICAgICAgfQoKICAgICAgICAuYnRuLXByaW1hcnkgewogICAgICAgICAgICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoMTM1ZGVnLCAjNjY3ZWVhIDAlLCAjNzY0YmEyIDEwMCUpOwogICAgICAgICAgICBjb2xvcjogd2hpdGU7CiAgICAgICAgfQoKICAgICAgICAuYnRuLXByaW1hcnk6aG92ZXIgewogICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTJweCk7CiAgICAgICAgICAgIGJveC1zaGFkb3c6IDAgNnB4IDEycHggcmdiYSgxMDIsIDEyNiwgMjM0LCAwLjMpOwogICAgICAgIH0KCiAgICAgICAgLmJ0bi1zZWNvbmRhcnkgewogICAgICAgICAgICBiYWNrZ3JvdW5kOiAjZTJlOGYwOwogICAgICAgICAgICBjb2xvcjogIzRhNTU2ODsKICAgICAgICB9CgogICAgICAgIC5idG4tc2Vjb25kYXJ5OmhvdmVyIHsKICAgICAgICAgICAgYmFja2dyb3VuZDogI2NiZDVlMDsKICAgICAgICB9CgogICAgICAgIC5idG4tZGFuZ2VyIHsKICAgICAgICAgICAgYmFja2dyb3VuZDogI2ZjODE4MTsKICAgICAgICAgICAgY29sb3I6IHdoaXRlOwogICAgICAgIH0KCiAgICAgICAgLmJ0bi1kYW5nZXI6aG92ZXIgewogICAgICAgICAgICBiYWNrZ3JvdW5kOiAjZjU2NTY1OwogICAgICAgIH0KCiAgICAgICAgLmJ0bi1ncm91cCB7CiAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7CiAgICAgICAgICAgIGdhcDogMTBweDsKICAgICAgICAgICAgbWFyZ2luLXRvcDogMjBweDsKICAgICAgICB9CgogICAgICAgIC5pbmZvLWNhcmQgewogICAgICAgICAgICBiYWNrZ3JvdW5kOiAjZjdmYWZjOwogICAgICAgICAgICBib3JkZXItbGVmdDogNHB4IHNvbGlkICM2NjdlZWE7CiAgICAgICAgICAgIHBhZGRpbmc6IDE1cHggMjBweDsKICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogOHB4OwogICAgICAgICAgICBtYXJnaW4tYm90dG9tOiAyMHB4OwogICAgICAgIH0KCiAgICAgICAgLmluZm8tY2FyZC10aXRsZSB7CiAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiA3MDA7CiAgICAgICAgICAgIGNvbG9yOiAjMmQzNzQ4OwogICAgICAgICAgICBtYXJnaW4tYm90dG9tOiA4cHg7CiAgICAgICAgfQoKICAgICAgICAuaW5mby1jYXJkLWNvbnRlbnQgewogICAgICAgICAgICBjb2xvcjogIzcxODA5NjsKICAgICAgICAgICAgZm9udC1zaXplOiAxNHB4OwogICAgICAgIH0KCiAgICAgICAgLmhvbWViZWF0LWl0ZW0gewogICAgICAgICAgICBiYWNrZ3JvdW5kOiAjZjdmYWZjOwogICAgICAgICAgICBib3JkZXItcmFkaXVzOiA4cHg7CiAgICAgICAgICAgIHBhZGRpbmc6IDIwcHg7CiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDE1cHg7CiAgICAgICAgICAgIGJvcmRlci1sZWZ0OiA0cHggc29saWQgI2UyZThmMDsKICAgICAgICB9CgogICAgICAgIC5ob21lYmVhdC1pdGVtLmhpZ2gtZW5nYWdlbWVudCB7CiAgICAgICAgICAgIGJvcmRlci1sZWZ0LWNvbG9yOiAjZjU2NTY1OwogICAgICAgICAgICBiYWNrZ3JvdW5kOiAjZmZmNWY1OwogICAgICAgIH0KCiAgICAgICAgLmhvbWViZWF0LWl0ZW0ubWVkaXVtLWVuZ2FnZW1lbnQgewogICAgICAgICAgICBib3JkZXItbGVmdC1jb2xvcjogI2VkODkzNjsKICAgICAgICAgICAgYmFja2dyb3VuZDogI2ZmZmFmMDsKICAgICAgICB9CgogICAgICAgIC5ob21lYmVhdC1pdGVtLmxvdy1lbmdhZ2VtZW50IHsKICAgICAgICAgICAgYm9yZGVyLWxlZnQtY29sb3I6ICM0Mjk5ZTE7CiAgICAgICAgICAgIGJhY2tncm91bmQ6ICNlYmY4ZmY7CiAgICAgICAgfQoKICAgICAgICAuaG9tZWJlYXQtaXRlbS5ub3QtYWNjZXB0ZWQgewogICAgICAgICAgICBib3JkZXItbGVmdC1jb2xvcjogI2EwYWVjMDsKICAgICAgICAgICAgYmFja2dyb3VuZDogI2VkZjJmNzsKICAgICAgICB9CgogICAgICAgIC5ob21lYmVhdC1oZWFkZXIgewogICAgICAgICAgICBkaXNwbGF5OiBmbGV4OwogICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47CiAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7CiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDE1cHg7CiAgICAgICAgfQoKICAgICAgICAuaG9tZWJlYXQtdGl0bGUgewogICAgICAgICAgICBmb250LXNpemU6IDE2cHg7CiAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiA3MDA7CiAgICAgICAgICAgIGNvbG9yOiAjMmQzNzQ4OwogICAgICAgIH0KCiAgICAgICAgLmVuZ2FnZW1lbnQtYmFkZ2UgewogICAgICAgICAgICBwYWRkaW5nOiA2cHggMTJweDsKICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogMjBweDsKICAgICAgICAgICAgZm9udC1zaXplOiAxMnB4OwogICAgICAgICAgICBmb250LXdlaWdodDogNzAwOwogICAgICAgICAgICB0ZXh0LXRyYW5zZm9ybTogdXBwZXJjYXNlOwogICAgICAgIH0KCiAgICAgICAgLmJhZGdlLWNyaXRpY2FsIHsKICAgICAgICAgICAgYmFja2dyb3VuZDogI2Y1NjU2NTsKICAgICAgICAgICAgY29sb3I6IHdoaXRlOwogICAgICAgIH0KCiAgICAgICAgLmJhZGdlLWhpZ2ggewogICAgICAgICAgICBiYWNrZ3JvdW5kOiAjZWQ4OTM2OwogICAgICAgICAgICBjb2xvcjogd2hpdGU7CiAgICAgICAgfQoKICAgICAgICAuYmFkZ2UtbWVkaXVtIHsKICAgICAgICAgICAgYmFja2dyb3VuZDogIzQyOTllMTsKICAgICAgICAgICAgY29sb3I6IHdoaXRlOwogICAgICAgIH0KCiAgICAgICAgLmJhZGdlLWxvdyB7CiAgICAgICAgICAgIGJhY2tncm91bmQ6ICNhMGFlYzA7CiAgICAgICAgICAgIGNvbG9yOiB3aGl0ZTsKICAgICAgICB9CgogICAgICAgIC5iYWRnZS1ub3QtYWNjZXB0ZWQgewogICAgICAgICAgICBiYWNrZ3JvdW5kOiAjNzE4MDk2OwogICAgICAgICAgICBjb2xvcjogd2hpdGU7CiAgICAgICAgfQoKICAgICAgICAuaG9tZWJlYXQtc3RhdHMgewogICAgICAgICAgICBkaXNwbGF5OiBncmlkOwogICAgICAgICAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IHJlcGVhdChhdXRvLWZpdCwgbWlubWF4KDE1MHB4LCAxZnIpKTsKICAgICAgICAgICAgZ2FwOiAxMHB4OwogICAgICAgICAgICBtYXJnaW4tYm90dG9tOiAxNXB4OwogICAgICAgIH0KCiAgICAgICAgLnN0YXQtaXRlbSB7CiAgICAgICAgICAgIGZvbnQtc2l6ZTogMTNweDsKICAgICAgICAgICAgY29sb3I6ICM0YTU1Njg7CiAgICAgICAgfQoKICAgICAgICAuc3RhdC1sYWJlbCB7CiAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiA2MDA7CiAgICAgICAgICAgIGNvbG9yOiAjNzE4MDk2OwogICAgICAgIH0KCiAgICAgICAgLmFjdGlvbi1jYXJkIHsKICAgICAgICAgICAgYmFja2dyb3VuZDogI2ZmZjVmNTsKICAgICAgICAgICAgYm9yZGVyLWxlZnQ6IDRweCBzb2xpZCAjZjU2NTY1OwogICAgICAgICAgICBib3JkZXItcmFkaXVzOiA4cHg7CiAgICAgICAgICAgIHBhZGRpbmc6IDIwcHg7CiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDIwcHg7CiAgICAgICAgfQoKICAgICAgICAuYWN0aW9uLWNhcmQuaG90IHsKICAgICAgICAgICAgYmFja2dyb3VuZDogI2ZmZmFmMDsKICAgICAgICAgICAgYm9yZGVyLWxlZnQtY29sb3I6ICNlZDg5MzY7CiAgICAgICAgfQoKICAgICAgICAuYWN0aW9uLWNhcmQud2FybSB7CiAgICAgICAgICAgIGJhY2tncm91bmQ6ICNlYmY4ZmY7CiAgICAgICAgICAgIGJvcmRlci1sZWZ0LWNvbG9yOiAjNDI5OWUxOwogICAgICAgIH0KCiAgICAgICAgLmFjdGlvbi1oZWFkZXIgewogICAgICAgICAgICBmb250LXNpemU6IDE2cHg7CiAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiA3MDA7CiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDEwcHg7CiAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7CiAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7CiAgICAgICAgICAgIGdhcDogMTBweDsKICAgICAgICB9CgogICAgICAgIC5hY3Rpb24tY29udGVudCB7CiAgICAgICAgICAgIG1hcmdpbjogMTVweCAwOwogICAgICAgICAgICBwYWRkaW5nOiAxNXB4OwogICAgICAgICAgICBiYWNrZ3JvdW5kOiB3aGl0ZTsKICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogOHB4OwogICAgICAgIH0KCiAgICAgICAgLnNjcmlwdC1ib3ggewogICAgICAgICAgICBiYWNrZ3JvdW5kOiAjZjdmYWZjOwogICAgICAgICAgICBib3JkZXI6IDFweCBzb2xpZCAjZTJlOGYwOwogICAgICAgICAgICBib3JkZXItcmFkaXVzOiA4cHg7CiAgICAgICAgICAgIHBhZGRpbmc6IDE1cHg7CiAgICAgICAgICAgIGZvbnQtc3R5bGU6IGl0YWxpYzsKICAgICAgICAgICAgY29sb3I6ICM0YTU1Njg7CiAgICAgICAgICAgIG1hcmdpbjogMTVweCAwOwogICAgICAgIH0KCiAgICAgICAgLmxvYWRpbmcgewogICAgICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7CiAgICAgICAgICAgIHBhZGRpbmc6IDQwcHg7CiAgICAgICAgICAgIGNvbG9yOiAjNzE4MDk2OwogICAgICAgIH0KCiAgICAgICAgLnNwaW5uZXIgewogICAgICAgICAgICBib3JkZXI6IDRweCBzb2xpZCAjZTJlOGYwOwogICAgICAgICAgICBib3JkZXItdG9wOiA0cHggc29saWQgIzY2N2VlYTsKICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogNTAlOwogICAgICAgICAgICB3aWR0aDogNDBweDsKICAgICAgICAgICAgaGVpZ2h0OiA0MHB4OwogICAgICAgICAgICBhbmltYXRpb246IHNwaW4gMXMgbGluZWFyIGluZmluaXRlOwogICAgICAgICAgICBtYXJnaW46IDAgYXV0byAyMHB4OwogICAgICAgIH0KCiAgICAgICAgQGtleWZyYW1lcyBzcGluIHsKICAgICAgICAgICAgMCUgeyB0cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTsgfQogICAgICAgICAgICAxMDAlIHsgdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTsgfQogICAgICAgIH0KCiAgICAgICAgLmVycm9yIHsKICAgICAgICAgICAgYmFja2dyb3VuZDogI2ZmZjVmNTsKICAgICAgICAgICAgYm9yZGVyOiAycHggc29saWQgI2ZjODE4MTsKICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogOHB4OwogICAgICAgICAgICBwYWRkaW5nOiAxNXB4OwogICAgICAgICAgICBjb2xvcjogI2M1MzAzMDsKICAgICAgICAgICAgbWFyZ2luOiAyMHB4IDA7CiAgICAgICAgfQoKICAgICAgICAuc3VjY2VzcyB7CiAgICAgICAgICAgIGJhY2tncm91bmQ6ICNmMGZmZjQ7CiAgICAgICAgICAgIGJvcmRlcjogMnB4IHNvbGlkICM2OGQzOTE7CiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDhweDsKICAgICAgICAgICAgcGFkZGluZzogMTVweDsKICAgICAgICAgICAgY29sb3I6ICMyMjU0M2Q7CiAgICAgICAgICAgIG1hcmdpbjogMjBweCAwOwogICAgICAgIH0KCiAgICAgICAgLmNvbGxhcHNpYmxlIHsKICAgICAgICAgICAgY3Vyc29yOiBwb2ludGVyOwogICAgICAgICAgICB1c2VyLXNlbGVjdDogbm9uZTsKICAgICAgICB9CgogICAgICAgIC5jb2xsYXBzaWJsZTo6YmVmb3JlIHsKICAgICAgICAgICAgY29udGVudDogJ+KWvCAnOwogICAgICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7CiAgICAgICAgICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSAwLjNzIGVhc2U7CiAgICAgICAgfQoKICAgICAgICAuY29sbGFwc2libGUuY29sbGFwc2VkOjpiZWZvcmUgewogICAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgtOTBkZWcpOwogICAgICAgIH0KCiAgICAgICAgLmNvbGxhcHNpYmxlLWNvbnRlbnQgewogICAgICAgICAgICBtYXgtaGVpZ2h0OiAxMDAwcHg7CiAgICAgICAgICAgIG92ZXJmbG93OiBoaWRkZW47CiAgICAgICAgICAgIHRyYW5zaXRpb246IG1heC1oZWlnaHQgMC4zcyBlYXNlOwogICAgICAgIH0KCiAgICAgICAgLmNvbGxhcHNpYmxlLWNvbnRlbnQuaGlkZGVuIHsKICAgICAgICAgICAgbWF4LWhlaWdodDogMDsKICAgICAgICB9CgogICAgICAgIC5zdW1tYXJ5LWdyaWQgewogICAgICAgICAgICBkaXNwbGF5OiBncmlkOwogICAgICAgICAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IHJlcGVhdChhdXRvLWZpdCwgbWlubWF4KDIwMHB4LCAxZnIpKTsKICAgICAgICAgICAgZ2FwOiAxNXB4OwogICAgICAgICAgICBtYXJnaW46IDIwcHggMDsKICAgICAgICB9CgogICAgICAgIC5zdW1tYXJ5LWNhcmQgewogICAgICAgICAgICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoMTM1ZGVnLCAjNjY3ZWVhIDAlLCAjNzY0YmEyIDEwMCUpOwogICAgICAgICAgICBjb2xvcjogd2hpdGU7CiAgICAgICAgICAgIHBhZGRpbmc6IDIwcHg7CiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDhweDsKICAgICAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyOwogICAgICAgIH0KCiAgICAgICAgLnN1bW1hcnktbnVtYmVyIHsKICAgICAgICAgICAgZm9udC1zaXplOiAzMnB4OwogICAgICAgICAgICBmb250LXdlaWdodDogNzAwOwogICAgICAgICAgICBtYXJnaW4tYm90dG9tOiA1cHg7CiAgICAgICAgfQoKICAgICAgICAuc3VtbWFyeS1sYWJlbCB7CiAgICAgICAgICAgIGZvbnQtc2l6ZTogMTRweDsKICAgICAgICAgICAgb3BhY2l0eTogMC45OwogICAgICAgIH0KCiAgICAgICAgLnJlc2VuZC13YXJuaW5nIHsKICAgICAgICAgICAgYmFja2dyb3VuZDogI2ZmZmFmMDsKICAgICAgICAgICAgYm9yZGVyOiAycHggc29saWQgI2VkODkzNjsKICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogOHB4OwogICAgICAgICAgICBwYWRkaW5nOiAxMnB4IDE1cHg7CiAgICAgICAgICAgIG1hcmdpbjogMTBweCAwOwogICAgICAgICAgICBkaXNwbGF5OiBmbGV4OwogICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyOwogICAgICAgICAgICBnYXA6IDEwcHg7CiAgICAgICAgICAgIGZvbnQtc2l6ZTogMTNweDsKICAgICAgICAgICAgY29sb3I6ICM3NDQyMTA7CiAgICAgICAgfQoKICAgICAgICAucmVzZW5kLXdhcm5pbmc6OmJlZm9yZSB7CiAgICAgICAgICAgIGNvbnRlbnQ6ICfimqDvuI8nOwogICAgICAgICAgICBmb250LXNpemU6IDE4cHg7CiAgICAgICAgfQogICAgPC9zdHlsZT4KPC9oZWFkPgo8Ym9keT4KICAgIDxkaXYgY2xhc3M9ImNvbnRhaW5lciI+CiAgICAgICAgPGRpdiBjbGFzcz0iaGVhZGVyIj4KICAgICAgICAgICAgPGgxPvCfjq8gV0lMTE9XIFY1MCAtIENNQSBXb3JrYmVuY2g8L2gxPgogICAgICAgICAgICA8ZGl2IGNsYXNzPSJzdWJ0aXRsZSI+SG9tZWJlYXQtQ2VudHJpYyBJbnRlbGxpZ2VuY2UgfCBMZWFkOiA8c3BhbiBpZD0ibGVhZE5hbWUiPkxvYWRpbmcuLi48L3NwYW4+PC9kaXY+CiAgICAgICAgPC9kaXY+CgogICAgICAgIDxkaXYgY2xhc3M9InRhYnMiPgogICAgICAgICAgICA8YnV0dG9uIGNsYXNzPSJ0YWItYnV0dG9uIGFjdGl2ZSIgb25jbGljaz0ic3dpdGNoVGFiKCdjbWEtd29ya2JlbmNoJykiPgogICAgICAgICAgICAgICAg8J+TiiBDTUEgV29ya2JlbmNoCiAgICAgICAgICAgIDwvYnV0dG9uPgogICAgICAgICAgICA8YnV0dG9uIGNsYXNzPSJ0YWItYnV0dG9uIiBvbmNsaWNrPSJzd2l0Y2hUYWIoJ2hvbWViZWF0LW1hbmFnZXInKSI+CiAgICAgICAgICAgICAgICDwn4+gIEhvbWViZWF0IE1hbmFnZXIKICAgICAgICAgICAgPC9idXR0b24+CiAgICAgICAgICAgIDxidXR0b24gY2xhc3M9InRhYi1idXR0b24iIG9uY2xpY2s9InN3aXRjaFRhYignYWN0aW9uLXBsYW5uZXInKSI+CiAgICAgICAgICAgICAgICDimqEgQWN0aW9uIFBsYW5uZXIKICAgICAgICAgICAgPC9idXR0b24+CiAgICAgICAgPC9kaXY+CgogICAgICAgIDwhLS0gVEFCIDE6IENNQSBXT1JLQkVOQ0ggLS0+CiAgICAgICAgPGRpdiBpZD0iY21hLXdvcmtiZW5jaCIgY2xhc3M9InRhYi1jb250ZW50IGFjdGl2ZSI+CiAgICAgICAgICAgIDxkaXYgY2xhc3M9InNlY3Rpb24iPgogICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0ic2VjdGlvbi10aXRsZSI+8J+TiyBFeGlzdGluZyBDTUEgU3RhdHVzPC9kaXY+CiAgICAgICAgICAgICAgICA8ZGl2IGlkPSJleGlzdGluZ0NNQSIgY2xhc3M9ImluZm8tY2FyZCI+CiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0ibG9hZGluZyI+CiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InNwaW5uZXIiPjwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICBMb2FkaW5nIENNQSBkYXRhLi4uCiAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgPC9kaXY+CgogICAgICAgICAgICA8ZGl2IGNsYXNzPSJzZWN0aW9uIj4KICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InNlY3Rpb24tdGl0bGUiPvCfmoAgR2VuZXJhdGUgTmV3IENNQTwvZGl2PgogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJmb3JtLWdyb3VwIj4KICAgICAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9ImZvcm0tbGFiZWwiPlByb3BlcnR5IEFkZHJlc3MgKjwvbGFiZWw+CiAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9InRleHQiIGlkPSJjbWFBZGRyZXNzIiBjbGFzcz0iZm9ybS1pbnB1dCIgcGxhY2Vob2xkZXI9IjEyMyBNYWluIFN0LCBQb3VnaGtlZXBzaWUsIE5ZIDEyNjAxIj4KICAgICAgICAgICAgICAgIDwvZGl2PgoKICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImZvcm0tZ3JvdXAiPgogICAgICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz0iZm9ybS1sYWJlbCI+Q01BIFRlbXBsYXRlIFR5cGUgKjwvbGFiZWw+CiAgICAgICAgICAgICAgICAgICAgPHNlbGVjdCBpZD0iY21hVGVtcGxhdGVUeXBlIiBjbGFzcz0iZm9ybS1pbnB1dCI+CiAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9InF1aWNrIj7wn5qAIFF1aWNrIENNQSAoQXV0b21hdGVkIEVtYWlsIERlbGl2ZXJ5KTwvb3B0aW9uPgogICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPSJmdWxsIiBzZWxlY3RlZD7wn5OLIEZ1bGwgQ01BIChNYW51YWwgQWdlbnQgQ29tcGxldGlvbik8L29wdGlvbj4KICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT0id2Vic2l0ZSI+8J+MkCBXZWJzaXRlIENNQSAoTGl2ZSBIb21lYmVhdC1TdHlsZSk8L29wdGlvbj4KICAgICAgICAgICAgICAgICAgICA8L3NlbGVjdD4KICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJ0ZW1wbGF0ZS1kZXNjcmlwdGlvbiIgaWQ9InRlbXBsYXRlRGVzY3JpcHRpb24iIHN0eWxlPSJmb250LXNpemU6IDEycHg7IGNvbG9yOiAjNjY2OyBtYXJnaW4tdG9wOiA1cHg7Ij4KICAgICAgICAgICAgICAgICAgICAgICAgUHJvZmVzc2lvbmFsIENNQSB3aXRoIGZ1bGwgY3VzdG9taXphdGlvbiAtIGFnZW50IGNvbXBsZXRlcyBhbmQgZGVsaXZlcnMgbWFudWFsbHkKICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgIDwvZGl2PgoKICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImJ0bi1ncm91cCIgc3R5bGU9Im1hcmdpbi1ib3R0b206IDIwcHg7Ij4KICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9ImJ1dHRvbiIgY2xhc3M9ImJ0biBidG4tc2Vjb25kYXJ5IiBpZD0iYXV0b0ZpbGxCdXR0b24iIG9uY2xpY2s9ImF1dG9GaWxsUHJvcGVydHlEYXRhKCkiIHN0eWxlPSJiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoMTM1ZGVnLCAjMTBiOTgxIDAlLCAjMDU5NjY5IDEwMCUpOyBjb2xvcjogd2hpdGU7Ij4KICAgICAgICAgICAgICAgICAgICAgICAg8J+UjSBBdXRvLUZpbGwgUHJvcGVydHkgRGF0YSAoQVRUT00pCiAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+CiAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD0iYXR0b21TcGlubmVyIiBjbGFzcz0ic3Bpbm5lciIgc3R5bGU9ImRpc3BsYXk6IG5vbmU7IHdpZHRoOiAyMHB4OyBoZWlnaHQ6IDIwcHg7IG1hcmdpbi1sZWZ0OiAxMHB4OyI+PC9kaXY+CiAgICAgICAgICAgICAgICA8L2Rpdj4KCiAgICAgICAgICAgICAgICA8ZGl2IGlkPSJhdXRvT3B0aW1pemVkUGFyYW1zIiBjbGFzcz0iaW5mby1jYXJkIj4KICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJpbmZvLWNhcmQtdGl0bGUiPkF1dG8tT3B0aW1pemVkIFBhcmFtZXRlcnMgKEJhc2VkIG9uIEJlaGF2aW9yYWwgU2NvcmU6IDxzcGFuIGlkPSJiZWhhdmlvcmFsU2NvcmUiPi0tPC9zcGFuPik8L2Rpdj4KICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJpbmZvLWNhcmQtY29udGVudCI+CiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImZvcm0tcm93IiBzdHlsZT0ibWFyZ2luLXRvcDogMTVweDsiPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9ImZvcm0tbGFiZWwiPkJlZHM8L2xhYmVsPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPSJudW1iZXIiIGlkPSJjbWFCZWRzIiBjbGFzcz0iZm9ybS1pbnB1dCIgdmFsdWU9IjMiPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2PgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz0iZm9ybS1sYWJlbCI+QmF0aHM8L2xhYmVsPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPSJudW1iZXIiIGlkPSJjbWFCYXRocyIgY2xhc3M9ImZvcm0taW5wdXQiIHZhbHVlPSIyIj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9ImZvcm0tbGFiZWwiPlNxRnQ8L2xhYmVsPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPSJudW1iZXIiIGlkPSJjbWFTcWZ0IiBjbGFzcz0iZm9ybS1pbnB1dCIgdmFsdWU9IjIwMDAiPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJmb3JtLXJvdyIgc3R5bGU9Im1hcmdpbi10b3A6IDE1cHg7Ij4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXY+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPSJmb3JtLWxhYmVsIj5TZWFyY2ggUmFkaXVzIChtaSkg8J+kljwvbGFiZWw+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9Im51bWJlciIgc3RlcD0iMC4yNSIgaWQ9ImNtYVJhZGl1cyIgY2xhc3M9ImZvcm0taW5wdXQiIHZhbHVlPSIwLjc1IiByZWFkb25seT4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c21hbGwgc3R5bGU9ImNvbG9yOiAjNzE4MDk2OyI+U2NvcmUtb3B0aW1pemVkPC9zbWFsbD4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9ImZvcm0tbGFiZWwiPk1vbnRocyBCYWNrIPCfpJY8L2xhYmVsPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPSJudW1iZXIiIGlkPSJjbWFNb250aHNCYWNrIiBjbGFzcz0iZm9ybS1pbnB1dCIgdmFsdWU9IjkiIHJlYWRvbmx5PgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzbWFsbCBzdHlsZT0iY29sb3I6ICM3MTgwOTY7Ij5TY29yZS1vcHRpbWl6ZWQ8L3NtYWxsPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2PgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz0iZm9ybS1sYWJlbCI+TWluIENvbXBhcmFibGVzPC9sYWJlbD4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT0ibnVtYmVyIiBpZD0iY21hTWluTGlzdGluZ3MiIGNsYXNzPSJmb3JtLWlucHV0IiB2YWx1ZT0iMTAiPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgPC9kaXY+CgogICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iY29sbGFwc2libGUgY29sbGFwc2VkIiBvbmNsaWNrPSJ0b2dnbGVDb2xsYXBzaWJsZSh0aGlzKSI+CiAgICAgICAgICAgICAgICAgICAgPHNwYW4gc3R5bGU9ImZvbnQtd2VpZ2h0OiA2MDA7IGNvbG9yOiAjNjY3ZWVhOyI+RWRpdCBQYXJhbWV0ZXJzIE1hbnVhbGx5PC9zcGFuPgogICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJjb2xsYXBzaWJsZS1jb250ZW50IGhpZGRlbiI+CiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iZm9ybS1yb3ciIHN0eWxlPSJtYXJnaW4tdG9wOiAxNXB4OyI+CiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXY+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9ImZvcm0tbGFiZWwiPlByb3BlcnR5IFR5cGU8L2xhYmVsPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNlbGVjdCBpZD0iY21hUHJvcFR5cGUiIGNsYXNzPSJmb3JtLXNlbGVjdCI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT0iIj5Bbnk8L29wdGlvbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPSJSZXNpZGVudGlhbCI+UmVzaWRlbnRpYWw8L29wdGlvbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPSJSZXNpZGVudGlhbCBJbmNvbWUiPlJlc2lkZW50aWFsIEluY29tZTwvb3B0aW9uPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9IkxhbmQiPkxhbmQ8L29wdGlvbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPSJNYW51ZmFjdHVyZWQgSW4gUGFyayI+TWFudWZhY3R1cmVkIEluIFBhcms8L29wdGlvbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc2VsZWN0PgogICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgICAgICAgICAgPGRpdj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz0iZm9ybS1sYWJlbCI+VmFyaWFuY2UgKCUpPC9sYWJlbD4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPSJudW1iZXIiIGlkPSJjbWFWYXJpYW5jZSIgY2xhc3M9ImZvcm0taW5wdXQiIHZhbHVlPSIxMCI+CiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgPC9kaXY+CgogICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iZm9ybS1ncm91cCIgc3R5bGU9Im1hcmdpbi10b3A6IDIwcHg7Ij4KICAgICAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9ImZvcm0tbGFiZWwiPkNNQSBUaXRsZSAoT3B0aW9uYWwpPC9sYWJlbD4KICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT0idGV4dCIgaWQ9ImNtYVRpdGxlIiBjbGFzcz0iZm9ybS1pbnB1dCIgcGxhY2Vob2xkZXI9IkxlYXZlIGJsYW5rIHRvIGF1dG8tZ2VuZXJhdGUiPgogICAgICAgICAgICAgICAgPC9kaXY+CgogICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iY2hlY2tib3gtZ3JvdXAiPgogICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPSJjaGVja2JveCIgaWQ9ImNyZWF0ZUhvbWViZWF0IiBjaGVja2VkPgogICAgICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9ImNyZWF0ZUhvbWViZWF0Ij5DcmVhdGUgSG9tZWJlYXQgd2l0aCB0aGlzIENNQTwvbGFiZWw+CiAgICAgICAgICAgICAgICA8L2Rpdj4KCiAgICAgICAgICAgICAgICA8ZGl2IGlkPSJob21lYmVhdE9wdGlvbnMiIGNsYXNzPSJmb3JtLWdyb3VwIj4KICAgICAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9ImZvcm0tbGFiZWwiPkhvbWViZWF0IEZyZXF1ZW5jeTwvbGFiZWw+CiAgICAgICAgICAgICAgICAgICAgPHNlbGVjdCBpZD0iaG9tZWJlYXRGcmVxdWVuY3kiIGNsYXNzPSJmb3JtLXNlbGVjdCI+CiAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9InF1YXJ0ZXJseSI+UXVhcnRlcmx5PC9vcHRpb24+CiAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9Im1vbnRobHkiPk1vbnRobHk8L29wdGlvbj4KICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT0ic2VtaS1hbm51YWxseSI+U2VtaS1Bbm51YWxseTwvb3B0aW9uPgogICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPSJhbm51YWxseSI+QW5udWFsbHk8L29wdGlvbj4KICAgICAgICAgICAgICAgICAgICA8L3NlbGVjdD4KICAgICAgICAgICAgICAgIDwvZGl2PgoKICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImJ0bi1ncm91cCI+CiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz0iYnRuIGJ0bi1wcmltYXJ5IiBvbmNsaWNrPSJnZW5lcmF0ZUNNQSgpIj4KICAgICAgICAgICAgICAgICAgICAgICAg8J+agCBHRU5FUkFURSBDTUEgJiBDUkVBVEUgSE9NRUJFQVQKICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj4KICAgICAgICAgICAgICAgIDwvZGl2PgoKICAgICAgICAgICAgICAgIDxkaXYgaWQ9ImNtYVJlc3VsdCI+PC9kaXY+CiAgICAgICAgICAgIDwvZGl2PgogICAgICAgIDwvZGl2PgoKICAgICAgICA8IS0tIFRBQiAyOiBIT01FQkVBVCBNQU5BR0VSIC0tPgogICAgICAgIDxkaXYgaWQ9ImhvbWViZWF0LW1hbmFnZXIiIGNsYXNzPSJ0YWItY29udGVudCI+CiAgICAgICAgICAgIDxkaXYgY2xhc3M9InNlY3Rpb24iPgogICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0ic2VjdGlvbi10aXRsZSI+8J+PoCBBY3RpdmUgSG9tZWJlYXRzPC9kaXY+CiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImJ0bi1ncm91cCI+CiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz0iYnRuIGJ0bi1wcmltYXJ5IiBvbmNsaWNrPSJyZWZyZXNoSG9tZWJlYXRBbmFseXRpY3MoKSI+CiAgICAgICAgICAgICAgICAgICAgICAgIPCflIQgUmVmcmVzaCBBbmFseXRpY3MKICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj4KICAgICAgICAgICAgICAgIDwvZGl2PgoKICAgICAgICAgICAgICAgIDxkaXYgaWQ9ImhvbWViZWF0TGlzdCIgY2xhc3M9ImxvYWRpbmciIHN0eWxlPSJtYXJnaW4tdG9wOiAyMHB4OyI+CiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0ic3Bpbm5lciI+PC9kaXY+CiAgICAgICAgICAgICAgICAgICAgTG9hZGluZyBIb21lYmVhdCBkYXRhLi4uCiAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgPC9kaXY+CgogICAgICAgICAgICA8ZGl2IGNsYXNzPSJzZWN0aW9uIj4KICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InNlY3Rpb24tdGl0bGUiPvCfk4ogRW5nYWdlbWVudCBTdW1tYXJ5PC9kaXY+CiAgICAgICAgICAgICAgICA8ZGl2IGlkPSJlbmdhZ2VtZW50U3VtbWFyeSIgY2xhc3M9InN1bW1hcnktZ3JpZCI+CiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0ic3VtbWFyeS1jYXJkIj4KICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0ic3VtbWFyeS1udW1iZXIiIGlkPSJoaWdoRW5nYWdlbWVudENvdW50Ij4wPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InN1bW1hcnktbGFiZWwiPkhpZ2ggRW5nYWdlbWVudCAoMjArIHZpZXdzKTwvZGl2PgogICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InN1bW1hcnktY2FyZCI+CiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InN1bW1hcnktbnVtYmVyIiBpZD0ibWVkaXVtRW5nYWdlbWVudENvdW50Ij4wPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InN1bW1hcnktbGFiZWwiPk1lZGl1bSBFbmdhZ2VtZW50ICg1LTE5IHZpZXdzKTwvZGl2PgogICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InN1bW1hcnktY2FyZCI+CiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InN1bW1hcnktbnVtYmVyIiBpZD0ibG93RW5nYWdlbWVudENvdW50Ij4wPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InN1bW1hcnktbGFiZWwiPkxvdyBFbmdhZ2VtZW50ICgxLTQgdmlld3MpPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0ic3VtbWFyeS1jYXJkIj4KICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0ic3VtbWFyeS1udW1iZXIiIGlkPSJub3RBY2NlcHRlZENvdW50Ij4wPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InN1bW1hcnktbGFiZWwiPk5vdCBBY2NlcHRlZCAoMCB2aWV3cyk8L2Rpdj4KICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICA8L2Rpdj4KICAgICAgICA8L2Rpdj4KCiAgICAgICAgPCEtLSBUQUIgMzogQUNUSU9OIFBMQU5ORVIgLS0+CiAgICAgICAgPGRpdiBpZD0iYWN0aW9uLXBsYW5uZXIiIGNsYXNzPSJ0YWItY29udGVudCI+CiAgICAgICAgICAgIDxkaXYgY2xhc3M9InNlY3Rpb24iPgogICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0ic2VjdGlvbi10aXRsZSI+4pqhIFRyaWdnZXJlZCBBY3Rpb25zIChCYXNlZCBvbiBFbmdhZ2VtZW50KTwvZGl2PgogICAgICAgICAgICAgICAgPGRpdiBpZD0idHJpZ2dlcmVkQWN0aW9ucyI+CiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0ibG9hZGluZyI+CiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InNwaW5uZXIiPjwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICBBbmFseXppbmcgZW5nYWdlbWVudCBkYXRhLi4uCiAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgPC9kaXY+CgogICAgICAgICAgICA8ZGl2IGNsYXNzPSJzZWN0aW9uIj4KICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InNlY3Rpb24tdGl0bGUiPvCfk50gTWFudWFsIEFjdGlvbiBDcmVhdGlvbjwvZGl2PgogICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iZm9ybS1yb3ciPgogICAgICAgICAgICAgICAgICAgIDxkaXY+CiAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz0iZm9ybS1sYWJlbCI+QWN0aW9uIFR5cGU8L2xhYmVsPgogICAgICAgICAgICAgICAgICAgICAgICA8c2VsZWN0IGlkPSJhY3Rpb25UeXBlIiBjbGFzcz0iZm9ybS1zZWxlY3QiPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT0iVGFzayI+VGFzazwvb3B0aW9uPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT0iQ2FsbCI+Q2FsbDwvb3B0aW9uPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT0iRW1haWwiPkVtYWlsPC9vcHRpb24+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPSJOb3RlIj5Ob3RlPC9vcHRpb24+CiAgICAgICAgICAgICAgICAgICAgICAgIDwvc2VsZWN0PgogICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgIDxkaXY+CiAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz0iZm9ybS1sYWJlbCI+QXNzaWduIFRvPC9sYWJlbD4KICAgICAgICAgICAgICAgICAgICAgICAgPHNlbGVjdCBpZD0iYXNzaWduVG8iIGNsYXNzPSJmb3JtLXNlbGVjdCI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPSJHbGVubiI+R2xlbm48L29wdGlvbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9Ikp1c3RpbiI+SnVzdGluPC9vcHRpb24+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPSJIZWF0aGVyIj5IZWF0aGVyPC9vcHRpb24+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPSJMbG95ZCI+TGxveWQ8L29wdGlvbj4KICAgICAgICAgICAgICAgICAgICAgICAgPC9zZWxlY3Q+CiAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgPGRpdj4KICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPSJmb3JtLWxhYmVsIj5VcmdlbmN5PC9sYWJlbD4KICAgICAgICAgICAgICAgICAgICAgICAgPHNlbGVjdCBpZD0idXJnZW5jeSIgY2xhc3M9ImZvcm0tc2VsZWN0Ij4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9IklNTUVESUFURSI+SW1tZWRpYXRlICgyNGgpPC9vcHRpb24+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPSJTQU1FX0RBWSI+U2FtZSBEYXk8L29wdGlvbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9Ik5FWFRfREFZIj5OZXh0IERheTwvb3B0aW9uPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT0iV0VFS0xZIj5UaGlzIFdlZWs8L29wdGlvbj4KICAgICAgICAgICAgICAgICAgICAgICAgPC9zZWxlY3Q+CiAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImZvcm0tZ3JvdXAiIHN0eWxlPSJtYXJnaW4tdG9wOiAxNXB4OyI+CiAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPSJmb3JtLWxhYmVsIj5Ob3RlczwvbGFiZWw+CiAgICAgICAgICAgICAgICAgICAgPHRleHRhcmVhIGlkPSJhY3Rpb25Ob3RlcyIgY2xhc3M9ImZvcm0taW5wdXQiIHJvd3M9IjMiIHBsYWNlaG9sZGVyPSJFbnRlciBhY3Rpb24gZGV0YWlscy4uLiI+PC90ZXh0YXJlYT4KICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz0iYnRuIGJ0bi1wcmltYXJ5IiBvbmNsaWNrPSJjcmVhdGVNYW51YWxBY3Rpb24oKSI+CiAgICAgICAgICAgICAgICAgICAg4pyFIENSRUFURSBBQ1RJT04gSU4gRlVCCiAgICAgICAgICAgICAgICA8L2J1dHRvbj4KICAgICAgICAgICAgICAgIDxkaXYgaWQ9Im1hbnVhbEFjdGlvblJlc3VsdCI+PC9kaXY+CiAgICAgICAgICAgIDwvZGl2PgogICAgICAgIDwvZGl2PgogICAgPC9kaXY+CgogICAgPHNjcmlwdD4KICAgICAgICAvLyBHbG9iYWwgc3RhdGUKICAgICAgICBjb25zdCBBUElfQkFTRV9VUkwgPSAnaHR0cHM6Ly93aWxsb3ctdjUwLXN1cGVydmlzZWQtY21hLm5ldGxpZnkuYXBwJzsKICAgICAgICBsZXQgcGVyc29uSWQgPSBudWxsOwogICAgICAgIGxldCBwZXJzb25EYXRhID0gbnVsbDsKICAgICAgICBsZXQgaG9tZWJlYXREYXRhID0gbnVsbDsKCiAgICAgICAgLy8gQVRUT00gSW50ZWdyYXRpb24gU3RhdGUKICAgICAgICBjb25zdCBBdHRvbVN0YXRlID0gewogICAgICAgICAgbG9hZGluZzogZmFsc2UsCiAgICAgICAgICBsYXN0TG9va3VwOiBudWxsLAogICAgICAgICAgY2FjaGVFbmFibGVkOiB0cnVlCiAgICAgICAgfTsKCiAgICAgICAgLy8gSW5pdGlhbGl6ZSBhcHAKICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGFzeW5jICgpID0+IHsKICAgICAgICAgICAgY29uc29sZS5sb2coJ/CfmoAgQXBwIGluaXRpYWxpemluZy4uLicpOwogICAgICAgICAgICBjb25zb2xlLmxvZygn8J+MkCBDdXJyZW50IFVSTDonLCB3aW5kb3cubG9jYXRpb24uaHJlZik7CiAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5SNIFF1ZXJ5IHBhcmFtczonLCB3aW5kb3cubG9jYXRpb24uc2VhcmNoKTsKICAgICAgICAgICAgCiAgICAgICAgICAgIC8vIE1ldGhvZCAxOiBUcnkgdG8gZGVjb2RlIEZVQidzIGNvbnRleHQgcXVlcnkgcGFyYW1ldGVyCiAgICAgICAgICAgIGNvbnN0IHVybFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMod2luZG93LmxvY2F0aW9uLnNlYXJjaCk7CiAgICAgICAgICAgIGNvbnN0IGNvbnRleHRQYXJhbSA9IHVybFBhcmFtcy5nZXQoJ2NvbnRleHQnKTsKICAgICAgICAgICAgCiAgICAgICAgICAgIGlmIChjb250ZXh0UGFyYW0pIHsKICAgICAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ/Cfk6YgRm91bmQgY29udGV4dCBwYXJhbWV0ZXIsIGRlY29kaW5nLi4uJyk7CiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ/Cfk6YgUmF3IGNvbnRleHQgcGFyYW0gKGZpcnN0IDEwMCBjaGFycyk6JywgY29udGV4dFBhcmFtLnN1YnN0cmluZygwLCAxMDApKTsKICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZXh0SnNvbiA9IGF0b2IoY29udGV4dFBhcmFtKTsKICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygn8J+TpiBEZWNvZGVkIEpTT04gc3RyaW5nOicsIGNvbnRleHRKc29uKTsKICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZXh0ID0gSlNPTi5wYXJzZShjb250ZXh0SnNvbik7CiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ+KchSBQYXJzZWQgRlVCIGNvbnRleHQgb2JqZWN0OicsIEpTT04uc3RyaW5naWZ5KGNvbnRleHQsIG51bGwsIDIpKTsKICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0LnBlcnNvbiAmJiBjb250ZXh0LnBlcnNvbi5pZCkgewogICAgICAgICAgICAgICAgICAgICAgICBwZXJzb25JZCA9IGNvbnRleHQucGVyc29uLmlkOwogICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygn4pyFIEdvdCBwZXJzb25faWQgZnJvbSBjb250ZXh0IHBhcmFtOicsIHBlcnNvbklkKTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikgewogICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybign4pqg77iPIEZhaWxlZCB0byBkZWNvZGUgY29udGV4dCBwYXJhbWV0ZXI6JywgZXJyb3IpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIAogICAgICAgICAgICAvLyBNZXRob2QgMjogVHJ5IEZVQiBTREsgZ2V0Q29udGV4dCgpCiAgICAgICAgICAgIGlmICghcGVyc29uSWQgJiYgd2luZG93LkVtYmVkZGVkQXBwcykgewogICAgICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygn8J+UhCBUcnlpbmcgRW1iZWRkZWRBcHBzLmluaXQoKS4uLicpOwogICAgICAgICAgICAgICAgICAgIGF3YWl0IHdpbmRvdy5FbWJlZGRlZEFwcHMuaW5pdCgpOwogICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCfinIUgRlVCIFNESyBpbml0aWFsaXplZCcpOwogICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSBhd2FpdCB3aW5kb3cuRW1iZWRkZWRBcHBzLmdldENvbnRleHQoKTsKICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygn8J+TpiBGVUIgU0RLIENvbnRleHQ6JywgY29udGV4dCk7CiAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5wZXJzb24gJiYgY29udGV4dC5wZXJzb24uaWQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgcGVyc29uSWQgPSBjb250ZXh0LnBlcnNvbi5pZDsKICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ+KchSBHb3QgcGVyc29uX2lkIGZyb20gU0RLIGNvbnRleHQ6JywgcGVyc29uSWQpOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7CiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCfimqDvuI8gRlVCIFNESyBlcnJvcjonLCBlcnJvcik7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgCiAgICAgICAgICAgIC8vIE1ldGhvZCAzOiBGYWxsYmFjayB0byBwZXJzb25faWQgVVJMIHBhcmFtZXRlcgogICAgICAgICAgICBpZiAoIXBlcnNvbklkKSB7CiAgICAgICAgICAgICAgICBwZXJzb25JZCA9IHVybFBhcmFtcy5nZXQoJ3BlcnNvbl9pZCcpOwogICAgICAgICAgICAgICAgaWYgKHBlcnNvbklkKSB7CiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ+KaoO+4jyBVc2luZyBVUkwgcGVyc29uX2lkIChmYWxsYmFjayk6JywgcGVyc29uSWQpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CgogICAgICAgICAgICBpZiAoIXBlcnNvbklkKSB7CiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgTm8gcGVyc29uX2lkIGZvdW5kIHZpYSBhbnkgbWV0aG9kJyk7CiAgICAgICAgICAgICAgICBzaG93RXJyb3IoJ05vIHBlcnNvbiBJRCBwcm92aWRlZC4gVHJpZWQ6IGNvbnRleHQgcGFyYW0sIFNESyBnZXRDb250ZXh0KCksIFVSTCBwYXJhbS4nKTsKICAgICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgfQogICAgICAgICAgICAKICAgICAgICAgICAgY29uc29sZS5sb2coJ/Cfjq8gRmluYWwgcGVyc29uX2lkOicsIHBlcnNvbklkKTsKICAgICAgICAgICAgY29uc29sZS5sb2coJ/Cfjq8gUGVyc29uX2lkIHR5cGU6JywgdHlwZW9mIHBlcnNvbklkKTsKICAgICAgICAgICAgCiAgICAgICAgICAgIGlmICghcGVyc29uSWQpIHsKICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ/CfkqUgQ1JJVElDQUw6IE5vIHBlcnNvbl9pZCBhZnRlciBhbGwgMyBtZXRob2RzIScpOwogICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcign8J+SpSB3aW5kb3cubG9jYXRpb24uaHJlZjonLCB3aW5kb3cubG9jYXRpb24uaHJlZik7CiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCfwn5KlIHdpbmRvdy5FbWJlZGRlZEFwcHMgZXhpc3RzOicsICEhd2luZG93LkVtYmVkZGVkQXBwcyk7CiAgICAgICAgICAgICAgICBzaG93RXJyb3IoJ+KdjCBVbmFibGUgdG8gZGV0ZXJtaW5lIHBlcnNvbiBJRC4gQ2hlY2sgYnJvd3NlciBjb25zb2xlIGZvciBkZXRhaWxzLicpOwogICAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICB9CgogICAgICAgICAgICBhd2FpdCBsb2FkUGVyc29uRGF0YSgpOwogICAgICAgICAgICBhd2FpdCBsb2FkSG9tZWJlYXREYXRhKCk7CiAgICAgICAgICAgIAogICAgICAgICAgICAvLyBTZXR1cCB0ZW1wbGF0ZSB0eXBlIGNoYW5nZSBoYW5kbGVyCiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjbWFUZW1wbGF0ZVR5cGUnKS5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB1cGRhdGVUZW1wbGF0ZURlc2NyaXB0aW9uKTsKICAgICAgICAgICAgdXBkYXRlVGVtcGxhdGVEZXNjcmlwdGlvbigpOyAvLyBTZXQgaW5pdGlhbCBkZXNjcmlwdGlvbgogICAgICAgIH0pOwogICAgICAgIAogICAgICAgIC8vIFVwZGF0ZSB0ZW1wbGF0ZSBkZXNjcmlwdGlvbiBiYXNlZCBvbiBzZWxlY3Rpb24KICAgICAgICBmdW5jdGlvbiB1cGRhdGVUZW1wbGF0ZURlc2NyaXB0aW9uKCkgewogICAgICAgICAgICBjb25zdCB0ZW1wbGF0ZVR5cGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY21hVGVtcGxhdGVUeXBlJykudmFsdWU7CiAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uRGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RlbXBsYXRlRGVzY3JpcHRpb24nKTsKICAgICAgICAgICAgCiAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0aW9ucyA9IHsKICAgICAgICAgICAgICAgICdxdWljayc6ICdBdXRvbWF0ZWQgbGVhZCBnZW5lcmF0aW9uIENNQSAtIGVtYWlsZWQgdG8gY2xpZW50IHdpdGhpbiAxIG1pbnV0ZSB1c2luZyBXZWIgTGVhZHMgdGVtcGxhdGUnLAogICAgICAgICAgICAgICAgJ2Z1bGwnOiAnUHJvZmVzc2lvbmFsIENNQSB3aXRoIGZ1bGwgY3VzdG9taXphdGlvbiAtIGFnZW50IGNvbXBsZXRlcyBhbmQgZGVsaXZlcnMgbWFudWFsbHknLCAKICAgICAgICAgICAgICAgICd3ZWJzaXRlJzogJ0xpdmUgaW50ZXJhY3RpdmUgQ01BIChIb21lYmVhdC1zdHlsZSkgLSBjYW4gYmUgZW1haWxlZCBhdXRvbWF0aWNhbGx5IG9yIGludGVncmF0ZWQgd2l0aCBGVUInCiAgICAgICAgICAgIH07CiAgICAgICAgICAgIAogICAgICAgICAgICBkZXNjcmlwdGlvbkRpdi50ZXh0Q29udGVudCA9IGRlc2NyaXB0aW9uc1t0ZW1wbGF0ZVR5cGVdIHx8IGRlc2NyaXB0aW9uc1snZnVsbCddOwogICAgICAgIH0KICAgICAgICAKICAgICAgICAvLyBTaG93IHZpZXcgY291bnQgd2FybmluZyBmb3IgbGl2ZSBVUkxzCiAgICAgICAgZnVuY3Rpb24gc2hvd1ZpZXdDb3VudFdhcm5pbmcobGl2ZVVybCkgewogICAgICAgICAgICBjb25zdCBjb25maXJtZWQgPSBjb25maXJtKAogICAgICAgICAgICAgICAgJ+KaoO+4jyBWSUVXIENPVU5UIFdBUk5JTkcg4pqg77iPXG5cbicgKwogICAgICAgICAgICAgICAgJ1RoaXMgbGl2ZSBVUkwgd2lsbCBpbmNyZW1lbnQgdGhlIGNsaWVudCB2aWV3IGNvdW50ZXIuXG4nICsKICAgICAgICAgICAgICAgICdFYWNoIHZpZXcgbWF5IGFmZmVjdCBjbGllbnQgZW5nYWdlbWVudCBhbmFseXRpY3MuXG5cbicgKwogICAgICAgICAgICAgICAgJ0NvbnNpZGVyIHVzaW5nICJBZ2VudCBQcmV2aWV3IiBvciAiRWRpdCBDTUEiIGxpbmtzIGluc3RlYWQuXG5cbicgKwogICAgICAgICAgICAgICAgJ0RvIHlvdSBzdGlsbCB3YW50IHRvIHByb2NlZWQ/JwogICAgICAgICAgICApOwogICAgICAgICAgICAKICAgICAgICAgICAgaWYgKGNvbmZpcm1lZCkgewogICAgICAgICAgICAgICAgd2luZG93Lm9wZW4obGl2ZVVybCwgJ19ibGFuaycpOwogICAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIAogICAgICAgIC8vIENvcHkgVVJMIHRvIGNsaXBib2FyZCBmb3IgY2xpZW50IGRlbGl2ZXJ5CiAgICAgICAgZnVuY3Rpb24gY29weVRvQ2xpcGJvYXJkKHVybCkgewogICAgICAgICAgICBuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dCh1cmwpLnRoZW4oKCkgPT4gewogICAgICAgICAgICAgICAgLy8gU2hvdyB0ZW1wb3Jhcnkgc3VjY2VzcyBtZXNzYWdlCiAgICAgICAgICAgICAgICBjb25zdCB0b2FzdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpOwogICAgICAgICAgICAgICAgdG9hc3QuaW5uZXJIVE1MID0gJ+KckyBDb3BpZWQgdG8gY2xpcGJvYXJkJzsKICAgICAgICAgICAgICAgIHRvYXN0LnN0eWxlLmNzc1RleHQgPSAncG9zaXRpb246IGZpeGVkOyB0b3A6IDIwcHg7IHJpZ2h0OiAyMHB4OyBiYWNrZ3JvdW5kOiAjMDU5NjY5OyBjb2xvcjogd2hpdGU7IHBhZGRpbmc6IDEwcHggMTVweDsgYm9yZGVyLXJhZGl1czogNnB4OyB6LWluZGV4OiAxMDAwOyBmb250LXdlaWdodDogNjAwOyc7CiAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRvYXN0KTsKICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0b2FzdCksIDIwMDApOwogICAgICAgICAgICB9KS5jYXRjaCgoKSA9PiB7CiAgICAgICAgICAgICAgICAvLyBGYWxsYmFjayBmb3Igb2xkZXIgYnJvd3NlcnMKICAgICAgICAgICAgICAgIHByb21wdCgnQ29weSB0aGlzIFVSTDonLCB1cmwpOwogICAgICAgICAgICB9KTsKICAgICAgICB9CgogICAgICAgIC8vIFRhYiBzd2l0Y2hpbmcKICAgICAgICBmdW5jdGlvbiBzd2l0Y2hUYWIodGFiSWQpIHsKICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnRhYi1jb250ZW50JykuZm9yRWFjaCh0YWIgPT4gdGFiLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpKTsKICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnRhYi1idXR0b24nKS5mb3JFYWNoKGJ0biA9PiBidG4uY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJykpOwogICAgICAgICAgICAKICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGFiSWQpLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpOwogICAgICAgICAgICBldmVudC50YXJnZXQuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7CgogICAgICAgICAgICAvLyBSZWZyZXNoIGRhdGEgd2hlbiBzd2l0Y2hpbmcgdG8gc3BlY2lmaWMgdGFicwogICAgICAgICAgICBpZiAodGFiSWQgPT09ICdob21lYmVhdC1tYW5hZ2VyJykgewogICAgICAgICAgICAgICAgcmVmcmVzaEhvbWViZWF0QW5hbHl0aWNzKCk7CiAgICAgICAgICAgIH0gZWxzZSBpZiAodGFiSWQgPT09ICdhY3Rpb24tcGxhbm5lcicpIHsKICAgICAgICAgICAgICAgIGdlbmVyYXRlVHJpZ2dlcmVkQWN0aW9ucygpOwogICAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICAvLyBUb2dnbGUgY29sbGFwc2libGUgc2VjdGlvbnMKICAgICAgICBmdW5jdGlvbiB0b2dnbGVDb2xsYXBzaWJsZShlbGVtZW50KSB7CiAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZSgnY29sbGFwc2VkJyk7CiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBlbGVtZW50Lm5leHRFbGVtZW50U2libGluZzsKICAgICAgICAgICAgY29udGVudC5jbGFzc0xpc3QudG9nZ2xlKCdoaWRkZW4nKTsKICAgICAgICB9CgogICAgICAgIC8vIExvYWQgcGVyc29uIGRhdGEgZnJvbSBGVUIKICAgICAgICBhc3luYyBmdW5jdGlvbiBsb2FkUGVyc29uRGF0YSgpIHsKICAgICAgICAgICAgY29uc29sZS5sb2coJ/Cfk6EgbG9hZFBlcnNvbkRhdGEoKSBjYWxsZWQgd2l0aCBwZXJzb25faWQ6JywgcGVyc29uSWQpOwogICAgICAgICAgICAKICAgICAgICAgICAgLy8gVmFsaWRhdGUgcGVyc29uSWQgYmVmb3JlIG1ha2luZyBBUEkgY2FsbAogICAgICAgICAgICBpZiAoIXBlcnNvbklkIHx8IHBlcnNvbklkID09PSAnbnVsbCcgfHwgcGVyc29uSWQgPT09ICd1bmRlZmluZWQnKSB7CiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgSW52YWxpZCBwZXJzb25faWQ6JywgcGVyc29uSWQpOwogICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2V4aXN0aW5nQ01BJykuaW5uZXJIVE1MID0gYAogICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImVycm9yIj7inYwgSW52YWxpZCBwZXJzb24gSUQuIFVuYWJsZSB0byBsb2FkIGRhdGEuPC9kaXY+CiAgICAgICAgICAgICAgICBgOwogICAgICAgICAgICAgICAgc2hvd0Vycm9yKCdJbnZhbGlkIHBlcnNvbiBJRDogJyArIHBlcnNvbklkKTsKICAgICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgfQogICAgICAgICAgICAKICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn4yQIEZldGNoaW5nIHBlcnNvbiBkYXRhIGZyb20gQVBJLi4uJyk7CiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vLm5ldGxpZnkvZnVuY3Rpb25zL3dpbGxvdy1jbWEtd29ya2JlbmNoP2FjdGlvbj1nZXRQZXJzb25EYXRhJnBlcnNvbklkPSR7cGVyc29uSWR9YCk7CiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygn8J+TpSBBUEkgcmVzcG9uc2Ugc3RhdHVzOicsIHJlc3BvbnNlLnN0YXR1cyk7CiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7CiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygn8J+TpiBBUEkgcmVzcG9uc2UgZGF0YTonLCBkYXRhKTsKICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgaWYgKGRhdGEuZXJyb3IpIHsKICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgQVBJIHJldHVybmVkIGVycm9yOicsIGRhdGEuZXJyb3IpOwogICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdleGlzdGluZ0NNQScpLmlubmVySFRNTCA9IGAKICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iZXJyb3IiPkVycm9yOiAke2RhdGEuZXJyb3J9PC9kaXY+CiAgICAgICAgICAgICAgICAgICAgYDsKICAgICAgICAgICAgICAgICAgICBzaG93RXJyb3IoZGF0YS5lcnJvcik7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgIHBlcnNvbkRhdGEgPSBkYXRhOwogICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xlYWROYW1lJykudGV4dENvbnRlbnQgPSBkYXRhLm5hbWUgfHwgJ1Vua25vd24nOwogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgYmVoYXZpb3JhbCBzY29yZQogICAgICAgICAgICAgICAgY29uc3Qgc2NvcmUgPSBkYXRhLmN1c3RvbVdJTExPV0JlaGF2aW9yYWxTY29yZVY0MCB8fCA1MDsKICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdiZWhhdmlvcmFsU2NvcmUnKS50ZXh0Q29udGVudCA9IGAke3Njb3JlfS8xMDBgOwogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAvLyBQcmVwb3B1bGF0ZSBhZGRyZXNzIGZpZWxkIGZyb20gY3VzdG9tV0lMTE9XX1Byb3BlcnR5QWRkcmVzcwogICAgICAgICAgICAgICAgY29uc3QgcHJvcGVydHlBZGRyZXNzID0gZGF0YS5jdXN0b21XSUxMT1dfUHJvcGVydHlBZGRyZXNzIHx8ICcnOwogICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5QWRkcmVzcykgewogICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5ONIFByZXBvcHVsYXRpbmcgYWRkcmVzcyBmcm9tIEZVQjonLCBwcm9wZXJ0eUFkZHJlc3MpOwogICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjbWFBZGRyZXNzJykudmFsdWUgPSBwcm9wZXJ0eUFkZHJlc3M7CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCfimqDvuI8gTm8gY3VzdG9tV0lMTE9XX1Byb3BlcnR5QWRkcmVzcyBmb3VuZCBpbiBGVUIgZGF0YScpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAvLyBBdXRvLW9wdGltaXplIHBhcmFtZXRlcnMgYmFzZWQgb24gc2NvcmUKICAgICAgICAgICAgICAgIG9wdGltaXplQ01BUGFyYW1ldGVycyhzY29yZSk7CiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgIC8vIERpc3BsYXkgZXhpc3RpbmcgQ01BIGlmIGF2YWlsYWJsZQogICAgICAgICAgICAgICAgZGlzcGxheUV4aXN0aW5nQ01BKGRhdGEpOwogICAgICAgICAgICAgICAgCiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7CiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCfwn5KlIEV4Y2VwdGlvbiBpbiBsb2FkUGVyc29uRGF0YSgpOicsIGVycm9yKTsKICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdleGlzdGluZ0NNQScpLmlubmVySFRNTCA9IGAKICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJlcnJvciI+RmFpbGVkIHRvIGxvYWQgcGVyc29uIGRhdGE6ICR7ZXJyb3IubWVzc2FnZX08L2Rpdj4KICAgICAgICAgICAgICAgIGA7CiAgICAgICAgICAgICAgICBzaG93RXJyb3IoJ0ZhaWxlZCB0byBsb2FkIHBlcnNvbiBkYXRhOiAnICsgZXJyb3IubWVzc2FnZSk7CiAgICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIC8vIE9wdGltaXplIENNQSBwYXJhbWV0ZXJzIGJhc2VkIG9uIGJlaGF2aW9yYWwgc2NvcmUKICAgICAgICBmdW5jdGlvbiBvcHRpbWl6ZUNNQVBhcmFtZXRlcnMoc2NvcmUpIHsKICAgICAgICAgICAgbGV0IHJhZGl1cywgbW9udGhzQmFjazsKICAgICAgICAgICAgCiAgICAgICAgICAgIGlmIChzY29yZSA+PSA5MCkgewogICAgICAgICAgICAgICAgcmFkaXVzID0gMC4yNTsKICAgICAgICAgICAgICAgIG1vbnRoc0JhY2sgPSAzOwogICAgICAgICAgICB9IGVsc2UgaWYgKHNjb3JlID49IDc1KSB7CiAgICAgICAgICAgICAgICByYWRpdXMgPSAwLjU7CiAgICAgICAgICAgICAgICBtb250aHNCYWNrID0gNjsKICAgICAgICAgICAgfSBlbHNlIGlmIChzY29yZSA+PSA2MCkgewogICAgICAgICAgICAgICAgcmFkaXVzID0gMC43NTsKICAgICAgICAgICAgICAgIG1vbnRoc0JhY2sgPSA5OwogICAgICAgICAgICB9IGVsc2UgaWYgKHNjb3JlID49IDQwKSB7CiAgICAgICAgICAgICAgICByYWRpdXMgPSAxLjA7CiAgICAgICAgICAgICAgICBtb250aHNCYWNrID0gMTI7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICByYWRpdXMgPSAxLjU7CiAgICAgICAgICAgICAgICBtb250aHNCYWNrID0gMTg7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgCiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjbWFSYWRpdXMnKS52YWx1ZSA9IHJhZGl1czsKICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NtYU1vbnRoc0JhY2snKS52YWx1ZSA9IG1vbnRoc0JhY2s7CiAgICAgICAgfQoKICAgICAgICAvLyBEaXNwbGF5IGV4aXN0aW5nIENNQSB3aXRoIGFsbCBhdmFpbGFibGUgbGlua3MKICAgICAgICBmdW5jdGlvbiBkaXNwbGF5RXhpc3RpbmdDTUEoZGF0YSkgewogICAgICAgICAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZXhpc3RpbmdDTUEnKTsKICAgICAgICAgICAgCiAgICAgICAgICAgIGlmIChkYXRhLmN1c3RvbVdJTExPV0NNQURhdGUgJiYgKGRhdGEuY3VzdG9tV0lMTE9XQ01BTGluayB8fCBkYXRhLmN1c3RvbVdJTExPV0NNQUVkaXRVUkwgfHwgZGF0YS5jdXN0b21XSUxMT1dDTUFQREZVUkwpKSB7CiAgICAgICAgICAgICAgICAvLyBUZW1wbGF0ZSB0eXBlIHdpdGggaWNvbgogICAgICAgICAgICAgICAgY29uc3QgdGVtcGxhdGVJY29ucyA9IHsKICAgICAgICAgICAgICAgICAgICAncXVpY2snOiAn8J+agCBRdWljayBDTUEnLAogICAgICAgICAgICAgICAgICAgICd3ZWJzaXRlJzogJ/CfjJAgV2Vic2l0ZSBDTUEnLCAKICAgICAgICAgICAgICAgICAgICAnZnVsbCc6ICfwn5OLIEZ1bGwgQ01BJwogICAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgICAgIGNvbnN0IHRlbXBsYXRlRGlzcGxheSA9IHRlbXBsYXRlSWNvbnNbZGF0YS5jdXN0b21XSUxMT1dDTUFUeXBlXSB8fCAn8J+TiyBDTUEnOwogICAgICAgICAgICAgICAgY29uc3Qgc3RhdHVzQmFkZ2UgPSBkYXRhLmN1c3RvbVdJTExPV0NNQVN0YXR1cyA9PT0gJ2NyZWF0ZWQnID8gCiAgICAgICAgICAgICAgICAgICAgJzxzcGFuIHN0eWxlPSJiYWNrZ3JvdW5kOiAjMTBiOTgxOyBjb2xvcjogd2hpdGU7IHBhZGRpbmc6IDJweCA4cHg7IGJvcmRlci1yYWRpdXM6IDEycHg7IGZvbnQtc2l6ZTogMTFweDsgZm9udC13ZWlnaHQ6IDYwMDsiPuKckyBSRUFEWTwvc3Bhbj4nIDoKICAgICAgICAgICAgICAgICAgICAnPHNwYW4gc3R5bGU9ImJhY2tncm91bmQ6ICNmNTllMGI7IGNvbG9yOiB3aGl0ZTsgcGFkZGluZzogMnB4IDhweDsgYm9yZGVyLXJhZGl1czogMTJweDsgZm9udC1zaXplOiAxMXB4OyBmb250LXdlaWdodDogNjAwOyI+RFJBRlQ8L3NwYW4+JzsKICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgLy8gQnVpbGQgY29tcHJlaGVuc2l2ZSBidXR0b24gbGF5b3V0IC0gQWdlbnQgdnMgQ2xpZW50IFVSTHMKICAgICAgICAgICAgICAgIGxldCBhZ2VudEJ1dHRvbnMgPSBbXTsKICAgICAgICAgICAgICAgIGxldCBjbGllbnRCdXR0b25zID0gW107CiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgIC8vIEFHRU5UIFNFQ1RJT04gKFNhZmUgZm9yIEdsZW5uICYgUGFydG5lcnMgLSBObyBWaWV3IENvdW50IEltcGFjdCkKICAgICAgICAgICAgICAgIGlmIChkYXRhLmN1c3RvbVdJTExPV0NNQUVkaXRVUkwpIHsKICAgICAgICAgICAgICAgICAgICBjb25zdCBlZGl0SWNvbiA9IGRhdGEuY3VzdG9tV0lMTE9XQ01BVHlwZSA9PT0gJ2Z1bGwnID8gJ+Kcj++4jyBFZGl0JyA6ICfwn5GB77iPIFZpZXcnOwogICAgICAgICAgICAgICAgICAgIGFnZW50QnV0dG9ucy5wdXNoKGAKICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz0iYnRuIGJ0bi1zZWNvbmRhcnkiIG9uY2xpY2s9IndpbmRvdy5vcGVuKCcke2RhdGEuY3VzdG9tV0lMTE9XQ01BRWRpdFVSTH0nLCAnX2JsYW5rJykiIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPSJiYWNrZ3JvdW5kOiAjNjM2NmYxOyBjb2xvcjogd2hpdGU7IG1hcmdpbjogMnB4OyIgdGl0bGU9IkFnZW50IGVkaXRpbmcgaW50ZXJmYWNlIC0gY29tcGxldGVseSBzYWZlIj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICR7ZWRpdEljb259CiAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPgogICAgICAgICAgICAgICAgICAgIGApOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICBpZiAoZGF0YS5jdXN0b21XSUxMT1dDTUFBZ2VudExpdmVVUkwpIHsKICAgICAgICAgICAgICAgICAgICBhZ2VudEJ1dHRvbnMucHVzaChgCiAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9ImJ0biBidG4tc2Vjb25kYXJ5IiBvbmNsaWNrPSJ3aW5kb3cub3BlbignJHtkYXRhLmN1c3RvbVdJTExPV0NNQUFnZW50TGl2ZVVSTH0nLCAnX2JsYW5rJykiIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPSJiYWNrZ3JvdW5kOiAjMDU5NjY5OyBjb2xvcjogd2hpdGU7IG1hcmdpbjogMnB4OyIgdGl0bGU9IkFnZW50LXNhZmUgbGl2ZSBkZWxpdmVyYWJsZSAoP3ByZXZpZXc9YWdlbnQpIj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIPCfjJAgTGl2ZSBQcmV2aWV3CiAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPgogICAgICAgICAgICAgICAgICAgIGApOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICBpZiAoZGF0YS5jdXN0b21XSUxMT1dDTUFBZ2VudFBERlVSTCkgewogICAgICAgICAgICAgICAgICAgIGFnZW50QnV0dG9ucy5wdXNoKGAKICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz0iYnRuIGJ0bi1zZWNvbmRhcnkiIG9uY2xpY2s9IndpbmRvdy5vcGVuKCcke2RhdGEuY3VzdG9tV0lMTE9XQ01BQWdlbnRQREZVUkx9JywgJ19ibGFuaycpIiAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT0iYmFja2dyb3VuZDogIzA4OTFiMjsgY29sb3I6IHdoaXRlOyBtYXJnaW46IDJweDsiIHRpdGxlPSJBZ2VudC1zYWZlIFBERiBkZWxpdmVyYWJsZSAoP3ByZXZpZXc9YWdlbnQpIj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIPCfk4QgUERGIFByZXZpZXcKICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+CiAgICAgICAgICAgICAgICAgICAgYCk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgIC8vIENMSUVOVCBTRUNUSU9OIChGb3IgQ2xpZW50IERlbGl2ZXJ5IC0gV2lsbCBDb3VudCBWaWV3cykKICAgICAgICAgICAgICAgIGlmIChkYXRhLmN1c3RvbVdJTExPV0NNQUxpdmVVUkwpIHsKICAgICAgICAgICAgICAgICAgICBjbGllbnRCdXR0b25zLnB1c2goYAogICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPSJidG4gYnRuLXNlY29uZGFyeSIgb25jbGljaz0iY29weVRvQ2xpcGJvYXJkKCcke2RhdGEuY3VzdG9tV0lMTE9XQ01BTGl2ZVVSTH0nKSIgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9ImJhY2tncm91bmQ6ICNkYzI2MjY7IGNvbG9yOiB3aGl0ZTsgbWFyZ2luOiAycHg7IiB0aXRsZT0iQ29weSBjbGllbnQgbGl2ZSBVUkwgdG8gY2xpcGJvYXJkIj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIPCflJcgQ29weSBMaXZlIFVSTAogICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj4KICAgICAgICAgICAgICAgICAgICBgKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgaWYgKGRhdGEuY3VzdG9tV0lMTE9XQ01BUERGVVJMKSB7CiAgICAgICAgICAgICAgICAgICAgY2xpZW50QnV0dG9ucy5wdXNoKGAKICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz0iYnRuIGJ0bi1zZWNvbmRhcnkiIG9uY2xpY2s9ImNvcHlUb0NsaXBib2FyZCgnJHtkYXRhLmN1c3RvbVdJTExPV0NNQVBERlVSTH0nKSIgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9ImJhY2tncm91bmQ6ICNkYzI2MjY7IGNvbG9yOiB3aGl0ZTsgbWFyZ2luOiAycHg7IiB0aXRsZT0iQ29weSBjbGllbnQgUERGIFVSTCB0byBjbGlwYm9hcmQiPgogICAgICAgICAgICAgICAgICAgICAgICAgICAg8J+UlyBDb3B5IFBERiBVUkwKICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+CiAgICAgICAgICAgICAgICAgICAgYCk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIG1haW4gbGluayBpZiBubyBzcGVjaWZpYyBVUkxzIGF2YWlsYWJsZQogICAgICAgICAgICAgICAgaWYgKGRhdGEuY3VzdG9tV0lMTE9XQ01BTGluayAmJiBhZ2VudEJ1dHRvbnMubGVuZ3RoID09PSAwICYmIGNsaWVudEJ1dHRvbnMubGVuZ3RoID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgYWdlbnRCdXR0b25zLnB1c2goYAogICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPSJidG4gYnRuLXNlY29uZGFyeSIgb25jbGljaz0id2luZG93Lm9wZW4oJyR7ZGF0YS5jdXN0b21XSUxMT1dDTUFMaW5rfScsICdfYmxhbmsnKSI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICDwn5OEIFZpZXcgQ01BCiAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPgogICAgICAgICAgICAgICAgICAgIGApOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gYAogICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImluZm8tY2FyZC10aXRsZSI+CiAgICAgICAgICAgICAgICAgICAgICAgICR7dGVtcGxhdGVEaXNwbGF5fSAke3N0YXR1c0JhZGdlfQogICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImluZm8tY2FyZC1jb250ZW50Ij4KICAgICAgICAgICAgICAgICAgICAgICAgPGRpdj48c3Ryb25nPkRhdGU6PC9zdHJvbmc+ICR7bmV3IERhdGUoZGF0YS5jdXN0b21XSUxMT1dDTUFEYXRlKS50b0xvY2FsZURhdGVTdHJpbmcoKX08L2Rpdj4KICAgICAgICAgICAgICAgICAgICAgICAgPGRpdj48c3Ryb25nPlByb3BlcnR5Ojwvc3Ryb25nPiAke2RhdGEuY3VzdG9tV0lMTE9XQ01BQWRkcmVzcyB8fCBkYXRhLmN1c3RvbVdJTExPV0NNQUFkZHJlc3MgfHwgJ04vQSd9PC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXY+PHN0cm9uZz5Fc3RpbWF0ZWQgVmFsdWU6PC9zdHJvbmc+ICR7ZGF0YS5jdXN0b21XSUxMT1dDZW50ZXJWYWx1ZSA/ICckJyArIHBhcnNlSW50KGRhdGEuY3VzdG9tV0lMTE9XQ2VudGVyVmFsdWUpLnRvTG9jYWxlU3RyaW5nKCkgOiAnTi9BJ308L2Rpdj4KICAgICAgICAgICAgICAgICAgICAgICAgJHtkYXRhLmN1c3RvbVdJTExPV0NNQUlEID8gYDxkaXY+PHN0cm9uZz5DTUEgSUQ6PC9zdHJvbmc+ICR7ZGF0YS5jdXN0b21XSUxMT1dDTUFJRH08L2Rpdj5gIDogJyd9CiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImJ0bi1ncm91cCIgc3R5bGU9Im1hcmdpbi10b3A6IDE1cHg7IGdhcDogOHB4OyI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAke2J1dHRvbnMuam9pbignJyl9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPSJidG4gYnRuLXNlY29uZGFyeSIgb25jbGljaz0icmVnZW5lcmF0ZUNNQSgpIj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDwn5SEIFJlZ2VuZXJhdGUKICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPgogICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgIGA7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gYAogICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImluZm8tY2FyZC10aXRsZSI+Tm8gQ01BIEdlbmVyYXRlZCBZZXQ8L2Rpdj4KICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJpbmZvLWNhcmQtY29udGVudCI+R2VuZXJhdGUgeW91ciBmaXJzdCBDTUEgYmVsb3cgdG8gZ2V0IHN0YXJ0ZWQuPC9kaXY+CiAgICAgICAgICAgICAgICBgOwogICAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICAvLyBHZW5lcmF0ZSBDTUEKICAgICAgICBhc3luYyBmdW5jdGlvbiBnZW5lcmF0ZUNNQSgpIHsKICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjbWFBZGRyZXNzJykudmFsdWUudHJpbSgpOwogICAgICAgICAgICAKICAgICAgICAgICAgaWYgKCFhZGRyZXNzKSB7CiAgICAgICAgICAgICAgICBzaG93RXJyb3IoJ1BsZWFzZSBlbnRlciBhIHByb3BlcnR5IGFkZHJlc3MnKTsKICAgICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgY29uc3QgcmVzdWx0RGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NtYVJlc3VsdCcpOwogICAgICAgICAgICByZXN1bHREaXYuaW5uZXJIVE1MID0gJzxkaXYgY2xhc3M9ImxvYWRpbmciPjxkaXYgY2xhc3M9InNwaW5uZXIiPjwvZGl2PkdlbmVyYXRpbmcgQ01BIGFuZCBjcmVhdGluZyBIb21lYmVhdC4uLjwvZGl2Pic7CgogICAgICAgICAgICBjb25zdCB0ZW1wbGF0ZVR5cGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY21hVGVtcGxhdGVUeXBlJykudmFsdWU7CiAgICAgICAgICAgIAogICAgICAgICAgICBjb25zdCBwYXJhbXMgPSB7CiAgICAgICAgICAgICAgICBhY3Rpb246ICdnZW5lcmF0ZUNNQScsCiAgICAgICAgICAgICAgICBwZXJzb25JZDogcGVyc29uSWQsCiAgICAgICAgICAgICAgICBhZGRyZXNzOiBhZGRyZXNzLAogICAgICAgICAgICAgICAgdGVtcGxhdGVUeXBlOiB0ZW1wbGF0ZVR5cGUsCiAgICAgICAgICAgICAgICBiZWRzOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY21hQmVkcycpLnZhbHVlLAogICAgICAgICAgICAgICAgYmF0aHM6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjbWFCYXRocycpLnZhbHVlLAogICAgICAgICAgICAgICAgc3FmdDogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NtYVNxZnQnKS52YWx1ZSwKICAgICAgICAgICAgICAgIHJhZGl1czogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NtYVJhZGl1cycpLnZhbHVlLAogICAgICAgICAgICAgICAgbW9udGhzQmFjazogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NtYU1vbnRoc0JhY2snKS52YWx1ZSwKICAgICAgICAgICAgICAgIG1pbkxpc3RpbmdzOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY21hTWluTGlzdGluZ3MnKS52YWx1ZSwKICAgICAgICAgICAgICAgIHByb3BUeXBlOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY21hUHJvcFR5cGUnKS52YWx1ZSwKICAgICAgICAgICAgICAgIHRpdGxlOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY21hVGl0bGUnKS52YWx1ZSwKICAgICAgICAgICAgICAgIGNyZWF0ZUhvbWViZWF0OiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY3JlYXRlSG9tZWJlYXQnKS5jaGVja2VkLAogICAgICAgICAgICAgICAgaG9tZWJlYXRGcmVxdWVuY3k6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdob21lYmVhdEZyZXF1ZW5jeScpLnZhbHVlCiAgICAgICAgICAgIH07CgogICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9Ly5uZXRsaWZ5L2Z1bmN0aW9ucy93aWxsb3ctY21hLXdvcmtiZW5jaGAsIHsKICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJywKICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSwKICAgICAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShwYXJhbXMpCiAgICAgICAgICAgICAgICB9KTsKCiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpOwoKICAgICAgICAgICAgICAgIGlmIChkYXRhLmVycm9yKSB7CiAgICAgICAgICAgICAgICAgICAgcmVzdWx0RGl2LmlubmVySFRNTCA9IGA8ZGl2IGNsYXNzPSJlcnJvciI+4p2MICR7ZGF0YS5lcnJvcn08L2Rpdj5gOwogICAgICAgICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICBjb25zdCB0ZW1wbGF0ZUljb25zID0gewogICAgICAgICAgICAgICAgICAgICdxdWljayc6ICfwn5qAJywKICAgICAgICAgICAgICAgICAgICAnd2Vic2l0ZSc6ICfwn4yQJywgCiAgICAgICAgICAgICAgICAgICAgJ2Z1bGwnOiAn8J+TiycKICAgICAgICAgICAgICAgIH07CiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgIGNvbnN0IHRlbXBsYXRlTWVzc2FnZXMgPSB7CiAgICAgICAgICAgICAgICAgICAgJ3F1aWNrJzogJ2F1dG9tYXRpY2FsbHkgZW1haWxlZCB0byBjbGllbnQgd2l0aGluIDEgbWludXRlJywKICAgICAgICAgICAgICAgICAgICAnd2Vic2l0ZSc6ICdsaXZlIGludGVyYWN0aXZlIHJlcG9ydCBnZW5lcmF0ZWQnLAogICAgICAgICAgICAgICAgICAgICdmdWxsJzogJ3JlYWR5IGZvciBhZ2VudCBjdXN0b21pemF0aW9uIGFuZCBkZWxpdmVyeScKICAgICAgICAgICAgICAgIH07CiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgIHJlc3VsdERpdi5pbm5lckhUTUwgPSBgCiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0ic3VjY2VzcyI+CiAgICAgICAgICAgICAgICAgICAgICAgIOKchSA8c3Ryb25nPiR7dGVtcGxhdGVJY29uc1tkYXRhLnRlbXBsYXRlVHlwZV0gfHwgJ/Cfk4snfSAke2RhdGEudGVtcGxhdGVMYWJlbH0gR2VuZXJhdGVkIFN1Y2Nlc3NmdWxseSE8L3N0cm9uZz48YnI+CiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9Im1hcmdpbjogMTBweCAwOyBwYWRkaW5nOiAxMHB4OyBiYWNrZ3JvdW5kOiAjZjBmZmY0OyBib3JkZXItbGVmdDogNHB4IHNvbGlkICM2OGQzOTE7IGJvcmRlci1yYWRpdXM6IDRweDsiPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cm9uZz5EZWxpdmVyeTo8L3N0cm9uZz4gJHt0ZW1wbGF0ZU1lc3NhZ2VzW2RhdGEudGVtcGxhdGVUeXBlXSB8fCAncmVhZHkgZm9yIG1hbnVhbCBjb21wbGV0aW9uJ308YnI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3Ryb25nPk1ldGhvZDo8L3N0cm9uZz4gJHtkYXRhLmRlbGl2ZXJ5TWV0aG9kfQogICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgICAgICAgICAgJHtkYXRhLmhvbWViZWF0Q3JlYXRlZCA/ICfinIUgSG9tZWJlYXQgc3Vic2NyaXB0aW9uIGNyZWF0ZWQ8YnI+JyA6ICcnfQogICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJidG4tZ3JvdXAiIHN0eWxlPSJtYXJnaW4tdG9wOiAxMHB4OyI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPSJidG4gYnRuLXNlY29uZGFyeSIgb25jbGljaz0id2luZG93Lm9wZW4oJyR7ZGF0YS5jbWFVcmx9JywgJ19ibGFuaycpIj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAke2RhdGEudGVtcGxhdGVUeXBlID09PSAncXVpY2snID8gJ/Cfk6cgQ2hlY2sgRW1haWwgRGVsaXZlcnknIDogZGF0YS50ZW1wbGF0ZVR5cGUgPT09ICd3ZWJzaXRlJyA/ICfwn4yQIFZpZXcgTGl2ZSBSZXBvcnQnIDogJ/Cfk4QgQ29tcGxldGUgQ01BJ30KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgJHtkYXRhLmhvbWViZWF0VXJsID8gYDxidXR0b24gY2xhc3M9ImJ0biBidG4tc2Vjb25kYXJ5IiBvbmNsaWNrPSJ3aW5kb3cub3BlbignJHtkYXRhLmhvbWViZWF0VXJsfScsICdfYmxhbmsnKSI+8J+PoCBWaWV3IEhvbWViZWF0PC9idXR0b24+YCA6ICcnfQogICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgIGA7CgogICAgICAgICAgICAgICAgLy8gUmVsb2FkIHBlcnNvbiBkYXRhIHRvIHNob3cgdXBkYXRlZCBDTUEKICAgICAgICAgICAgICAgIGF3YWl0IGxvYWRQZXJzb25EYXRhKCk7CiAgICAgICAgICAgICAgICBhd2FpdCBsb2FkSG9tZWJlYXREYXRhKCk7CgogICAgICAgICAgICB9IGNhdGNoIChlcnJvcikgewogICAgICAgICAgICAgICAgcmVzdWx0RGl2LmlubmVySFRNTCA9IGA8ZGl2IGNsYXNzPSJlcnJvciI+4p2MIEZhaWxlZCB0byBnZW5lcmF0ZSBDTUE6ICR7ZXJyb3IubWVzc2FnZX08L2Rpdj5gOwogICAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICAvLyBMb2FkIEhvbWViZWF0IGRhdGEKICAgICAgICBhc3luYyBmdW5jdGlvbiBsb2FkSG9tZWJlYXREYXRhKCkgewogICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9Ly5uZXRsaWZ5L2Z1bmN0aW9ucy93aWxsb3ctY21hLXdvcmtiZW5jaD9hY3Rpb249Z2V0SG9tZWJlYXREYXRhJnBlcnNvbklkPSR7cGVyc29uSWR9YCk7CiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpOwoKICAgICAgICAgICAgICAgIGlmIChkYXRhLmVycm9yKSB7CiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2hvbWViZWF0TGlzdCcpLmlubmVySFRNTCA9IGA8ZGl2IGNsYXNzPSJlcnJvciI+JHtkYXRhLmVycm9yfTwvZGl2PmA7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgIGhvbWViZWF0RGF0YSA9IGRhdGEuaG9tZWJlYXRzIHx8IFtdOwogICAgICAgICAgICAgICAgZGlzcGxheUhvbWViZWF0cyhob21lYmVhdERhdGEpOwogICAgICAgICAgICAgICAgdXBkYXRlRW5nYWdlbWVudFN1bW1hcnkoaG9tZWJlYXREYXRhKTsKCiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7CiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaG9tZWJlYXRMaXN0JykuaW5uZXJIVE1MID0gYDxkaXYgY2xhc3M9ImVycm9yIj5GYWlsZWQgdG8gbG9hZCBIb21lYmVhdCBkYXRhOiAke2Vycm9yLm1lc3NhZ2V9PC9kaXY+YDsKICAgICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgLy8gRGlzcGxheSBIb21lYmVhdHMKICAgICAgICBmdW5jdGlvbiBkaXNwbGF5SG9tZWJlYXRzKGhvbWViZWF0cykgewogICAgICAgICAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaG9tZWJlYXRMaXN0Jyk7CgogICAgICAgICAgICBpZiAoIWhvbWViZWF0cyB8fCBob21lYmVhdHMubGVuZ3RoID09PSAwKSB7CiAgICAgICAgICAgICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gJzxkaXYgY2xhc3M9ImluZm8tY2FyZCI+PGRpdiBjbGFzcz0iaW5mby1jYXJkLXRpdGxlIj5ObyBIb21lYmVhdHMgRm91bmQ8L2Rpdj48ZGl2IGNsYXNzPSJpbmZvLWNhcmQtY29udGVudCI+R2VuZXJhdGUgYSBDTUEgd2l0aCBIb21lYmVhdCBzdWJzY3JpcHRpb24gdG8gZ2V0IHN0YXJ0ZWQuPC9kaXY+PC9kaXY+JzsKICAgICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgY29udGFpbmVyLmlubmVySFRNTCA9IGhvbWViZWF0cy5tYXAoaGIgPT4gewogICAgICAgICAgICAgICAgY29uc3Qgdmlld3MgPSBoYi50b3RhbF92aWV3cyB8fCAwOwogICAgICAgICAgICAgICAgY29uc3QgZGF5c1NpbmNlRmlyc3RTZW5kID0gaGIuZmlyc3Rfc2VuZF9kYXRlID8gTWF0aC5mbG9vcigoRGF0ZS5ub3coKSAtIG5ldyBEYXRlKGhiLmZpcnN0X3NlbmRfZGF0ZSkuZ2V0VGltZSgpKSAvICgxMDAwICogNjAgKiA2MCAqIDI0KSkgOiAwOwogICAgICAgICAgICAgICAgY29uc3QgbmVlZHNSZXNlbmQgPSB2aWV3cyA9PT0gMCAmJiBkYXlzU2luY2VGaXJzdFNlbmQgPj0gNjA7CiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgIGxldCBlbmdhZ2VtZW50Q2xhc3MsIGVuZ2FnZW1lbnRCYWRnZTsKICAgICAgICAgICAgICAgIGlmICh2aWV3cyA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIGVuZ2FnZW1lbnRDbGFzcyA9ICdub3QtYWNjZXB0ZWQnOwogICAgICAgICAgICAgICAgICAgIGVuZ2FnZW1lbnRCYWRnZSA9ICc8c3BhbiBjbGFzcz0iZW5nYWdlbWVudC1iYWRnZSBiYWRnZS1ub3QtYWNjZXB0ZWQiPk5PVCBBQ0NFUFRFRDwvc3Bhbj4nOwogICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2aWV3cyA+PSAyMCkgewogICAgICAgICAgICAgICAgICAgIGVuZ2FnZW1lbnRDbGFzcyA9ICdoaWdoLWVuZ2FnZW1lbnQnOwogICAgICAgICAgICAgICAgICAgIGVuZ2FnZW1lbnRCYWRnZSA9ICc8c3BhbiBjbGFzcz0iZW5nYWdlbWVudC1iYWRnZSBiYWRnZS1jcml0aWNhbCI+8J+UpSBISUdIPC9zcGFuPic7CiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZpZXdzID49IDUpIHsKICAgICAgICAgICAgICAgICAgICBlbmdhZ2VtZW50Q2xhc3MgPSAnbWVkaXVtLWVuZ2FnZW1lbnQnOwogICAgICAgICAgICAgICAgICAgIGVuZ2FnZW1lbnRCYWRnZSA9ICc8c3BhbiBjbGFzcz0iZW5nYWdlbWVudC1iYWRnZSBiYWRnZS1oaWdoIj7imqDvuI8gTUVESVVNPC9zcGFuPic7CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgIGVuZ2FnZW1lbnRDbGFzcyA9ICdsb3ctZW5nYWdlbWVudCc7CiAgICAgICAgICAgICAgICAgICAgZW5nYWdlbWVudEJhZGdlID0gJzxzcGFuIGNsYXNzPSJlbmdhZ2VtZW50LWJhZGdlIGJhZGdlLW1lZGl1bSI+8J+TiiBMT1c8L3NwYW4+JzsKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICByZXR1cm4gYAogICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImhvbWViZWF0LWl0ZW0gJHtlbmdhZ2VtZW50Q2xhc3N9Ij4KICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iaG9tZWJlYXQtaGVhZGVyIj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImhvbWViZWF0LXRpdGxlIj7wn4+gICR7aGIucHJvcGVydHlfYWRkcmVzcyB8fCAnVW5rbm93biBBZGRyZXNzJ308L2Rpdj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICR7ZW5nYWdlbWVudEJhZGdlfQogICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgICAgICAgICAgJHtuZWVkc1Jlc2VuZCA/IGAKICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InJlc2VuZC13YXJuaW5nIj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBIb21lYmVhdCBub3QgYWNjZXB0ZWQgZm9yICR7ZGF5c1NpbmNlRmlyc3RTZW5kfSBkYXlzIC0gcmVzZW5kIHJlY29tbWVuZGVkCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgICAgICAgICAgYCA6ICcnfQogICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJob21lYmVhdC1zdGF0cyI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJzdGF0LWl0ZW0iPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSJzdGF0LWxhYmVsIj5Ub3RhbCBWaWV3czo8L3NwYW4+ICR7dmlld3N9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InN0YXQtaXRlbSI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9InN0YXQtbGFiZWwiPkxhc3QgVmlldzo8L3NwYW4+ICR7aGIubGFzdF92aWV3ID8gbmV3IERhdGUoaGIubGFzdF92aWV3KS50b0xvY2FsZURhdGVTdHJpbmcoKSA6ICdOZXZlcid9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InN0YXQtaXRlbSI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9InN0YXQtbGFiZWwiPkZyZXF1ZW5jeTo8L3NwYW4+ICR7aGIuZnJlcXVlbmN5IHx8ICdOL0EnfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJzdGF0LWl0ZW0iPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSJzdGF0LWxhYmVsIj5OZXh0IFJlcG9ydDo8L3NwYW4+ICR7aGIubmV4dF9yZXBvcnQgPyBuZXcgRGF0ZShoYi5uZXh0X3JlcG9ydCkudG9Mb2NhbGVEYXRlU3RyaW5nKCkgOiAnTi9BJ30KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICAgICAgJHtkYXlzU2luY2VGaXJzdFNlbmQgPiAwID8gYAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InN0YXQtaXRlbSI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSJzdGF0LWxhYmVsIj5EYXlzIFNpbmNlIEZpcnN0IFNlbmQ6PC9zcGFuPiAke2RheXNTaW5jZUZpcnN0U2VuZH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGAgOiAnJ30KICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImJ0bi1ncm91cCI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPSJidG4gYnRuLXNlY29uZGFyeSIgb25jbGljaz0id2luZG93Lm9wZW4oJyR7aGIuaG9tZWJlYXRfdXJsfScsICdfYmxhbmsnKSI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg8J+Rge+4jyBWaWV3IEhvbWViZWF0CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICR7dmlld3MgPT09IDAgfHwgbmVlZHNSZXNlbmQgPyBgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz0iYnRuIGJ0bi1wcmltYXJ5IiBvbmNsaWNrPSJyZXNlbmRIb21lYmVhdCgnJHtoYi5pZH0nKSI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIPCfk6cgUmVzZW5kIEhvbWViZWF0CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgIDogJyd9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPSJidG4gYnRuLXNlY29uZGFyeSIgb25jbGljaz0iZWRpdEhvbWViZWF0KCcke2hiLmlkfScpIj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDinI/vuI8gRWRpdAogICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPSJidG4gYnRuLWRhbmdlciIgb25jbGljaz0idW5zdWJzY3JpYmVIb21lYmVhdCgnJHtoYi5pZH0nKSI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg8J+aqyBVbnN1YnNjcmliZQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+CiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgYDsKICAgICAgICAgICAgfSkuam9pbignJyk7CiAgICAgICAgfQoKICAgICAgICAvLyBVcGRhdGUgZW5nYWdlbWVudCBzdW1tYXJ5CiAgICAgICAgZnVuY3Rpb24gdXBkYXRlRW5nYWdlbWVudFN1bW1hcnkoaG9tZWJlYXRzKSB7CiAgICAgICAgICAgIGxldCBoaWdoID0gMCwgbWVkaXVtID0gMCwgbG93ID0gMCwgbm90QWNjZXB0ZWQgPSAwOwoKICAgICAgICAgICAgaG9tZWJlYXRzLmZvckVhY2goaGIgPT4gewogICAgICAgICAgICAgICAgY29uc3Qgdmlld3MgPSBoYi50b3RhbF92aWV3cyB8fCAwOwogICAgICAgICAgICAgICAgaWYgKHZpZXdzID09PSAwKSBub3RBY2NlcHRlZCsrOwogICAgICAgICAgICAgICAgZWxzZSBpZiAodmlld3MgPj0gMjApIGhpZ2grKzsKICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZpZXdzID49IDUpIG1lZGl1bSsrOwogICAgICAgICAgICAgICAgZWxzZSBsb3crKzsKICAgICAgICAgICAgfSk7CgogICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaGlnaEVuZ2FnZW1lbnRDb3VudCcpLnRleHRDb250ZW50ID0gaGlnaDsKICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21lZGl1bUVuZ2FnZW1lbnRDb3VudCcpLnRleHRDb250ZW50ID0gbWVkaXVtOwogICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbG93RW5nYWdlbWVudENvdW50JykudGV4dENvbnRlbnQgPSBsb3c7CiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdub3RBY2NlcHRlZENvdW50JykudGV4dENvbnRlbnQgPSBub3RBY2NlcHRlZDsKICAgICAgICB9CgogICAgICAgIC8vIFJlZnJlc2ggSG9tZWJlYXQgYW5hbHl0aWNzCiAgICAgICAgYXN5bmMgZnVuY3Rpb24gcmVmcmVzaEhvbWViZWF0QW5hbHl0aWNzKCkgewogICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaG9tZWJlYXRMaXN0JykuaW5uZXJIVE1MID0gJzxkaXYgY2xhc3M9ImxvYWRpbmciPjxkaXYgY2xhc3M9InNwaW5uZXIiPjwvZGl2PlJlZnJlc2hpbmcgYW5hbHl0aWNzLi4uPC9kaXY+JzsKICAgICAgICAgICAgYXdhaXQgbG9hZEhvbWViZWF0RGF0YSgpOwogICAgICAgIH0KCiAgICAgICAgLy8gUmVzZW5kIEhvbWViZWF0CiAgICAgICAgYXN5bmMgZnVuY3Rpb24gcmVzZW5kSG9tZWJlYXQoaG9tZWJlYXRJZCkgewogICAgICAgICAgICBpZiAoIWNvbmZpcm0oJ1Jlc2VuZCB0aGlzIEhvbWViZWF0IHRvIHRoZSBsZWFkPycpKSByZXR1cm47CgogICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9Ly5uZXRsaWZ5L2Z1bmN0aW9ucy93aWxsb3ctY21hLXdvcmtiZW5jaGAsIHsKICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJywKICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSwKICAgICAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7CiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogJ3Jlc2VuZEhvbWViZWF0JywKICAgICAgICAgICAgICAgICAgICAgICAgaG9tZWJlYXRJZDogaG9tZWJlYXRJZCwKICAgICAgICAgICAgICAgICAgICAgICAgcGVyc29uSWQ6IHBlcnNvbklkCiAgICAgICAgICAgICAgICAgICAgfSkKICAgICAgICAgICAgICAgIH0pOwoKICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7CgogICAgICAgICAgICAgICAgaWYgKGRhdGEuZXJyb3IpIHsKICAgICAgICAgICAgICAgICAgICBhbGVydCgnRmFpbGVkIHRvIHJlc2VuZCBIb21lYmVhdDogJyArIGRhdGEuZXJyb3IpOwogICAgICAgICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICBhbGVydCgn4pyFIEhvbWViZWF0IHJlc2VudCBzdWNjZXNzZnVsbHkhJyk7CiAgICAgICAgICAgICAgICBhd2FpdCBsb2FkSG9tZWJlYXREYXRhKCk7CgogICAgICAgICAgICB9IGNhdGNoIChlcnJvcikgewogICAgICAgICAgICAgICAgYWxlcnQoJ0ZhaWxlZCB0byByZXNlbmQgSG9tZWJlYXQ6ICcgKyBlcnJvci5tZXNzYWdlKTsKICAgICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgLy8gR2VuZXJhdGUgdHJpZ2dlcmVkIGFjdGlvbnMKICAgICAgICBhc3luYyBmdW5jdGlvbiBnZW5lcmF0ZVRyaWdnZXJlZEFjdGlvbnMoKSB7CiAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0cmlnZ2VyZWRBY3Rpb25zJyk7CiAgICAgICAgICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSAnPGRpdiBjbGFzcz0ibG9hZGluZyI+PGRpdiBjbGFzcz0ic3Bpbm5lciI+PC9kaXY+QW5hbHl6aW5nIGVuZ2FnZW1lbnQgZGF0YS4uLjwvZGl2Pic7CgogICAgICAgICAgICBpZiAoIWhvbWViZWF0RGF0YSB8fCBob21lYmVhdERhdGEubGVuZ3RoID09PSAwKSB7CiAgICAgICAgICAgICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gJzxkaXYgY2xhc3M9ImluZm8tY2FyZCI+PGRpdiBjbGFzcz0iaW5mby1jYXJkLXRpdGxlIj5ObyBBY3Rpb25zIFRyaWdnZXJlZDwvZGl2PjxkaXYgY2xhc3M9ImluZm8tY2FyZC1jb250ZW50Ij5HZW5lcmF0ZSBIb21lYmVhdHMgYW5kIHRyYWNrIGVuZ2FnZW1lbnQgdG8gc2VlIHRyaWdnZXJlZCBhY3Rpb25zIGhlcmUuPC9kaXY+PC9kaXY+JzsKICAgICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgY29uc3QgYWN0aW9ucyA9IFtdOwoKICAgICAgICAgICAgaG9tZWJlYXREYXRhLmZvckVhY2goaGIgPT4gewogICAgICAgICAgICAgICAgY29uc3Qgdmlld3MgPSBoYi50b3RhbF92aWV3cyB8fCAwOwogICAgICAgICAgICAgICAgY29uc3QgZGF5c1NpbmNlRmlyc3RTZW5kID0gaGIuZmlyc3Rfc2VuZF9kYXRlID8gTWF0aC5mbG9vcigoRGF0ZS5ub3coKSAtIG5ldyBEYXRlKGhiLmZpcnN0X3NlbmRfZGF0ZSkuZ2V0VGltZSgpKSAvICgxMDAwICogNjAgKiA2MCAqIDI0KSkgOiAwOwoKICAgICAgICAgICAgICAgIGlmICh2aWV3cyA+PSAyMCkgewogICAgICAgICAgICAgICAgICAgIGFjdGlvbnMucHVzaCh7CiAgICAgICAgICAgICAgICAgICAgICAgIHByaW9yaXR5OiAnY3JpdGljYWwnLAogICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogaGIucHJvcGVydHlfYWRkcmVzcywKICAgICAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcjogYEhvbWViZWF0IHZpZXdzICgke3ZpZXdzfSkgZXhjZWVkIGNyaXRpY2FsIHRocmVzaG9sZGAsCiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogJ1NjaGVkdWxlIGxpc3RpbmcgcHJlc2VudGF0aW9uJywKICAgICAgICAgICAgICAgICAgICAgICAgdXJnZW5jeTogJ0lNTUVESUFURScsCiAgICAgICAgICAgICAgICAgICAgICAgIHNjcmlwdDogIkkgbm90aWNlZCB5b3UndmUgYmVlbiBtb25pdG9yaW5nIHlvdXIgaG9tZSB2YWx1ZSBjbG9zZWx5IHdpdGggdGhlIEhvbWViZWF0IHJlcG9ydHMuIFdpdGggIiArIHZpZXdzICsgIiB2aWV3cywgaXQncyBjbGVhciB5b3UncmUgc2VyaW91cyBhYm91dCB1bmRlcnN0YW5kaW5nIHlvdXIgcHJvcGVydHkncyB3b3J0aC4gVGhlIG1hcmtldCBpcyBtb3ZpbmcgZmFzdCByaWdodCBub3cgLSBsZXQncyBkaXNjdXNzIHdoYXQgdGhpcyBtZWFucyBmb3IgeW91IGFuZCB5b3VyIHRpbWVsaW5lLiIKICAgICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodmlld3MgPj0gMTApIHsKICAgICAgICAgICAgICAgICAgICBhY3Rpb25zLnB1c2goewogICAgICAgICAgICAgICAgICAgICAgICBwcmlvcml0eTogJ2hvdCcsCiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBoYi5wcm9wZXJ0eV9hZGRyZXNzLAogICAgICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyOiBgSG9tZWJlYXQgdmlld3MgKCR7dmlld3N9KSBzaG93IHN0cm9uZyBlbmdhZ2VtZW50YCwKICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiAnQ2FsbCB0byBkaXNjdXNzIG1hcmtldCBjaGFuZ2VzJywKICAgICAgICAgICAgICAgICAgICAgICAgdXJnZW5jeTogJ1NBTUVfREFZJywKICAgICAgICAgICAgICAgICAgICAgICAgc2NyaXB0OiAiSSBzZWUgeW91J3ZlIGJlZW4ga2VlcGluZyBhbiBleWUgb24gdGhlIG1hcmtldCB0aHJvdWdoIHlvdXIgSG9tZWJlYXQgcmVwb3J0cy4gQW55IHF1ZXN0aW9ucyBhYm91dCB0aGUgcmVjZW50IGNoYW5nZXMgb3IgY29tcGFyYWJsZSBzYWxlcyBpbiB5b3VyIGFyZWE/IgogICAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2aWV3cyA+PSA1KSB7CiAgICAgICAgICAgICAgICAgICAgYWN0aW9ucy5wdXNoKHsKICAgICAgICAgICAgICAgICAgICAgICAgcHJpb3JpdHk6ICd3YXJtJywKICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IGhiLnByb3BlcnR5X2FkZHJlc3MsCiAgICAgICAgICAgICAgICAgICAgICAgIHRyaWdnZXI6IGBIb21lYmVhdCB2aWV3cyAoJHt2aWV3c30pIHNob3cgbW9kZXJhdGUgaW50ZXJlc3RgLAogICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246ICdFbWFpbCBjaGVjay1pbiBhYm91dCBwcm9wZXJ0eSB2YWx1ZScsCiAgICAgICAgICAgICAgICAgICAgICAgIHVyZ2VuY3k6ICdXRUVLTFknLAogICAgICAgICAgICAgICAgICAgICAgICBzY3JpcHQ6ICJKdXN0IHdhbnRlZCB0byBjaGVjayBpbiBhYm91dCB5b3VyIEhvbWViZWF0IHJlcG9ydHMuIEFyZSB5b3UgZmluZGluZyB0aGUgbWFya2V0IHVwZGF0ZXMgaGVscGZ1bD8gTGV0IG1lIGtub3cgaWYgeW91J2QgbGlrZSB0byBkaXNjdXNzIGFueSBzcGVjaWZpYyB0cmVuZHMuIgogICAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2aWV3cyA9PT0gMCAmJiBkYXlzU2luY2VGaXJzdFNlbmQgPj0gNjApIHsKICAgICAgICAgICAgICAgICAgICBhY3Rpb25zLnB1c2goewogICAgICAgICAgICAgICAgICAgICAgICBwcmlvcml0eTogJ3dhcm0nLAogICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogaGIucHJvcGVydHlfYWRkcmVzcywKICAgICAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcjogYEhvbWViZWF0IG5vdCBvcGVuZWQgZm9yICR7ZGF5c1NpbmNlRmlyc3RTZW5kfSBkYXlzYCwKICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiAnUmUtZW5nYWdlIHdpdGggdXBkYXRlZCBIb21lYmVhdCcsCiAgICAgICAgICAgICAgICAgICAgICAgIHVyZ2VuY3k6ICdXRUVLTFknLAogICAgICAgICAgICAgICAgICAgICAgICBzY3JpcHQ6ICJJIHdhbnRlZCB0byBtYWtlIHN1cmUgeW91J3JlIHN0aWxsIHJlY2VpdmluZyB5b3VyIEhvbWViZWF0IG1hcmtldCB1cGRhdGVzLiBXb3VsZCB5b3UgbGlrZSBtZSB0byByZXNlbmQgdGhlIGxhdGVzdCByZXBvcnQgb3IgYWRqdXN0IHRoZSBmcmVxdWVuY3k/IgogICAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9KTsKCiAgICAgICAgICAgIGlmIChhY3Rpb25zLmxlbmd0aCA9PT0gMCkgewogICAgICAgICAgICAgICAgY29udGFpbmVyLmlubmVySFRNTCA9ICc8ZGl2IGNsYXNzPSJpbmZvLWNhcmQiPjxkaXYgY2xhc3M9ImluZm8tY2FyZC10aXRsZSI+Tm8gQWN0aW9ucyBUcmlnZ2VyZWQ8L2Rpdj48ZGl2IGNsYXNzPSJpbmZvLWNhcmQtY29udGVudCI+Q29udGludWUgbW9uaXRvcmluZyBIb21lYmVhdCBlbmdhZ2VtZW50LiBBY3Rpb25zIHdpbGwgYXBwZWFyIGhlcmUgd2hlbiBlbmdhZ2VtZW50IHRocmVzaG9sZHMgYXJlIG1ldC48L2Rpdj48L2Rpdj4nOwogICAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICB9CgogICAgICAgICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gYWN0aW9ucy5tYXAoYWN0aW9uID0+IGAKICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImFjdGlvbi1jYXJkICR7YWN0aW9uLnByaW9yaXR5fSI+CiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iYWN0aW9uLWhlYWRlciI+CiAgICAgICAgICAgICAgICAgICAgICAgICR7YWN0aW9uLnByaW9yaXR5ID09PSAnY3JpdGljYWwnID8gJ/CflKUgQ1JJVElDQUwgQUNUSU9OIFJFQ09NTUVOREVEJyA6IGFjdGlvbi5wcmlvcml0eSA9PT0gJ2hvdCcgPyAn4pqg77iPIEhPVCBBQ1RJT04gU1VHR0VTVEVEJyA6ICfwn5OKIFdBUk0gQUNUSU9OIFNVR0dFU1RFRCd9CiAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iYWN0aW9uLWNvbnRlbnQiPgogICAgICAgICAgICAgICAgICAgICAgICA8ZGl2PjxzdHJvbmc+UHJvcGVydHk6PC9zdHJvbmc+ICR7YWN0aW9uLnByb3BlcnR5fTwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICA8ZGl2PjxzdHJvbmc+VHJpZ2dlcjo8L3N0cm9uZz4gJHthY3Rpb24udHJpZ2dlcn08L2Rpdj4KICAgICAgICAgICAgICAgICAgICAgICAgPGRpdj48c3Ryb25nPlN1Z2dlc3RlZCBBY3Rpb246PC9zdHJvbmc+ICR7YWN0aW9uLmFjdGlvbn08L2Rpdj4KICAgICAgICAgICAgICAgICAgICAgICAgPGRpdj48c3Ryb25nPlVyZ2VuY3k6PC9zdHJvbmc+ICR7YWN0aW9uLnVyZ2VuY3l9PC9kaXY+CiAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0ic2NyaXB0LWJveCI+CiAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJvbmc+U3VnZ2VzdGVkIFNjcmlwdDo8L3N0cm9uZz48YnI+CiAgICAgICAgICAgICAgICAgICAgICAgICIke2FjdGlvbi5zY3JpcHR9IgogICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImZvcm0tZ3JvdXAiPgogICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9ImZvcm0tbGFiZWwiPkFzc2lnbiBQYXJ0bmVyPC9sYWJlbD4KICAgICAgICAgICAgICAgICAgICAgICAgPHNlbGVjdCBjbGFzcz0iZm9ybS1zZWxlY3QiIGlkPSJwYXJ0bmVyLSR7YWN0aW9uLnByb3BlcnR5fSI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPSJHbGVubiI+R2xlbm48L29wdGlvbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9Ikp1c3RpbiI+SnVzdGluPC9vcHRpb24+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPSJIZWF0aGVyIj5IZWF0aGVyPC9vcHRpb24+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPSJMbG95ZCI+TGxveWQ8L29wdGlvbj4KICAgICAgICAgICAgICAgICAgICAgICAgPC9zZWxlY3Q+CiAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iYnRuLWdyb3VwIj4KICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz0iYnRuIGJ0bi1wcmltYXJ5IiBvbmNsaWNrPSJjcmVhdGVUYXNrKCcke2FjdGlvbi5wcm9wZXJ0eX0nLCAnJHthY3Rpb24uYWN0aW9ufScsICcke2FjdGlvbi51cmdlbmN5fScpIj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKchSBDcmVhdGUgVGFzayBpbiBGVUIKICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+CiAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9ImJ0biBidG4tc2Vjb25kYXJ5IiBvbmNsaWNrPSJjcmVhdGVDYWxsKCcke2FjdGlvbi5wcm9wZXJ0eX0nKSI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICDwn5OeIExvZyBDYWxsCiAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPgogICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPSJidG4gYnRuLXNlY29uZGFyeSIgb25jbGljaz0iY3JlYXRlRW1haWwoJyR7YWN0aW9uLnByb3BlcnR5fScsICcke2FjdGlvbi5zY3JpcHR9JykiPgogICAgICAgICAgICAgICAgICAgICAgICAgICAg8J+TpyBTZW5kIEVtYWlsCiAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPgogICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgIGApLmpvaW4oJycpOwogICAgICAgIH0KCiAgICAgICAgLy8gQ3JlYXRlIHRhc2sgaW4gRlVCCiAgICAgICAgYXN5bmMgZnVuY3Rpb24gY3JlYXRlVGFzayhwcm9wZXJ0eSwgYWN0aW9uLCB1cmdlbmN5KSB7CiAgICAgICAgICAgIGNvbnN0IHBhcnRuZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChgcGFydG5lci0ke3Byb3BlcnR5fWApPy52YWx1ZSB8fCAnR2xlbm4nOwogICAgICAgICAgICAKICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS8ubmV0bGlmeS9mdW5jdGlvbnMvd2lsbG93LWNtYS13b3JrYmVuY2hgLCB7CiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsCiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sCiAgICAgICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoewogICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246ICdjcmVhdGVUYXNrJywKICAgICAgICAgICAgICAgICAgICAgICAgcGVyc29uSWQ6IHBlcnNvbklkLAogICAgICAgICAgICAgICAgICAgICAgICB0YXNrRGVzY3JpcHRpb246IGAke2FjdGlvbn0gLSBQcm9wZXJ0eTogJHtwcm9wZXJ0eX1gLAogICAgICAgICAgICAgICAgICAgICAgICB1cmdlbmN5OiB1cmdlbmN5LAogICAgICAgICAgICAgICAgICAgICAgICBhc3NpZ25lZFRvOiBwYXJ0bmVyCiAgICAgICAgICAgICAgICAgICAgfSkKICAgICAgICAgICAgICAgIH0pOwoKICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7CgogICAgICAgICAgICAgICAgaWYgKGRhdGEuZXJyb3IpIHsKICAgICAgICAgICAgICAgICAgICBhbGVydCgnRmFpbGVkIHRvIGNyZWF0ZSB0YXNrOiAnICsgZGF0YS5lcnJvcik7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgIGFsZXJ0KGDinIUgVGFzayBjcmVhdGVkIGFuZCBhc3NpZ25lZCB0byAke3BhcnRuZXJ9IWApOwoKICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHsKICAgICAgICAgICAgICAgIGFsZXJ0KCdGYWlsZWQgdG8gY3JlYXRlIHRhc2s6ICcgKyBlcnJvci5tZXNzYWdlKTsKICAgICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgLy8gQ3JlYXRlIG1hbnVhbCBhY3Rpb24KICAgICAgICBhc3luYyBmdW5jdGlvbiBjcmVhdGVNYW51YWxBY3Rpb24oKSB7CiAgICAgICAgICAgIGNvbnN0IGFjdGlvblR5cGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYWN0aW9uVHlwZScpLnZhbHVlOwogICAgICAgICAgICBjb25zdCBhc3NpZ25UbyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhc3NpZ25UbycpLnZhbHVlOwogICAgICAgICAgICBjb25zdCB1cmdlbmN5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3VyZ2VuY3knKS52YWx1ZTsKICAgICAgICAgICAgY29uc3Qgbm90ZXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYWN0aW9uTm90ZXMnKS52YWx1ZS50cmltKCk7CgogICAgICAgICAgICBpZiAoIW5vdGVzKSB7CiAgICAgICAgICAgICAgICBhbGVydCgnUGxlYXNlIGVudGVyIGFjdGlvbiBub3RlcycpOwogICAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICB9CgogICAgICAgICAgICBjb25zdCByZXN1bHREaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWFudWFsQWN0aW9uUmVzdWx0Jyk7CiAgICAgICAgICAgIHJlc3VsdERpdi5pbm5lckhUTUwgPSAnPGRpdiBjbGFzcz0ibG9hZGluZyI+PGRpdiBjbGFzcz0ic3Bpbm5lciI+PC9kaXY+Q3JlYXRpbmcgYWN0aW9uLi4uPC9kaXY+JzsKCiAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vLm5ldGxpZnkvZnVuY3Rpb25zL3dpbGxvdy1jbWEtd29ya2JlbmNoYCwgewogICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLAogICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LAogICAgICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsKICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiAnY3JlYXRlTWFudWFsQWN0aW9uJywKICAgICAgICAgICAgICAgICAgICAgICAgcGVyc29uSWQ6IHBlcnNvbklkLAogICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25UeXBlOiBhY3Rpb25UeXBlLAogICAgICAgICAgICAgICAgICAgICAgICBhc3NpZ25lZFRvOiBhc3NpZ25UbywKICAgICAgICAgICAgICAgICAgICAgICAgdXJnZW5jeTogdXJnZW5jeSwKICAgICAgICAgICAgICAgICAgICAgICAgbm90ZXM6IG5vdGVzCiAgICAgICAgICAgICAgICAgICAgfSkKICAgICAgICAgICAgICAgIH0pOwoKICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7CgogICAgICAgICAgICAgICAgaWYgKGRhdGEuZXJyb3IpIHsKICAgICAgICAgICAgICAgICAgICByZXN1bHREaXYuaW5uZXJIVE1MID0gYDxkaXYgY2xhc3M9ImVycm9yIj7inYwgJHtkYXRhLmVycm9yfTwvZGl2PmA7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgIHJlc3VsdERpdi5pbm5lckhUTUwgPSBgPGRpdiBjbGFzcz0ic3VjY2VzcyI+4pyFICR7YWN0aW9uVHlwZX0gY3JlYXRlZCBzdWNjZXNzZnVsbHkgYW5kIGFzc2lnbmVkIHRvICR7YXNzaWduVG99ITwvZGl2PmA7CiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYWN0aW9uTm90ZXMnKS52YWx1ZSA9ICcnOwoKICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHsKICAgICAgICAgICAgICAgIHJlc3VsdERpdi5pbm5lckhUTUwgPSBgPGRpdiBjbGFzcz0iZXJyb3IiPuKdjCBGYWlsZWQgdG8gY3JlYXRlIGFjdGlvbjogJHtlcnJvci5tZXNzYWdlfTwvZGl2PmA7CiAgICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIC8vIEhlbHBlciBmdW5jdGlvbnMKICAgICAgICBmdW5jdGlvbiBzaG93RXJyb3IobWVzc2FnZSkgewogICAgICAgICAgICBhbGVydCgnRXJyb3I6ICcgKyBtZXNzYWdlKTsKICAgICAgICB9CgogICAgICAgIC8vIEVkaXQgSG9tZWJlYXQgKHBsYWNlaG9sZGVyKQogICAgICAgIGZ1bmN0aW9uIGVkaXRIb21lYmVhdChob21lYmVhdElkKSB7CiAgICAgICAgICAgIGFsZXJ0KCdFZGl0IEhvbWViZWF0IGZ1bmN0aW9uYWxpdHkgY29taW5nIHNvb24uIEhvbWViZWF0IElEOiAnICsgaG9tZWJlYXRJZCk7CiAgICAgICAgfQoKICAgICAgICAvLyBVbnN1YnNjcmliZSBIb21lYmVhdCAocGxhY2Vob2xkZXIpCiAgICAgICAgYXN5bmMgZnVuY3Rpb24gdW5zdWJzY3JpYmVIb21lYmVhdChob21lYmVhdElkKSB7CiAgICAgICAgICAgIGlmICghY29uZmlybSgnQXJlIHlvdSBzdXJlIHlvdSB3YW50IHRvIHVuc3Vic2NyaWJlIHRoaXMgSG9tZWJlYXQ/JykpIHJldHVybjsKICAgICAgICAgICAgYWxlcnQoJ1Vuc3Vic2NyaWJlIGZ1bmN0aW9uYWxpdHkgY29taW5nIHNvb24uIEhvbWViZWF0IElEOiAnICsgaG9tZWJlYXRJZCk7CiAgICAgICAgfQoKICAgICAgICAvLyBDcmVhdGUgY2FsbCAocGxhY2Vob2xkZXIpCiAgICAgICAgZnVuY3Rpb24gY3JlYXRlQ2FsbChwcm9wZXJ0eSkgewogICAgICAgICAgICBhbGVydCgnQ2FsbCBsb2dnaW5nIGZ1bmN0aW9uYWxpdHkgY29taW5nIHNvb24gZm9yIHByb3BlcnR5OiAnICsgcHJvcGVydHkpOwogICAgICAgIH0KCiAgICAgICAgLy8gQ3JlYXRlIGVtYWlsIChwbGFjZWhvbGRlcikKICAgICAgICBmdW5jdGlvbiBjcmVhdGVFbWFpbChwcm9wZXJ0eSwgc2NyaXB0KSB7CiAgICAgICAgICAgIGFsZXJ0KCdFbWFpbCBjcmVhdGlvbiBmdW5jdGlvbmFsaXR5IGNvbWluZyBzb29uIGZvciBwcm9wZXJ0eTogJyArIHByb3BlcnR5KTsKICAgICAgICB9CgogICAgICAgIC8vIFJlZ2VuZXJhdGUgQ01BIChwbGFjZWhvbGRlcikKICAgICAgICBmdW5jdGlvbiByZWdlbmVyYXRlQ01BKCkgewogICAgICAgICAgICBhbGVydCgnUmVnZW5lcmF0ZSBDTUEgZnVuY3Rpb25hbGl0eSBjb21pbmcgc29vbi4nKTsKICAgICAgICB9CgogICAgICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KICAgICAgICAvLyBBVFRPTSBEQVRBIElOVEVHUkFUSU9OCiAgICAgICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQoKICAgICAgICAvKioKICAgICAgICAgKiBBdXRvLWZpbGwgcHJvcGVydHkgZGF0YSBmcm9tIEFUVE9NIEFQSQogICAgICAgICAqLwogICAgICAgIGFzeW5jIGZ1bmN0aW9uIGF1dG9GaWxsUHJvcGVydHlEYXRhKCkgewogICAgICAgICAgY29uc3QgYWRkcmVzc0lucHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NtYUFkZHJlc3MnKTsKICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSBhZGRyZXNzSW5wdXQ/LnZhbHVlPy50cmltKCk7CgogICAgICAgICAgaWYgKCFhZGRyZXNzKSB7CiAgICAgICAgICAgIHNob3dBdHRvbU5vdGlmaWNhdGlvbignUGxlYXNlIGVudGVyIGEgcHJvcGVydHkgYWRkcmVzcyBmaXJzdCcsICd3YXJuaW5nJyk7CiAgICAgICAgICAgIGFkZHJlc3NJbnB1dD8uZm9jdXMoKTsKICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgfQoKICAgICAgICAgIC8vIFNob3cgbG9hZGluZyBzdGF0ZQogICAgICAgICAgc2V0QXR0b21Mb2FkaW5nU3RhdGUodHJ1ZSk7CiAgICAgICAgICBzaG93QXR0b21Ob3RpZmljYXRpb24oJ0xvb2tpbmcgdXAgcHJvcGVydHkgZGV0YWlscyBmcm9tIEFUVE9NIERhdGEuLi4nLCAnaW5mbycpOwoKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgIC8vIEdldCBwZXJzb24gSUQgKGFscmVhZHkgYXZhaWxhYmxlIGZyb20gcGFnZSBjb250ZXh0KQogICAgICAgICAgICBjb25zdCBjb250ZXh0UGVyc29uSWQgPSBwZXJzb25JZDsKCiAgICAgICAgICAgIC8vIENhbGwgQVRUT00gbG9va3VwIGZ1bmN0aW9uCiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoewogICAgICAgICAgICAgIGFkZHJlc3M6IGFkZHJlc3MsCiAgICAgICAgICAgICAgLi4uKGNvbnRleHRQZXJzb25JZCAmJiB7IHBlcnNvbklkOiBjb250ZXh0UGVyc29uSWQgfSkKICAgICAgICAgICAgfSk7CgogICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vLm5ldGxpZnkvZnVuY3Rpb25zL2F0dG9tLXByb3BlcnR5LWxvb2t1cD8ke3BhcmFtc31gKTsKICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpOwoKICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykgewogICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZXN1bHQubWVzc2FnZSB8fCAnUHJvcGVydHkgbG9va3VwIGZhaWxlZCcpOwogICAgICAgICAgICB9CgogICAgICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MgJiYgcmVzdWx0LmRhdGEpIHsKICAgICAgICAgICAgICAvLyBGaWxsIGZvcm0gZmllbGRzIHdpdGggQVRUT00gZGF0YQogICAgICAgICAgICAgIGZpbGxQcm9wZXJ0eUZpZWxkc0Zyb21BdHRvbShyZXN1bHQuZGF0YSwgcmVzdWx0LnNvdXJjZSk7CiAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgLy8gU2hvdyBzdWNjZXNzIG1lc3NhZ2UKICAgICAgICAgICAgICBjb25zdCBzb3VyY2VMYWJlbCA9IHJlc3VsdC5jYWNoZWQgPyAnY2FjaGVkIGRhdGEnIDogJ0FUVE9NIERhdGEgQVBJJzsKICAgICAgICAgICAgICBzaG93QXR0b21Ob3RpZmljYXRpb24oYOKckyBQcm9wZXJ0eSBkYXRhIGxvYWRlZCBmcm9tICR7c291cmNlTGFiZWx9YCwgJ3N1Y2Nlc3MnKTsKICAgICAgICAgICAgICAKICAgICAgICAgICAgICAvLyBTdG9yZSBmb3IgcmVmZXJlbmNlCiAgICAgICAgICAgICAgQXR0b21TdGF0ZS5sYXN0TG9va3VwID0gewogICAgICAgICAgICAgICAgZGF0YTogcmVzdWx0LmRhdGEsCiAgICAgICAgICAgICAgICBzb3VyY2U6IHJlc3VsdC5zb3VyY2UsCiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSwKICAgICAgICAgICAgICAgIGFkZHJlc3M6IGFkZHJlc3MKICAgICAgICAgICAgICB9OwogICAgICAgICAgICB9CgogICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHsKICAgICAgICAgICAgY29uc29sZS5lcnJvcignQVRUT00gbG9va3VwIGVycm9yOicsIGVycm9yKTsKICAgICAgICAgICAgc2hvd0F0dG9tTm90aWZpY2F0aW9uKGBQcm9wZXJ0eSBsb29rdXAgZmFpbGVkOiAke2Vycm9yLm1lc3NhZ2V9LiBUcnkgbWFudWFsIGVudHJ5LmAsICdlcnJvcicpOwogICAgICAgICAgICAKICAgICAgICAgICAgLy8gRmFsbCBiYWNrIHRvIHNtYXJ0IGRlZmF1bHRzCiAgICAgICAgICAgIGlmIChjb25maXJtKCdQcm9wZXJ0eSBub3QgZm91bmQgaW4gQVRUT00gZGF0YWJhc2UuIFdvdWxkIHlvdSBsaWtlIHRvIHVzZSBIdWRzb24gVmFsbGV5IG1hcmtldCBkZWZhdWx0cz8nKSkgewogICAgICAgICAgICAgIGZpbGxQcm9wZXJ0eUZpZWxkc0Zyb21BdHRvbShnZXRIdWRzb25WYWxsZXlEZWZhdWx0cygpLCAnTUFOVUFMX0RFRkFVTFRTJyk7CiAgICAgICAgICAgICAgc2hvd0F0dG9tTm90aWZpY2F0aW9uKCdVc2luZyBIdWRzb24gVmFsbGV5IG1hcmtldCBkZWZhdWx0cycsICd3YXJuaW5nJyk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICAgIHNldEF0dG9tTG9hZGluZ1N0YXRlKGZhbHNlKTsKICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIC8qKgogICAgICAgICAqIEZpbGwgZm9ybSBmaWVsZHMgd2l0aCBwcm9wZXJ0eSBkYXRhIGZyb20gQVRUT00KICAgICAgICAgKi8KICAgICAgICBmdW5jdGlvbiBmaWxsUHJvcGVydHlGaWVsZHNGcm9tQXR0b20oZGF0YSwgc291cmNlKSB7CiAgICAgICAgICAvLyBNYXAgQVRUT00gZGF0YSB0byBleGlzdGluZyBmb3JtIGZpZWxkIElEcwogICAgICAgICAgY29uc3QgZmllbGRNYXBwaW5ncyA9IHsKICAgICAgICAgICAgJ2NtYUJlZHMnOiBkYXRhLmJlZHMsCiAgICAgICAgICAgICdjbWFCYXRocyc6IGRhdGEuYmF0aHMsCiAgICAgICAgICAgICdjbWFTcWZ0JzogZGF0YS5zcWZ0LAogICAgICAgICAgICAvLyBOb3RlOiBObyBhY3JlcyBvciBnYXJhZ2UgZmllbGRzIGluIGN1cnJlbnQgZm9ybQogICAgICAgICAgICAvLyBOb3RlOiBObyBsb3RTaXplLCBwcm9wZXJ0eVR5cGUsIHllYXJCdWlsdCwgY29uZGl0aW9uIGZpZWxkcyBpbiBjdXJyZW50IGZvcm0KICAgICAgICAgIH07CgogICAgICAgICAgLy8gRmlsbCBhdmFpbGFibGUgZmllbGRzCiAgICAgICAgICBPYmplY3QuZW50cmllcyhmaWVsZE1hcHBpbmdzKS5mb3JFYWNoKChbZmllbGRJZCwgdmFsdWVdKSA9PiB7CiAgICAgICAgICAgIHNldEF0dG9tRmllbGRWYWx1ZShmaWVsZElkLCB2YWx1ZSk7CiAgICAgICAgICB9KTsKCiAgICAgICAgICAvLyBBZGQgZGF0YSBzb3VyY2UgaW5kaWNhdG9yIHRvIGZvcm0KICAgICAgICAgIGFkZEF0dG9tRGF0YVNvdXJjZUluZGljYXRvcihzb3VyY2UpOwogICAgICAgICAgCiAgICAgICAgICAvLyBMb2cgdGhlIGZ1bGwgZGF0YSByZWNlaXZlZCBmb3IgZGVidWdnaW5nCiAgICAgICAgICBjb25zb2xlLmxvZygnQVRUT00gRGF0YSBSZWNlaXZlZDonLCBkYXRhKTsKICAgICAgICAgIGNvbnNvbGUubG9nKCdGaWVsZHMgbm90IG1hcHBlZCAobm8gZm9ybSBmaWVsZCBleGlzdHMpOicsIHsKICAgICAgICAgICAgYWNyZXM6IGRhdGEuYWNyZXMsCiAgICAgICAgICAgIGdhcmFnZTogZGF0YS5nYXJhZ2UsCiAgICAgICAgICAgIHByb3BlcnR5VHlwZTogZGF0YS5wcm9wZXJ0eVR5cGUsCiAgICAgICAgICAgIHllYXJCdWlsdDogZGF0YS55ZWFyQnVpbHQsCiAgICAgICAgICAgIGNvbmRpdGlvbjogZGF0YS5jb25kaXRpb24KICAgICAgICAgIH0pOwogICAgICAgIH0KCiAgICAgICAgLyoqCiAgICAgICAgICogU2V0IGZpZWxkIHZhbHVlIHdpdGggdmFsaWRhdGlvbgogICAgICAgICAqLwogICAgICAgIGZ1bmN0aW9uIHNldEF0dG9tRmllbGRWYWx1ZShmaWVsZElkLCB2YWx1ZSkgewogICAgICAgICAgY29uc3QgZmllbGQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChmaWVsZElkKTsKICAgICAgICAgIGlmIChmaWVsZCAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICAgIGZpZWxkLnZhbHVlID0gdmFsdWU7CiAgICAgICAgICAgIGZpZWxkLnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICcjZjBmZGY0JzsgLy8gTGlnaHQgZ3JlZW4gYmFja2dyb3VuZAogICAgICAgICAgICBmaWVsZC5zdHlsZS5ib3JkZXJDb2xvciA9ICcjMTBiOTgxJzsgLy8gR3JlZW4gYm9yZGVyCiAgICAgICAgICAgIAogICAgICAgICAgICAvLyBUcmlnZ2VyIGNoYW5nZSBldmVudCBmb3IgYW55IGxpc3RlbmVycwogICAgICAgICAgICBmaWVsZC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnY2hhbmdlJywgeyBidWJibGVzOiB0cnVlIH0pKTsKICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIC8qKgogICAgICAgICAqIEFkZCB2aXN1YWwgaW5kaWNhdG9yIHNob3dpbmcgQVRUT00gZGF0YSB3YXMgdXNlZAogICAgICAgICAqLwogICAgICAgIGZ1bmN0aW9uIGFkZEF0dG9tRGF0YVNvdXJjZUluZGljYXRvcihzb3VyY2UpIHsKICAgICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhdXRvT3B0aW1pemVkUGFyYW1zJyk7CiAgICAgICAgICAKICAgICAgICAgIC8vIFJlbW92ZSBleGlzdGluZyBpbmRpY2F0b3IKICAgICAgICAgIGNvbnN0IGV4aXN0aW5nSW5kaWNhdG9yID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2F0dG9tU291cmNlSW5kaWNhdG9yJyk7CiAgICAgICAgICBpZiAoZXhpc3RpbmdJbmRpY2F0b3IpIGV4aXN0aW5nSW5kaWNhdG9yLnJlbW92ZSgpOwoKICAgICAgICAgIGNvbnN0IHNvdXJjZUxhYmVscyA9IHsKICAgICAgICAgICAgJ0FUVE9NX0FQSSc6ICfinJMgRGF0YSBmcm9tIEFUVE9NIFByb3BlcnR5IERhdGFiYXNlJywKICAgICAgICAgICAgJ0ZVQl9DQUNIRSc6ICfinJMgRGF0YSBmcm9tIEZvbGxvdyBVcCBCb3NzIENhY2hlJywKICAgICAgICAgICAgJ01BTlVBTF9ERUZBVUxUUyc6ICfimqAgVXNpbmcgSHVkc29uIFZhbGxleSBNYXJrZXQgRGVmYXVsdHMnCiAgICAgICAgICB9OwoKICAgICAgICAgIGNvbnN0IHNvdXJjZUNvbG9ycyA9IHsKICAgICAgICAgICAgJ0FUVE9NX0FQSSc6ICcjMTBiOTgxJywKICAgICAgICAgICAgJ0ZVQl9DQUNIRSc6ICcjM2I4MmY2JywKICAgICAgICAgICAgJ01BTlVBTF9ERUZBVUxUUyc6ICcjZjU5ZTBiJwogICAgICAgICAgfTsKCiAgICAgICAgICBjb25zdCBpbmRpY2F0b3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTsKICAgICAgICAgIGluZGljYXRvci5pZCA9ICdhdHRvbVNvdXJjZUluZGljYXRvcic7CiAgICAgICAgICBpbmRpY2F0b3Iuc3R5bGUuY3NzVGV4dCA9IGAKICAgICAgICAgICAgYmFja2dyb3VuZDogJHtzb3VyY2VDb2xvcnNbc291cmNlXSB8fCAnIzEwYjk4MSd9OwogICAgICAgICAgICBjb2xvcjogd2hpdGU7CiAgICAgICAgICAgIHBhZGRpbmc6IDEwcHggMTVweDsKICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogOHB4OwogICAgICAgICAgICBtYXJnaW4tdG9wOiAxNXB4OwogICAgICAgICAgICBmb250LXNpemU6IDEzcHg7CiAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiA2MDA7CiAgICAgICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjsKICAgICAgICAgIGA7CiAgICAgICAgICBpbmRpY2F0b3IudGV4dENvbnRlbnQgPSBzb3VyY2VMYWJlbHNbc291cmNlXSB8fCBzb3VyY2U7CiAgICAgICAgICAKICAgICAgICAgIGNvbnRhaW5lcj8uYXBwZW5kQ2hpbGQoaW5kaWNhdG9yKTsKICAgICAgICB9CgogICAgICAgIC8qKgogICAgICAgICAqIEh1ZHNvbiBWYWxsZXkgbWFya2V0IGRlZmF1bHRzCiAgICAgICAgICovCiAgICAgICAgZnVuY3Rpb24gZ2V0SHVkc29uVmFsbGV5RGVmYXVsdHMoKSB7CiAgICAgICAgICByZXR1cm4gewogICAgICAgICAgICBiZWRzOiAzLAogICAgICAgICAgICBiYXRoczogMiwKICAgICAgICAgICAgc3FmdDogMTgwMCwKICAgICAgICAgICAgYWNyZXM6IDAuMjUsCiAgICAgICAgICAgIGdhcmFnZTogMiwKICAgICAgICAgICAgcHJvcGVydHlUeXBlOiAnU2luZ2xlIEZhbWlseSBSZXNpZGVudGlhbCcsCiAgICAgICAgICAgIHllYXJCdWlsdDogMTk4NSwKICAgICAgICAgICAgY29uZGl0aW9uOiAnQXZlcmFnZScKICAgICAgICAgIH07CiAgICAgICAgfQoKICAgICAgICAvKioKICAgICAgICAgKiBTZXQgbG9hZGluZyBzdGF0ZSBmb3IgQVRUT00gbG9va3VwCiAgICAgICAgICovCiAgICAgICAgZnVuY3Rpb24gc2V0QXR0b21Mb2FkaW5nU3RhdGUobG9hZGluZykgewogICAgICAgICAgQXR0b21TdGF0ZS5sb2FkaW5nID0gbG9hZGluZzsKICAgICAgICAgIAogICAgICAgICAgY29uc3QgbG9va3VwQnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2F1dG9GaWxsQnV0dG9uJyk7CiAgICAgICAgICBpZiAobG9va3VwQnV0dG9uKSB7CiAgICAgICAgICAgIGxvb2t1cEJ1dHRvbi5kaXNhYmxlZCA9IGxvYWRpbmc7CiAgICAgICAgICAgIGxvb2t1cEJ1dHRvbi5pbm5lckhUTUwgPSBsb2FkaW5nIAogICAgICAgICAgICAgID8gJ/CflI0gTG9va2luZyB1cC4uLiA8ZGl2IGNsYXNzPSJzcGlubmVyIiBzdHlsZT0iZGlzcGxheTogaW5saW5lLWJsb2NrOyB3aWR0aDogMTZweDsgaGVpZ2h0OiAxNnB4OyBtYXJnaW4tbGVmdDogNXB4OyBib3JkZXItd2lkdGg6IDJweDsiPjwvZGl2PicgCiAgICAgICAgICAgICAgOiAn8J+UjSBBdXRvLUZpbGwgUHJvcGVydHkgRGF0YSAoQVRUT00pJzsKICAgICAgICAgICAgbG9va3VwQnV0dG9uLnN0eWxlLm9wYWNpdHkgPSBsb2FkaW5nID8gJzAuNicgOiAnMSc7CiAgICAgICAgICAgIGxvb2t1cEJ1dHRvbi5zdHlsZS5jdXJzb3IgPSBsb2FkaW5nID8gJ25vdC1hbGxvd2VkJyA6ICdwb2ludGVyJzsKICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIC8qKgogICAgICAgICAqIFNob3cgbm90aWZpY2F0aW9uIG1lc3NhZ2UKICAgICAgICAgKi8KICAgICAgICBmdW5jdGlvbiBzaG93QXR0b21Ob3RpZmljYXRpb24obWVzc2FnZSwgdHlwZSA9ICdpbmZvJykgewogICAgICAgICAgbGV0IG5vdGlmaWNhdGlvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhdHRvbU5vdGlmaWNhdGlvbicpOwogICAgICAgICAgCiAgICAgICAgICBpZiAoIW5vdGlmaWNhdGlvbikgewogICAgICAgICAgICAvLyBDcmVhdGUgbm90aWZpY2F0aW9uIGVsZW1lbnQKICAgICAgICAgICAgbm90aWZpY2F0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7CiAgICAgICAgICAgIG5vdGlmaWNhdGlvbi5pZCA9ICdhdHRvbU5vdGlmaWNhdGlvbic7CiAgICAgICAgICAgIG5vdGlmaWNhdGlvbi5zdHlsZS5jc3NUZXh0ID0gYAogICAgICAgICAgICAgIHBvc2l0aW9uOiBmaXhlZDsKICAgICAgICAgICAgICB0b3A6IDIwcHg7CiAgICAgICAgICAgICAgcmlnaHQ6IDIwcHg7CiAgICAgICAgICAgICAgbWF4LXdpZHRoOiA0MDBweDsKICAgICAgICAgICAgICBwYWRkaW5nOiAxNXB4IDIwcHg7CiAgICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogOHB4OwogICAgICAgICAgICAgIGJveC1zaGFkb3c6IDAgNHB4IDEycHggcmdiYSgwLDAsMCwwLjE1KTsKICAgICAgICAgICAgICBmb250LXNpemU6IDE0cHg7CiAgICAgICAgICAgICAgZm9udC13ZWlnaHQ6IDYwMDsKICAgICAgICAgICAgICB6LWluZGV4OiAxMDAwMDsKICAgICAgICAgICAgICBkaXNwbGF5OiBub25lOwogICAgICAgICAgICAgIGFuaW1hdGlvbjogc2xpZGVJbiAwLjNzIGVhc2Utb3V0OwogICAgICAgICAgICBgOwogICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG5vdGlmaWNhdGlvbik7CiAgICAgICAgICB9CgogICAgICAgICAgY29uc3QgY29sb3JzID0gewogICAgICAgICAgICBpbmZvOiB7IGJnOiAnIzNiODJmNicsIHRleHQ6ICd3aGl0ZScgfSwKICAgICAgICAgICAgc3VjY2VzczogeyBiZzogJyMxMGI5ODEnLCB0ZXh0OiAnd2hpdGUnIH0sCiAgICAgICAgICAgIHdhcm5pbmc6IHsgYmc6ICcjZjU5ZTBiJywgdGV4dDogJ3doaXRlJyB9LAogICAgICAgICAgICBlcnJvcjogeyBiZzogJyNlZjQ0NDQnLCB0ZXh0OiAnd2hpdGUnIH0KICAgICAgICAgIH07CgogICAgICAgICAgY29uc3QgY29sb3IgPSBjb2xvcnNbdHlwZV0gfHwgY29sb3JzLmluZm87CiAgICAgICAgICBub3RpZmljYXRpb24uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gY29sb3IuYmc7CiAgICAgICAgICBub3RpZmljYXRpb24uc3R5bGUuY29sb3IgPSBjb2xvci50ZXh0OwogICAgICAgICAgbm90aWZpY2F0aW9uLnRleHRDb250ZW50ID0gbWVzc2FnZTsKICAgICAgICAgIG5vdGlmaWNhdGlvbi5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJzsKCiAgICAgICAgICAvLyBBdXRvLWhpZGUgYWZ0ZXIgNSBzZWNvbmRzCiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsKICAgICAgICAgICAgbm90aWZpY2F0aW9uLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7CiAgICAgICAgICB9LCA1MDAwKTsKICAgICAgICB9CgogICAgICAgIC8vIEFkZCBzbGlkZS1pbiBhbmltYXRpb24KICAgICAgICBjb25zdCBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7CiAgICAgICAgc3R5bGUudGV4dENvbnRlbnQgPSBgCiAgICAgICAgICBAa2V5ZnJhbWVzIHNsaWRlSW4gewogICAgICAgICAgICBmcm9tIHsKICAgICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoNDAwcHgpOwogICAgICAgICAgICAgIG9wYWNpdHk6IDA7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdG8gewogICAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgwKTsKICAgICAgICAgICAgICBvcGFjaXR5OiAxOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICAuYXV0by1maWxsZWQgewogICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjBmZGY0ICFpbXBvcnRhbnQ7CiAgICAgICAgICAgIGJvcmRlci1jb2xvcjogIzEwYjk4MSAhaW1wb3J0YW50OwogICAgICAgICAgfQogICAgICAgIGA7CiAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzdHlsZSk7CiAgICA8L3NjcmlwdD4KPC9ib2R5Pgo8L2h0bWw+Cg==';
            const html = Buffer.from(htmlBase64, 'base64').toString('utf8');
            
            return {
                statusCode: 200,
                headers: {
                    'Content-Type': 'text/html',
                    'Access-Control-Allow-Origin': '*'
                },
                body: html
            };
        }

        // Route to appropriate API handler
        switch (action) {
            case 'getPersonData':
                return await getPersonData(params.personId, headers);
            
            case 'generateCMA':
                return await generateCMA(params, headers);
            
            case 'getHomebeatData':
                return await getHomebeatData(params.personId, headers);
            
            case 'resendHomebeat':
                return await resendHomebeat(params, headers);
            
            case 'createTask':
                return await createTask(params, headers);
            
            case 'createManualAction':
                return await createManualAction(params, headers);
            
            default:
                return {
                    statusCode: 400,
                    headers,
                    body: JSON.stringify({ error: 'Invalid action' })
                };
        }

    } catch (error) {
        console.error('Function error:', error);
        return {
            statusCode: 500,
            headers,
            body: JSON.stringify({ error: error.message })
        };
    }
};

// Get person data from FUB
async function getPersonData(personId, headers) {
    try {
        // Validate personId
        if (!personId || personId === 'null' || personId === 'undefined') {
            return {
                statusCode: 400,
                headers,
                body: JSON.stringify({ error: 'Missing person_id parameter' })
            };
        }
        
        const personData = await fubAPIRequest('GET', `/v1/people/${personId}`);
        
        return {
            statusCode: 200,
            headers,
            body: JSON.stringify(personData)
        };
    } catch (error) {
        return {
            statusCode: 500,
            headers,
            body: JSON.stringify({ error: 'Failed to fetch person data: ' + error.message })
        };
    }
}

// Generate CMA with CloudCMA API
async function generateCMA(params, headers) {
    try {
        const {
            personId,
            address,
            beds,
            baths,
            sqft,
            radius,
            monthsBack,
            minListings,
            propType,
            title,
            createHomebeat,
            homebeatFrequency
        } = params;

        // CRITICAL: Validate personId exists
        if (!personId || personId === 'null' || personId === 'undefined') {
            return {
                statusCode: 400,
                headers,
                body: JSON.stringify({ 
                    error: 'Missing person_id. FUB context parameter not decoded correctly.',
                    debug: {
                        personId: personId,
                        allParams: Object.keys(params)
                    }
                })
            };
        }

        // Get person data for lead info
        const personData = await fubAPIRequest('GET', `/v1/people/${personId}`);

        // Build CMA URL
        const cmaParams = new URLSearchParams({
            api_key: CLOUDCMA_API_KEY,
            address: address,
            beds: beds || '',
            baths: baths || '',
            sqft: sqft || '',
            radius: radius || '0.75',
            months_back: monthsBack || '9',
            min_listings: minListings || '10',
            prop_type: propType || '',
            title: title || `${personData.name || 'Client'} - ${address}`,
            callback_url: WEBHOOK_URL
        });

        const cmaUrl = `https://cloudcma.com/cmas/new?${cmaParams.toString()}`;

        // Update FUB custom fields
        const updatePayload = {
            customWILLOWCMADate: new Date().toISOString(),
            customWILLOWCMAAddress: address,
            customWILLOWCMALink: cmaUrl
        };

        await fubAPIRequest('PUT', `/v1/people/${personId}`, updatePayload);

        // Create FUB activity note (using Notes API for proper timeline visibility)
        await fubAPIRequest('POST', '/v1/notes', {
            personId: parseInt(personId),
            subject: ' WILLOW V50: CMA Generated',
            body: `CMA generated for ${address}

Template: ${params.template || 'Standard'}
Parameters: ${beds || 'auto'}bd/${baths || 'auto'}ba, ${sqft || 'auto'}sqft
Search: ${radius || '0.75'}mi radius, ${monthsBack || '9'} months back, min ${minListings || '10'} comps

CloudCMA URL: ${cmaUrl}

${params.notes || 'Generated via WILLOW V50 CMA Workbench'}`
        });

        let homebeatUrl = null;
        let homebeatCreated = false;

        // Create Homebeat if requested
        if (createHomebeat === true || createHomebeat === 'true') {
            try {
                const homebeatPayload = {
                    automation: {
                        api_key: CLOUDCMA_API_KEY,
                        frequency: homebeatFrequency || 'quarterly',
                        welcome_email: 'true',
                        report: {
                            prop_type: propType || null,
                            callback_url: null
                        },
                        subject_property: {
                            address: address,
                            sqft: sqft || null,
                            beds: beds || null,
                            baths: baths || null
                        },
                        lead: {
                            name: personData.name || '',
                            email_address: personData.emails?.[0]?.value || '',
                            phone: personData.phones?.[0]?.value || ''
                        }
                    }
                };

                const homebeatResponse = await cloudCMAAPIRequest('POST', '/homebeats/widget', homebeatPayload);
                homebeatCreated = true;
                homebeatUrl = homebeatResponse.homebeat_url || null;

                // Update FUB with Homebeat info
                await fubAPIRequest('PUT', `/v1/people/${personId}`, {
                    customWILLOWCloudCMAHomeBeatURL: homebeatUrl,
                    customWILLOWHomebeatFirstSendDate: new Date().toISOString()
                });

                // Create FUB activity note for Homebeat (using Notes API)
                await fubAPIRequest('POST', '/v1/notes', {
                    personId: parseInt(personId),
                    subject: ' WILLOW V50: Homebeat Created',
                    body: `Homebeat subscription created for ${address}

Frequency: ${homebeatFrequency || 'quarterly'}
Homebeat URL: ${homebeatUrl}

Lead will receive automated market updates with property value estimates and neighborhood insights.`
                });

            } catch (homebeatError) {
                console.error('Homebeat creation failed:', homebeatError);
            }
        }

        return {
            statusCode: 200,
            headers,
            body: JSON.stringify({
                success: true,
                cmaUrl: cmaUrl,
                homebeatCreated: homebeatCreated,
                homebeatUrl: homebeatUrl
            })
        };

    } catch (error) {
        return {
            statusCode: 500,
            headers,
            body: JSON.stringify({ error: 'Failed to generate CMA: ' + error.message })
        };
    }
}

// Get Homebeat data from CloudCMA
async function getHomebeatData(personId, headers) {
    try {
        // Validate personId
        if (!personId || personId === 'null' || personId === 'undefined') {
            return {
                statusCode: 400,
                headers,
                body: JSON.stringify({ error: 'Missing person_id parameter' })
            };
        }
        
        // Try to fetch homebeat data, but gracefully handle CloudCMA auth failures
        let homebeatReport = [];
        try {
            homebeatReport = await cloudCMAAPIRequest('GET', `/homebeats/report?api_key=${CLOUDCMA_API_KEY}&format=json`);
        } catch (cloudCMAError) {
            console.warn('CloudCMA API unavailable:', cloudCMAError.message);
            // Return empty homebeats array instead of failing
            return {
                statusCode: 200,
                headers,
                body: JSON.stringify({ 
                    homebeats: [],
                    warning: 'CloudCMA API unavailable. Check API key configuration.'
                })
            };
        }

        const personData = await fubAPIRequest('GET', `/v1/people/${personId}`);
        const personEmail = personData.emails?.[0]?.value?.toLowerCase();

        if (!personEmail) {
            return {
                statusCode: 200,
                headers,
                body: JSON.stringify({ homebeats: [] })
            };
        }

        const leadHomebeats = (homebeatReport || []).filter(hb => 
            hb.lead_email?.toLowerCase() === personEmail
        );

        const enrichedHomebeats = leadHomebeats.map(hb => ({
            ...hb,
            first_send_date: personData.customWILLOWHomebeatFirstSendDate || hb.created_at,
            status: (hb.total_views || 0) === 0 ? 'pending' : 'active'
        }));

        if (enrichedHomebeats.length > 0) {
            const totalViews = enrichedHomebeats.reduce((sum, hb) => sum + (hb.total_views || 0), 0);
            const latestView = enrichedHomebeats
                .map(hb => hb.last_view)
                .filter(v => v)
                .sort()
                .reverse()[0];

            await fubAPIRequest('PUT', `/v1/people/${personId}`, {
                customWILLOWHomebeatViews: totalViews,
                customWILLOWHomebeatLastView: latestView || null
            });
        }

        return {
            statusCode: 200,
            headers,
            body: JSON.stringify({ homebeats: enrichedHomebeats })
        };

    } catch (error) {
        return {
            statusCode: 500,
            headers,
            body: JSON.stringify({ error: 'Failed to fetch Homebeat data: ' + error.message })
        };
    }
}

// Resend Homebeat
async function resendHomebeat(params, headers) {
    try {
        const { homebeatId, personId } = params;

        // Validate personId
        if (!personId || personId === 'null' || personId === 'undefined') {
            return {
                statusCode: 400,
                headers,
                body: JSON.stringify({ error: 'Missing person_id parameter' })
            };
        }

        const personData = await fubAPIRequest('GET', `/v1/people/${personId}`);
        
        const homebeatReport = await cloudCMAAPIRequest('GET', `/homebeats/report?api_key=${CLOUDCMA_API_KEY}&format=json`);
        const homebeat = (homebeatReport || []).find(hb => hb.id === homebeatId);

        if (!homebeat) {
            throw new Error('Homebeat not found');
        }

        const homebeatPayload = {
            automation: {
                api_key: CLOUDCMA_API_KEY,
                frequency: homebeat.frequency || 'quarterly',
                welcome_email: 'true',
                subject_property: {
                    address: homebeat.property_address,
                    sqft: homebeat.sqft || null,
                    beds: homebeat.beds || null,
                    baths: homebeat.baths || null
                },
                lead: {
                    name: personData.name || '',
                    email_address: personData.emails?.[0]?.value || '',
                    phone: personData.phones?.[0]?.value || ''
                }
            }
        };

        await cloudCMAAPIRequest('POST', '/homebeats/widget', homebeatPayload);

        await fubAPIRequest('PUT', `/v1/people/${personId}`, {
            customWILLOWHomebeatLastResend: new Date().toISOString()
        });

        // Create FUB activity note for Homebeat resend (using Notes API)
        await fubAPIRequest('POST', '/v1/notes', {
            personId: parseInt(personId),
            subject: ' WILLOW V50: Homebeat Resent',
            body: `Homebeat resent for ${homebeat.property_address}

Previous Status: Pending (0 views)
Action: Manual resend triggered

Lead will receive a new Homebeat welcome email with the latest market data.`
        });

        return {
            statusCode: 200,
            headers,
            body: JSON.stringify({ success: true })
        };

    } catch (error) {
        return {
            statusCode: 500,
            headers,
            body: JSON.stringify({ error: 'Failed to resend Homebeat: ' + error.message })
        };
    }
}

// Create task in FUB
async function createTask(params, headers) {
    try {
        const { personId, taskDescription, urgency, assignedTo } = params;

        // Validate personId
        if (!personId || personId === 'null' || personId === 'undefined') {
            return {
                statusCode: 400,
                headers,
                body: JSON.stringify({ error: 'Missing person_id parameter' })
            };
        }

        const now = new Date();
        let dueDate = new Date(now);
        
        switch (urgency) {
            case 'IMMEDIATE':
                dueDate.setHours(now.getHours() + 24);
                break;
            case 'SAME_DAY':
                dueDate.setHours(23, 59, 59);
                break;
            case 'NEXT_DAY':
                dueDate.setDate(now.getDate() + 1);
                break;
            case 'WEEKLY':
                dueDate.setDate(now.getDate() + 7);
                break;
            default:
                dueDate.setDate(now.getDate() + 1);
        }

        // FUB tasks API doesn't accept description/body field
        // Task details should be added as a note after task creation
        const taskPayload = {
            personId: parseInt(personId),
            type: 'Follow Up',
            dueDate: dueDate.toISOString()
        };

        const taskResult = await fubAPIRequest('POST', '/v1/tasks', taskPayload);
        
        // Add task details as a note
        const notePayload = {
            personId: parseInt(personId),
            subject: `Task: ${taskDescription}`,
            body: `${taskDescription}\n\nAssigned to: ${assignedTo}\nUrgency: ${urgency}\nDue: ${dueDate.toLocaleDateString()}`,
            isHtml: false
        };
        await fubAPIRequest('POST', '/v1/notes', notePayload);

        return {
            statusCode: 200,
            headers,
            body: JSON.stringify({ success: true })
        };

    } catch (error) {
        return {
            statusCode: 500,
            headers,
            body: JSON.stringify({ error: 'Failed to create task: ' + error.message })
        };
    }
}

// Create manual action in FUB
async function createManualAction(params, headers) {
    try {
        const { personId, actionType, assignedTo, urgency, notes } = params;

        // Validate personId
        if (!personId || personId === 'null' || personId === 'undefined') {
            return {
                statusCode: 400,
                headers,
                body: JSON.stringify({ error: 'Missing person_id parameter' })
            };
        }

        const now = new Date();
        let dueDate = new Date(now);
        
        switch (urgency) {
            case 'IMMEDIATE':
                dueDate.setHours(now.getHours() + 24);
                break;
            case 'SAME_DAY':
                dueDate.setHours(23, 59, 59);
                break;
            case 'NEXT_DAY':
                dueDate.setDate(now.getDate() + 1);
                break;
            case 'WEEKLY':
                dueDate.setDate(now.getDate() + 7);
                break;
            default:
                dueDate.setDate(now.getDate() + 1);
        }

        // Map action types to FUB task types
        const taskTypeMap = {
            'Task': 'Follow Up',
            'Call': 'Call',
            'Email': 'Email',
            'Text': 'Text',
            'Note': 'Note'
        };
        
        const fubType = taskTypeMap[actionType] || 'Follow Up';
        
        // If it's a Note, use /v1/notes endpoint, otherwise use /v1/tasks
        if (actionType === 'Note') {
            const notePayload = {
                personId: parseInt(personId),
                subject: `${urgency} Action`,
                body: `${notes}\n\nAssigned to: ${assignedTo}`,
                isHtml: false
            };
            await fubAPIRequest('POST', '/v1/notes', notePayload);
        } else {
            // FUB tasks API doesn't accept description field
            const taskPayload = {
                personId: parseInt(personId),
                type: fubType,
                dueDate: dueDate.toISOString()
            };
            await fubAPIRequest('POST', '/v1/tasks', taskPayload);
            
            // Add action details as a note
            const notePayload = {
                personId: parseInt(personId),
                subject: `${fubType} Action`,
                body: `${notes}\n\nAssigned to: ${assignedTo}\nUrgency: ${urgency}`,
                isHtml: false
            };
            await fubAPIRequest('POST', '/v1/notes', notePayload);
        }

        return {
            statusCode: 200,
            headers,
            body: JSON.stringify({ success: true })
        };

    } catch (error) {
        return {
            statusCode: 500,
            headers,
            body: JSON.stringify({ error: 'Failed to create action: ' + error.message })
        };
    }
}

// FUB API Request Helper
function fubAPIRequest(method, path, data = null) {
    return new Promise((resolve, reject) => {
        const options = {
            hostname: 'api.followupboss.com',
            port: 443,
            path: path,
            method: method,
            headers: {
                'Authorization': `Basic ${Buffer.from(FUB_API_KEY + ':').toString('base64')}`,
                'Content-Type': 'application/json'
            }
        };

        const req = https.request(options, (res) => {
            let body = '';
            res.on('data', (chunk) => body += chunk);
            res.on('end', () => {
                try {
                    const parsed = JSON.parse(body);
                    if (res.statusCode >= 200 && res.statusCode < 300) {
                        resolve(parsed);
                    } else {
                        reject(new Error(`FUB API error: ${res.statusCode} - ${body}`));
                    }
                } catch (e) {
                    reject(new Error(`Failed to parse FUB response: ${body}`));
                }
            });
        });

        req.on('error', reject);
        
        if (data) {
            req.write(JSON.stringify(data));
        }
        
        req.end();
    });
}

// CloudCMA API Request Helper
function cloudCMAAPIRequest(method, path, data = null) {
    return new Promise((resolve, reject) => {
        const options = {
            hostname: 'cloudcma.com',
            port: 443,
            path: path,
            method: method,
            headers: {
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            }
        };

        const req = https.request(options, (res) => {
            let body = '';
            res.on('data', (chunk) => body += chunk);
            res.on('end', () => {
                try {
                    const parsed = body ? JSON.parse(body) : {};
                    if (res.statusCode >= 200 && res.statusCode < 300) {
                        resolve(parsed);
                    } else {
                        reject(new Error(`CloudCMA API error: ${res.statusCode} - ${body}`));
                    }
                } catch (e) {
                    if (res.statusCode >= 200 && res.statusCode < 300) {
                        resolve({});
                    } else {
                        reject(new Error(`Failed to parse CloudCMA response: ${body}`));
                    }
                }
            });
        });

        req.on('error', reject);
        
        if (data) {
            req.write(JSON.stringify(data));
        }
        
        req.end();
    });
}
