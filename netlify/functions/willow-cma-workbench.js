// WILLOW V50 CMA Workbench - Complete Netlify Function
// Purpose: Server-side FUB/CloudCMA API integration with HTML serving

const https = require('https');

// API Credentials
const FUB_API_KEY = process.env.FUB_API_KEY || 'fka_0oHt62NxmsExO6x69p08ix82zx8ii1hzrj';
const CLOUDCMA_API_KEY = process.env.CLOUDCMA_API_KEY || '742f4a46e1780904da090d721a9bae7b';
const WEBHOOK_URL = 'https://willow-v50-supervised-cma.netlify.app/.netlify/functions/cloudcma-webhook';

exports.handler = async (event, context) => {
    // CORS headers
    const headers = {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': 'Content-Type',
        'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
        'Content-Type': 'application/json'
    };

    if (event.httpMethod === 'OPTIONS') {
        return { statusCode: 200, headers, body: '' };
    }

    try {
        // Parse request
        const params = event.httpMethod === 'GET' 
            ? event.queryStringParameters || {}
            : JSON.parse(event.body || '{}');

        const action = params.action;

        // If no action parameter, serve HTML interface (Base64 decoded)
        if (!action) {
            const htmlBase64 = 'PCFET0NUWVBFIGh0bWw+CjxodG1sIGxhbmc9ImVuIj4KPGhlYWQ+CiAgICA8bWV0YSBjaGFyc2V0PSJVVEYtOCI+CiAgICA8bWV0YSBuYW1lPSJ2aWV3cG9ydCIgY29udGVudD0id2lkdGg9ZGV2aWNlLXdpZHRoLCBpbml0aWFsLXNjYWxlPTEuMCI+CiAgICA8dGl0bGU+V0lMTE9XIFY1MCAtIEVuaGFuY2VkIENNQSBXb3JrYmVuY2g8L3RpdGxlPgogICAgPHNjcmlwdCB0eXBlPSJ0ZXh0L2phdmFzY3JpcHQiIHNyYz0iaHR0cHM6Ly9laWEuZm9sbG93dXBib3NzLmNvbS9lbWJlZGRlZEFwcHMtdjEuMC4xLmpzIj48L3NjcmlwdD4KICAgIDxzdHlsZT4KICAgICAgICAqIHsKICAgICAgICAgICAgbWFyZ2luOiAwOwogICAgICAgICAgICBwYWRkaW5nOiAwOwogICAgICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94OwogICAgICAgIH0KCiAgICAgICAgYm9keSB7CiAgICAgICAgICAgIGZvbnQtZmFtaWx5OiAtYXBwbGUtc3lzdGVtLCBCbGlua01hY1N5c3RlbUZvbnQsICdTZWdvZSBVSScsIFJvYm90bywgc2Fucy1zZXJpZjsKICAgICAgICAgICAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KDEzNWRlZywgIzY2N2VlYSAwJSwgIzc2NGJhMiAxMDAlKTsKICAgICAgICAgICAgY29sb3I6ICMyZDM3NDg7CiAgICAgICAgICAgIGxpbmUtaGVpZ2h0OiAxLjQ7CiAgICAgICAgICAgIGZvbnQtc2l6ZTogMTNweDsKICAgICAgICB9CgogICAgICAgIC5jb250YWluZXIgewogICAgICAgICAgICBtYXgtd2lkdGg6IDE2MDBweDsKICAgICAgICAgICAgbWFyZ2luOiAwIGF1dG87CiAgICAgICAgICAgIHBhZGRpbmc6IDE1cHg7CiAgICAgICAgfQoKICAgICAgICAuaGVhZGVyIHsKICAgICAgICAgICAgYmFja2dyb3VuZDogd2hpdGU7CiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDhweDsKICAgICAgICAgICAgcGFkZGluZzogMTVweCAyMHB4OwogICAgICAgICAgICBtYXJnaW4tYm90dG9tOiAxNXB4OwogICAgICAgICAgICBib3gtc2hhZG93OiAwIDJweCA0cHggcmdiYSgwLDAsMCwwLjEpOwogICAgICAgIH0KCiAgICAgICAgLmhlYWRlciBoMSB7CiAgICAgICAgICAgIGZvbnQtc2l6ZTogMjBweDsKICAgICAgICAgICAgY29sb3I6ICM2NjdlZWE7CiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDNweDsKICAgICAgICB9CgogICAgICAgIC5oZWFkZXIgLnN1YnRpdGxlIHsKICAgICAgICAgICAgZm9udC1zaXplOiAxMnB4OwogICAgICAgICAgICBjb2xvcjogIzcxODA5NjsKICAgICAgICB9CgogICAgICAgIC53b3JrYmVuY2ggewogICAgICAgICAgICBiYWNrZ3JvdW5kOiB3aGl0ZTsKICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogOHB4OwogICAgICAgICAgICBwYWRkaW5nOiAyMHB4OwogICAgICAgICAgICBib3gtc2hhZG93OiAwIDJweCA0cHggcmdiYSgwLDAsMCwwLjEpOwogICAgICAgIH0KCiAgICAgICAgLyogREVOU0UgR1JJRCBMQVlPVVQgKi8KICAgICAgICAucHJvcGVydHktZ3JpZCB7CiAgICAgICAgICAgIGRpc3BsYXk6IGdyaWQ7CiAgICAgICAgICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogMWZyIDFmcjsKICAgICAgICAgICAgZ2FwOiAyMHB4OwogICAgICAgICAgICBtYXJnaW4tYm90dG9tOiAyMHB4OwogICAgICAgIH0KCiAgICAgICAgLnNlY3Rpb24tY29tcGFjdCB7CiAgICAgICAgICAgIGJhY2tncm91bmQ6ICNmN2ZhZmM7CiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDZweDsKICAgICAgICAgICAgcGFkZGluZzogMTJweDsKICAgICAgICB9CgogICAgICAgIC5zZWN0aW9uLXRpdGxlLWNvbXBhY3QgewogICAgICAgICAgICBmb250LXNpemU6IDE0cHg7CiAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiA3MDA7CiAgICAgICAgICAgIGNvbG9yOiAjMmQzNzQ4OwogICAgICAgICAgICBtYXJnaW4tYm90dG9tOiAxMHB4OwogICAgICAgICAgICBkaXNwbGF5OiBmbGV4OwogICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyOwogICAgICAgICAgICBnYXA6IDhweDsKICAgICAgICAgICAgYm9yZGVyLWJvdHRvbTogMnB4IHNvbGlkICNlMmU4ZjA7CiAgICAgICAgICAgIHBhZGRpbmctYm90dG9tOiA2cHg7CiAgICAgICAgfQoKICAgICAgICAvKiBBVk0gQ09ORklERU5DRSBCQURHRSAqLwogICAgICAgIC5hdm0taGVhZGVyIHsKICAgICAgICAgICAgZGlzcGxheTogZmxleDsKICAgICAgICAgICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuOwogICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyOwogICAgICAgICAgICBtYXJnaW4tYm90dG9tOiAxMnB4OwogICAgICAgIH0KCiAgICAgICAgLmNvbmZpZGVuY2UtYmFkZ2UgewogICAgICAgICAgICBwYWRkaW5nOiA0cHggMTJweDsKICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogNHB4OwogICAgICAgICAgICBmb250LXNpemU6IDExcHg7CiAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiA3MDA7CiAgICAgICAgICAgIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7CiAgICAgICAgICAgIGxldHRlci1zcGFjaW5nOiAwLjVweDsKICAgICAgICB9CgogICAgICAgIC5jb25maWRlbmNlLUhJR0ggewogICAgICAgICAgICBiYWNrZ3JvdW5kOiAjNDhiYjc4OwogICAgICAgICAgICBjb2xvcjogd2hpdGU7CiAgICAgICAgfQoKICAgICAgICAuY29uZmlkZW5jZS1NRURJVU0gewogICAgICAgICAgICBiYWNrZ3JvdW5kOiAjZWQ4OTM2OwogICAgICAgICAgICBjb2xvcjogd2hpdGU7CiAgICAgICAgfQoKICAgICAgICAuY29uZmlkZW5jZS1MT1cgewogICAgICAgICAgICBiYWNrZ3JvdW5kOiAjZmM4MTgxOwogICAgICAgICAgICBjb2xvcjogd2hpdGU7CiAgICAgICAgfQoKICAgICAgICAuY29uZmlkZW5jZS1VTktOT1dOIHsKICAgICAgICAgICAgYmFja2dyb3VuZDogI2EwYWVjMDsKICAgICAgICAgICAgY29sb3I6IHdoaXRlOwogICAgICAgIH0KCiAgICAgICAgLyogRURJVEFCTEUgQ0VOVEVSIFZBTFVFICovCiAgICAgICAgLnZhbHVlLWNvbnRyb2wgewogICAgICAgICAgICBkaXNwbGF5OiBncmlkOwogICAgICAgICAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IDFmciAxZnI7CiAgICAgICAgICAgIGdhcDogMTBweDsKICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMTVweDsKICAgICAgICB9CgogICAgICAgIC52YWx1ZS1pbnB1dC1ncm91cCB7CiAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7CiAgICAgICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47CiAgICAgICAgICAgIGdhcDogNHB4OwogICAgICAgIH0KCiAgICAgICAgLnZhbHVlLWlucHV0LWxhYmVsIHsKICAgICAgICAgICAgZm9udC1zaXplOiAxMXB4OwogICAgICAgICAgICBmb250LXdlaWdodDogNjAwOwogICAgICAgICAgICBjb2xvcjogIzcxODA5NjsKICAgICAgICAgICAgdGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTsKICAgICAgICB9CgogICAgICAgIC52YWx1ZS1pbnB1dCB7CiAgICAgICAgICAgIHBhZGRpbmc6IDhweCAxMnB4OwogICAgICAgICAgICBib3JkZXI6IDJweCBzb2xpZCAjZTJlOGYwOwogICAgICAgICAgICBib3JkZXItcmFkaXVzOiA2cHg7CiAgICAgICAgICAgIGZvbnQtc2l6ZTogMTRweDsKICAgICAgICAgICAgZm9udC13ZWlnaHQ6IDcwMDsKICAgICAgICAgICAgY29sb3I6ICMyZDM3NDg7CiAgICAgICAgICAgIGJhY2tncm91bmQ6IHdoaXRlOwogICAgICAgIH0KCiAgICAgICAgLnZhbHVlLWlucHV0OmZvY3VzIHsKICAgICAgICAgICAgb3V0bGluZTogbm9uZTsKICAgICAgICAgICAgYm9yZGVyLWNvbG9yOiAjNjY3ZWVhOwogICAgICAgIH0KCiAgICAgICAgLnZhbHVlLWlucHV0LnN1Z2dlc3RlZCB7CiAgICAgICAgICAgIGJhY2tncm91bmQ6ICNmMGZmZjQ7CiAgICAgICAgICAgIGJvcmRlci1jb2xvcjogIzQ4YmI3ODsKICAgICAgICB9CgogICAgICAgIC52YWx1ZS1pbnB1dC51c2VyLW92ZXJyaWRlIHsKICAgICAgICAgICAgYmFja2dyb3VuZDogI2ZmZmFmMDsKICAgICAgICAgICAgYm9yZGVyLWNvbG9yOiAjZWQ4OTM2OwogICAgICAgIH0KCiAgICAgICAgLyogREVOU0UgREFUQSBST1dTICovCiAgICAgICAgLmRhdGEtcm93IHsKICAgICAgICAgICAgZGlzcGxheTogZ3JpZDsKICAgICAgICAgICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiAxMjBweCAxZnI7CiAgICAgICAgICAgIGdhcDogOHB4OwogICAgICAgICAgICBwYWRkaW5nOiA2cHggMDsKICAgICAgICAgICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNlZGYyZjc7CiAgICAgICAgfQoKICAgICAgICAuZGF0YS1yb3c6bGFzdC1jaGlsZCB7CiAgICAgICAgICAgIGJvcmRlci1ib3R0b206IG5vbmU7CiAgICAgICAgfQoKICAgICAgICAuZGF0YS1sYWJlbCB7CiAgICAgICAgICAgIGZvbnQtc2l6ZTogMTFweDsKICAgICAgICAgICAgZm9udC13ZWlnaHQ6IDYwMDsKICAgICAgICAgICAgY29sb3I6ICM3MTgwOTY7CiAgICAgICAgICAgIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7CiAgICAgICAgfQoKICAgICAgICAuZGF0YS12YWx1ZSB7CiAgICAgICAgICAgIGZvbnQtc2l6ZTogMTNweDsKICAgICAgICAgICAgZm9udC13ZWlnaHQ6IDYwMDsKICAgICAgICAgICAgY29sb3I6ICMyZDM3NDg7CiAgICAgICAgfQoKICAgICAgICAuZGF0YS12YWx1ZS5oaWdobGlnaHQgewogICAgICAgICAgICBjb2xvcjogIzY2N2VlYTsKICAgICAgICAgICAgZm9udC13ZWlnaHQ6IDcwMDsKICAgICAgICB9CgogICAgICAgIC5kYXRhLXZhbHVlLndhcm5pbmcgewogICAgICAgICAgICBjb2xvcjogI2VkODkzNjsKICAgICAgICAgICAgZm9udC13ZWlnaHQ6IDcwMDsKICAgICAgICB9CgogICAgICAgIC5kYXRhLXZhbHVlLmRhbmdlciB7CiAgICAgICAgICAgIGNvbG9yOiAjZmM4MTgxOwogICAgICAgICAgICBmb250LXdlaWdodDogNzAwOwogICAgICAgIH0KCiAgICAgICAgLmRhdGEtdmFsdWUuc3VjY2VzcyB7CiAgICAgICAgICAgIGNvbG9yOiAjNDhiYjc4OwogICAgICAgICAgICBmb250LXdlaWdodDogNzAwOwogICAgICAgIH0KCiAgICAgICAgLyogQ09NUEFDVCBQUk9QRVJUWSBDSEFSQUNURVJJU1RJQ1MgKi8KICAgICAgICAuY2hhci1ncmlkIHsKICAgICAgICAgICAgZGlzcGxheTogZ3JpZDsKICAgICAgICAgICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiByZXBlYXQoNCwgMWZyKTsKICAgICAgICAgICAgZ2FwOiA4cHg7CiAgICAgICAgICAgIG1hcmdpbjogMTBweCAwOwogICAgICAgIH0KCiAgICAgICAgLmNoYXItaXRlbSB7CiAgICAgICAgICAgIGJhY2tncm91bmQ6IHdoaXRlOwogICAgICAgICAgICBib3JkZXI6IDFweCBzb2xpZCAjZTJlOGYwOwogICAgICAgICAgICBib3JkZXItcmFkaXVzOiA2cHg7CiAgICAgICAgICAgIHBhZGRpbmc6IDhweDsKICAgICAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyOwogICAgICAgIH0KCiAgICAgICAgLmNoYXItdmFsdWUgewogICAgICAgICAgICBmb250LXNpemU6IDE2cHg7CiAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiA3MDA7CiAgICAgICAgICAgIGNvbG9yOiAjMmQzNzQ4OwogICAgICAgICAgICBtYXJnaW4tYm90dG9tOiAycHg7CiAgICAgICAgfQoKICAgICAgICAuY2hhci1sYWJlbCB7CiAgICAgICAgICAgIGZvbnQtc2l6ZTogMTBweDsKICAgICAgICAgICAgY29sb3I6ICM3MTgwOTY7CiAgICAgICAgICAgIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7CiAgICAgICAgfQoKICAgICAgICAvKiBTQUxFUyBISVNUT1JZIFRBQkxFICovCiAgICAgICAgLnNhbGVzLXRhYmxlIHsKICAgICAgICAgICAgd2lkdGg6IDEwMCU7CiAgICAgICAgICAgIGZvbnQtc2l6ZTogMTJweDsKICAgICAgICAgICAgYm9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTsKICAgICAgICAgICAgbWFyZ2luOiAxMHB4IDA7CiAgICAgICAgfQoKICAgICAgICAuc2FsZXMtdGFibGUgdGggewogICAgICAgICAgICBiYWNrZ3JvdW5kOiAjZWRmMmY3OwogICAgICAgICAgICBwYWRkaW5nOiA2cHggOHB4OwogICAgICAgICAgICB0ZXh0LWFsaWduOiBsZWZ0OwogICAgICAgICAgICBmb250LXNpemU6IDEwcHg7CiAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiA3MDA7CiAgICAgICAgICAgIGNvbG9yOiAjNzE4MDk2OwogICAgICAgICAgICB0ZXh0LXRyYW5zZm9ybTogdXBwZXJjYXNlOwogICAgICAgICAgICBib3JkZXItYm90dG9tOiAycHggc29saWQgI2NiZDVlMDsKICAgICAgICB9CgogICAgICAgIC5zYWxlcy10YWJsZSB0ZCB7CiAgICAgICAgICAgIHBhZGRpbmc6IDZweCA4cHg7CiAgICAgICAgICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjZWRmMmY3OwogICAgICAgIH0KCiAgICAgICAgLyogUklTSyBGTEFHUyAqLwogICAgICAgIC5yaXNrLWZsYWdzIHsKICAgICAgICAgICAgZGlzcGxheTogZmxleDsKICAgICAgICAgICAgZmxleC13cmFwOiB3cmFwOwogICAgICAgICAgICBnYXA6IDZweDsKICAgICAgICAgICAgbWFyZ2luOiAxMHB4IDA7CiAgICAgICAgfQoKICAgICAgICAucmlzay1mbGFnIHsKICAgICAgICAgICAgcGFkZGluZzogNHB4IDEwcHg7CiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDRweDsKICAgICAgICAgICAgZm9udC1zaXplOiAxMHB4OwogICAgICAgICAgICBmb250LXdlaWdodDogNzAwOwogICAgICAgICAgICB0ZXh0LXRyYW5zZm9ybTogdXBwZXJjYXNlOwogICAgICAgIH0KCiAgICAgICAgLmZsYWctZGFuZ2VyIHsKICAgICAgICAgICAgYmFja2dyb3VuZDogI2ZmZjVmNTsKICAgICAgICAgICAgYm9yZGVyOiAxcHggc29saWQgI2ZjODE4MTsKICAgICAgICAgICAgY29sb3I6ICNjNTMwMzA7CiAgICAgICAgfQoKICAgICAgICAuZmxhZy13YXJuaW5nIHsKICAgICAgICAgICAgYmFja2dyb3VuZDogI2ZmZmFmMDsKICAgICAgICAgICAgYm9yZGVyOiAxcHggc29saWQgI2VkODkzNjsKICAgICAgICAgICAgY29sb3I6ICM3NDQyMTA7CiAgICAgICAgfQoKICAgICAgICAuZmxhZy1pbmZvIHsKICAgICAgICAgICAgYmFja2dyb3VuZDogI2ViZjhmZjsKICAgICAgICAgICAgYm9yZGVyOiAxcHggc29saWQgIzQyOTllMTsKICAgICAgICAgICAgY29sb3I6ICMyYzUyODI7CiAgICAgICAgfQoKICAgICAgICAuZmxhZy1zdWNjZXNzIHsKICAgICAgICAgICAgYmFja2dyb3VuZDogI2YwZmZmNDsKICAgICAgICAgICAgYm9yZGVyOiAxcHggc29saWQgIzQ4YmI3ODsKICAgICAgICAgICAgY29sb3I6ICMyMjU0M2Q7CiAgICAgICAgfQoKICAgICAgICAvKiBGT1JNIElOUFVUUyAtIENPTVBBQ1QgKi8KICAgICAgICAuZm9ybS1jb21wYWN0IHsKICAgICAgICAgICAgZGlzcGxheTogZ3JpZDsKICAgICAgICAgICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiByZXBlYXQoMiwgMWZyKTsKICAgICAgICAgICAgZ2FwOiAxMHB4OwogICAgICAgICAgICBtYXJnaW4tYm90dG9tOiAxNXB4OwogICAgICAgIH0KCiAgICAgICAgLmZvcm0tZ3JvdXAtY29tcGFjdCB7CiAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7CiAgICAgICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47CiAgICAgICAgICAgIGdhcDogNHB4OwogICAgICAgIH0KCiAgICAgICAgLmZvcm0tbGFiZWwtY29tcGFjdCB7CiAgICAgICAgICAgIGZvbnQtc2l6ZTogMTFweDsKICAgICAgICAgICAgZm9udC13ZWlnaHQ6IDYwMDsKICAgICAgICAgICAgY29sb3I6ICM3MTgwOTY7CiAgICAgICAgICAgIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7CiAgICAgICAgfQoKICAgICAgICAuZm9ybS1pbnB1dC1jb21wYWN0IHsKICAgICAgICAgICAgcGFkZGluZzogOHB4IDEwcHg7CiAgICAgICAgICAgIGJvcmRlcjogMnB4IHNvbGlkICNlMmU4ZjA7CiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDZweDsKICAgICAgICAgICAgZm9udC1zaXplOiAxM3B4OwogICAgICAgIH0KCiAgICAgICAgLmZvcm0taW5wdXQtY29tcGFjdDpmb2N1cyB7CiAgICAgICAgICAgIG91dGxpbmU6IG5vbmU7CiAgICAgICAgICAgIGJvcmRlci1jb2xvcjogIzY2N2VlYTsKICAgICAgICB9CgogICAgICAgIC5mb3JtLXNlbGVjdC1jb21wYWN0IHsKICAgICAgICAgICAgcGFkZGluZzogOHB4IDEwcHg7CiAgICAgICAgICAgIGJvcmRlcjogMnB4IHNvbGlkICNlMmU4ZjA7CiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDZweDsKICAgICAgICAgICAgZm9udC1zaXplOiAxM3B4OwogICAgICAgICAgICBiYWNrZ3JvdW5kOiB3aGl0ZTsKICAgICAgICAgICAgY3Vyc29yOiBwb2ludGVyOwogICAgICAgIH0KCiAgICAgICAgLmJ0biB7CiAgICAgICAgICAgIHBhZGRpbmc6IDEwcHggMjBweDsKICAgICAgICAgICAgYm9yZGVyOiBub25lOwogICAgICAgICAgICBib3JkZXItcmFkaXVzOiA2cHg7CiAgICAgICAgICAgIGZvbnQtc2l6ZTogMTRweDsKICAgICAgICAgICAgZm9udC13ZWlnaHQ6IDYwMDsKICAgICAgICAgICAgY3Vyc29yOiBwb2ludGVyOwogICAgICAgICAgICB0cmFuc2l0aW9uOiBhbGwgMC4zcyBlYXNlOwogICAgICAgIH0KCiAgICAgICAgLmJ0bi1wcmltYXJ5IHsKICAgICAgICAgICAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KDEzNWRlZywgIzY2N2VlYSAwJSwgIzc2NGJhMiAxMDAlKTsKICAgICAgICAgICAgY29sb3I6IHdoaXRlOwogICAgICAgIH0KCiAgICAgICAgLmJ0bi1wcmltYXJ5OmhvdmVyIHsKICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC0ycHgpOwogICAgICAgICAgICBib3gtc2hhZG93OiAwIDRweCA4cHggcmdiYSgxMDIsIDEyNiwgMjM0LCAwLjMpOwogICAgICAgIH0KCiAgICAgICAgLmJ0bi1zZWNvbmRhcnkgewogICAgICAgICAgICBiYWNrZ3JvdW5kOiAjZTJlOGYwOwogICAgICAgICAgICBjb2xvcjogIzRhNTU2ODsKICAgICAgICB9CgogICAgICAgIC5idG4tc2Vjb25kYXJ5OmhvdmVyIHsKICAgICAgICAgICAgYmFja2dyb3VuZDogI2NiZDVlMDsKICAgICAgICB9CgogICAgICAgIC5idG4tZ3JvdXAgewogICAgICAgICAgICBkaXNwbGF5OiBmbGV4OwogICAgICAgICAgICBnYXA6IDEwcHg7CiAgICAgICAgICAgIG1hcmdpbi10b3A6IDE1cHg7CiAgICAgICAgfQoKICAgICAgICAubG9hZGluZyB7CiAgICAgICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjsKICAgICAgICAgICAgcGFkZGluZzogMzBweDsKICAgICAgICAgICAgY29sb3I6ICM3MTgwOTY7CiAgICAgICAgfQoKICAgICAgICAuc3Bpbm5lciB7CiAgICAgICAgICAgIGJvcmRlcjogNHB4IHNvbGlkICNlMmU4ZjA7CiAgICAgICAgICAgIGJvcmRlci10b3A6IDRweCBzb2xpZCAjNjY3ZWVhOwogICAgICAgICAgICBib3JkZXItcmFkaXVzOiA1MCU7CiAgICAgICAgICAgIHdpZHRoOiAzMHB4OwogICAgICAgICAgICBoZWlnaHQ6IDMwcHg7CiAgICAgICAgICAgIGFuaW1hdGlvbjogc3BpbiAxcyBsaW5lYXIgaW5maW5pdGU7CiAgICAgICAgICAgIG1hcmdpbjogMCBhdXRvIDE1cHg7CiAgICAgICAgfQoKICAgICAgICBAa2V5ZnJhbWVzIHNwaW4gewogICAgICAgICAgICAwJSB7IHRyYW5zZm9ybTogcm90YXRlKDBkZWcpOyB9CiAgICAgICAgICAgIDEwMCUgeyB0cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpOyB9CiAgICAgICAgfQoKICAgICAgICAuZXJyb3IgewogICAgICAgICAgICBiYWNrZ3JvdW5kOiAjZmZmNWY1OwogICAgICAgICAgICBib3JkZXI6IDJweCBzb2xpZCAjZmM4MTgxOwogICAgICAgICAgICBib3JkZXItcmFkaXVzOiA2cHg7CiAgICAgICAgICAgIHBhZGRpbmc6IDEycHg7CiAgICAgICAgICAgIGNvbG9yOiAjYzUzMDMwOwogICAgICAgICAgICBtYXJnaW46IDE1cHggMDsKICAgICAgICAgICAgZm9udC1zaXplOiAxMnB4OwogICAgICAgIH0KCiAgICAgICAgLnN1Y2Nlc3MgewogICAgICAgICAgICBiYWNrZ3JvdW5kOiAjZjBmZmY0OwogICAgICAgICAgICBib3JkZXI6IDJweCBzb2xpZCAjNjhkMzkxOwogICAgICAgICAgICBib3JkZXItcmFkaXVzOiA2cHg7CiAgICAgICAgICAgIHBhZGRpbmc6IDEycHg7CiAgICAgICAgICAgIGNvbG9yOiAjMjI1NDNkOwogICAgICAgICAgICBtYXJnaW46IDE1cHggMDsKICAgICAgICAgICAgZm9udC1zaXplOiAxMnB4OwogICAgICAgIH0KCiAgICAgICAgLyogQ09MTEFQU0lCTEUgU0VDVElPTlMgKi8KICAgICAgICAuY29sbGFwc2libGUgewogICAgICAgICAgICBjdXJzb3I6IHBvaW50ZXI7CiAgICAgICAgICAgIHVzZXItc2VsZWN0OiBub25lOwogICAgICAgICAgICBkaXNwbGF5OiBmbGV4OwogICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyOwogICAgICAgICAgICBnYXA6IDZweDsKICAgICAgICB9CgogICAgICAgIC5jb2xsYXBzaWJsZTo6YmVmb3JlIHsKICAgICAgICAgICAgY29udGVudDogJ+KWvCc7CiAgICAgICAgICAgIGZvbnQtc2l6ZTogMTBweDsKICAgICAgICAgICAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDAuM3MgZWFzZTsKICAgICAgICB9CgogICAgICAgIC5jb2xsYXBzaWJsZS5jb2xsYXBzZWQ6OmJlZm9yZSB7CiAgICAgICAgICAgIHRyYW5zZm9ybTogcm90YXRlKC05MGRlZyk7CiAgICAgICAgfQoKICAgICAgICAuY29sbGFwc2libGUtY29udGVudCB7CiAgICAgICAgICAgIG1heC1oZWlnaHQ6IDIwMDBweDsKICAgICAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjsKICAgICAgICAgICAgdHJhbnNpdGlvbjogbWF4LWhlaWdodCAwLjNzIGVhc2U7CiAgICAgICAgfQoKICAgICAgICAuY29sbGFwc2libGUtY29udGVudC5oaWRkZW4gewogICAgICAgICAgICBtYXgtaGVpZ2h0OiAwOwogICAgICAgIH0KCiAgICAgICAgLyogVE9PTFRJUCAqLwogICAgICAgIC50b29sdGlwIHsKICAgICAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlOwogICAgICAgICAgICBjdXJzb3I6IGhlbHA7CiAgICAgICAgICAgIGJvcmRlci1ib3R0b206IDFweCBkYXNoZWQgI2NiZDVlMDsKICAgICAgICB9CgogICAgICAgIC50b29sdGlwOmhvdmVyOjphZnRlciB7CiAgICAgICAgICAgIGNvbnRlbnQ6IGF0dHIoZGF0YS10b29sdGlwKTsKICAgICAgICAgICAgcG9zaXRpb246IGFic29sdXRlOwogICAgICAgICAgICBib3R0b206IDEwMCU7CiAgICAgICAgICAgIGxlZnQ6IDUwJTsKICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MCUpOwogICAgICAgICAgICBiYWNrZ3JvdW5kOiAjMmQzNzQ4OwogICAgICAgICAgICBjb2xvcjogd2hpdGU7CiAgICAgICAgICAgIHBhZGRpbmc6IDZweCAxMHB4OwogICAgICAgICAgICBib3JkZXItcmFkaXVzOiA0cHg7CiAgICAgICAgICAgIGZvbnQtc2l6ZTogMTFweDsKICAgICAgICAgICAgd2hpdGUtc3BhY2U6IG5vd3JhcDsKICAgICAgICAgICAgei1pbmRleDogMTAwMDsKICAgICAgICB9CiAgICA8L3N0eWxlPgo8L2hlYWQ+Cjxib2R5PgogICAgPGRpdiBjbGFzcz0iY29udGFpbmVyIj4KICAgICAgICA8ZGl2IGNsYXNzPSJoZWFkZXIiPgogICAgICAgICAgICA8aDE+8J+OryBXSUxMT1cgVjUwIC0gRW5oYW5jZWQgQ01BIFdvcmtiZW5jaDwvaDE+CiAgICAgICAgICAgIDxkaXYgY2xhc3M9InN1YnRpdGxlIj5BVFRPTSBJbnRlbGxpZ2VuY2UgfCBMZWFkOiA8c3BhbiBpZD0ibGVhZE5hbWUiPkxvYWRpbmcuLi48L3NwYW4+PC9kaXY+CiAgICAgICAgPC9kaXY+CgogICAgICAgIDxkaXYgY2xhc3M9IndvcmtiZW5jaCI+CiAgICAgICAgICAgIDwhLS0gU0VDVElPTiAxOiBTVUJKRUNUIFBST1BFUlRZIEFERFJFU1MgLS0+CiAgICAgICAgICAgIDxkaXYgY2xhc3M9InNlY3Rpb24tY29tcGFjdCI+CiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJzZWN0aW9uLXRpdGxlLWNvbXBhY3QiPvCfk40gU3ViamVjdCBQcm9wZXJ0eSBBZGRyZXNzPC9kaXY+CiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJmb3JtLWdyb3VwLWNvbXBhY3QiIHN0eWxlPSJncmlkLWNvbHVtbjogMSAvIC0xOyI+CiAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPSJmb3JtLWxhYmVsLWNvbXBhY3QiPkZ1bGwgQWRkcmVzcyAoQ2l0eSwgU3RhdGUsIFpJUCByZXF1aXJlZCk8L2xhYmVsPgogICAgICAgICAgICAgICAgICAgIDxpbnB1dCAKICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT0idGV4dCIgCiAgICAgICAgICAgICAgICAgICAgICAgIGlkPSJzdWJqZWN0QWRkcmVzcyIgCiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPSJmb3JtLWlucHV0LWNvbXBhY3QiIAogICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj0iMTIzIE1haW4gU3QsIFBvdWdoa2VlcHNpZSwgTlkgMTI2MDEiCiAgICAgICAgICAgICAgICAgICAgPgogICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPSJidG4gYnRuLXByaW1hcnkiIG9uY2xpY2s9ImxvYWRQcm9wZXJ0eURhdGEoKSIgc3R5bGU9Im1hcmdpbi10b3A6IDEwcHg7Ij4KICAgICAgICAgICAgICAgICAgICDwn5SNIExvYWQgQVRUT00gSW50ZWxsaWdlbmNlCiAgICAgICAgICAgICAgICA8L2J1dHRvbj4KICAgICAgICAgICAgPC9kaXY+CgogICAgICAgICAgICA8ZGl2IGlkPSJsb2FkaW5nSW5kaWNhdG9yIiBjbGFzcz0ibG9hZGluZyIgc3R5bGU9ImRpc3BsYXk6IG5vbmU7Ij4KICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InNwaW5uZXIiPjwvZGl2PgogICAgICAgICAgICAgICAgPGRpdj5Mb2FkaW5nIGNvbXBsZXRlIHByb3BlcnR5IGludGVsbGlnZW5jZSBmcm9tIEFUVE9NLi4uPC9kaXY+CiAgICAgICAgICAgIDwvZGl2PgoKICAgICAgICAgICAgPGRpdiBpZD0iZXJyb3JNZXNzYWdlIiBjbGFzcz0iZXJyb3IiIHN0eWxlPSJkaXNwbGF5OiBub25lOyI+PC9kaXY+CgogICAgICAgICAgICA8IS0tIFBST1BFUlRZIElOVEVMTElHRU5DRSBHUklEIChIaWRkZW4gdW50aWwgZGF0YSBsb2FkZWQpIC0tPgogICAgICAgICAgICA8ZGl2IGlkPSJwcm9wZXJ0eUludGVsbGlnZW5jZSIgc3R5bGU9ImRpc3BsYXk6IG5vbmU7Ij4KICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InByb3BlcnR5LWdyaWQiPgogICAgICAgICAgICAgICAgICAgIDwhLS0gTEVGVCBDT0xVTU46IEFWTSAmIFZBTFVBVElPTiAtLT4KICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJzZWN0aW9uLWNvbXBhY3QiPgogICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJhdm0taGVhZGVyIj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InNlY3Rpb24tdGl0bGUtY29tcGFjdCI+8J+SsCBBdXRvbWF0ZWQgVmFsdWF0aW9uIE1vZGVsIChBVk0pPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBpZD0iYXZtQ29uZmlkZW5jZUJhZGdlIiBjbGFzcz0iY29uZmlkZW5jZS1iYWRnZSBjb25maWRlbmNlLVVOS05PV04iPlVOS05PV048L3NwYW4+CiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PgoKICAgICAgICAgICAgICAgICAgICAgICAgPCEtLSBFRElUQUJMRSBDRU5URVIgVkFMVUUgLS0+CiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InZhbHVlLWNvbnRyb2wiPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0idmFsdWUtaW5wdXQtZ3JvdXAiPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz0idmFsdWUtaW5wdXQtbGFiZWwiPkFUVE9NIFN1Z2dlc3RlZCBWYWx1ZTwvbGFiZWw+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlPSJ0ZXh0IiAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ9ImF2bVN1Z2dlc3RlZFZhbHVlIiAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9InZhbHVlLWlucHV0IHN1Z2dlc3RlZCIgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRvbmx5CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPSIkMCIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InZhbHVlLWlucHV0LWdyb3VwIj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9InZhbHVlLWlucHV0LWxhYmVsIj5Zb3VyIENlbnRlciBWYWx1ZTwvbGFiZWw+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlPSJ0ZXh0IiAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ9ImNlbnRlclZhbHVlIiAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9InZhbHVlLWlucHV0IHVzZXItb3ZlcnJpZGUiIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj0iT3ZlcnJpZGUgaGVyZSIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25jaGFuZ2U9InVwZGF0ZUNlbnRlclZhbHVlKCkiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PgoKICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iZGF0YS1yb3ciPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9ImRhdGEtbGFiZWwiPkNvbmZpZGVuY2UgU2NvcmU8L3NwYW4+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBpZD0iYXZtU2NvcmUiIGNsYXNzPSJkYXRhLXZhbHVlIj4tLTwvc3Bhbj4KICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImRhdGEtcm93Ij4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSJkYXRhLWxhYmVsIj5WYWx1ZSBSYW5nZTwvc3Bhbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGlkPSJhdm1SYW5nZSIgY2xhc3M9ImRhdGEtdmFsdWUiPi0tPC9zcGFuPgogICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iZGF0YS1yb3ciPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9ImRhdGEtbGFiZWwiPkFWTSBEYXRlPC9zcGFuPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gaWQ9ImF2bURhdGUiIGNsYXNzPSJkYXRhLXZhbHVlIj4tLTwvc3Bhbj4KICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgPC9kaXY+CgogICAgICAgICAgICAgICAgICAgIDwhLS0gUklHSFQgQ09MVU1OOiBTQUxFUyBISVNUT1JZIC0tPgogICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InNlY3Rpb24tY29tcGFjdCI+CiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InNlY3Rpb24tdGl0bGUtY29tcGFjdCI+8J+TiCBTYWxlcyBIaXN0b3J5ICYgTWFya2V0IFZlbG9jaXR5PC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImRhdGEtcm93Ij4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSJkYXRhLWxhYmVsIj5MYXN0IFNhbGUgRGF0ZTwvc3Bhbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGlkPSJsYXN0U2FsZURhdGUiIGNsYXNzPSJkYXRhLXZhbHVlIj4tLTwvc3Bhbj4KICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImRhdGEtcm93Ij4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSJkYXRhLWxhYmVsIj5MYXN0IFNhbGUgUHJpY2U8L3NwYW4+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBpZD0ibGFzdFNhbGVQcmljZSIgY2xhc3M9ImRhdGEtdmFsdWUiPi0tPC9zcGFuPgogICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iZGF0YS1yb3ciPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9ImRhdGEtbGFiZWwiPlByaWNlL1NxRnQ8L3NwYW4+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBpZD0icHJpY2VQZXJTcWZ0IiBjbGFzcz0iZGF0YS12YWx1ZSI+LS08L3NwYW4+CiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJkYXRhLXJvdyI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0iZGF0YS1sYWJlbCI+QXBwcmVjaWF0aW9uPC9zcGFuPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gaWQ9ImFwcHJlY2lhdGlvbiIgY2xhc3M9ImRhdGEtdmFsdWUiPi0tPC9zcGFuPgogICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iZGF0YS1yb3ciPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9ImRhdGEtbGFiZWwiPk1hcmtldCBWZWxvY2l0eTwvc3Bhbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGlkPSJtYXJrZXRWZWxvY2l0eSIgY2xhc3M9ImRhdGEtdmFsdWUiPi0tPC9zcGFuPgogICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgIDwvZGl2PgoKICAgICAgICAgICAgICAgIDwhLS0gUFJPUEVSVFkgQ0hBUkFDVEVSSVNUSUNTIC0gQ09NUEFDVCAtLT4KICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InNlY3Rpb24tY29tcGFjdCIgc3R5bGU9Im1hcmdpbi1ib3R0b206IDIwcHg7Ij4KICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJzZWN0aW9uLXRpdGxlLWNvbXBhY3QiPvCfj6AgUHJvcGVydHkgQ2hhcmFjdGVyaXN0aWNzPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iY2hhci1ncmlkIj4KICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iY2hhci1pdGVtIj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgaWQ9ImNoYXJCZWRzIiBjbGFzcz0iY2hhci12YWx1ZSI+LS08L2Rpdj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImNoYXItbGFiZWwiPkJlZHM8L2Rpdj4KICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImNoYXItaXRlbSI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGlkPSJjaGFyQmF0aHMiIGNsYXNzPSJjaGFyLXZhbHVlIj4tLTwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iY2hhci1sYWJlbCI+QmF0aHM8L2Rpdj4KICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImNoYXItaXRlbSI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGlkPSJjaGFyU3FmdCIgY2xhc3M9ImNoYXItdmFsdWUiPi0tPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJjaGFyLWxhYmVsIj5TcUZ0PC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJjaGFyLWl0ZW0iPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD0iY2hhckFjcmVzIiBjbGFzcz0iY2hhci12YWx1ZSI+LS08L2Rpdj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImNoYXItbGFiZWwiPkFjcmVzPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJjaGFyLWl0ZW0iPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD0iY2hhckdhcmFnZSIgY2xhc3M9ImNoYXItdmFsdWUiPi0tPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJjaGFyLWxhYmVsIj5HYXJhZ2U8L2Rpdj4KICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImNoYXItaXRlbSI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGlkPSJjaGFyVHlwZSIgY2xhc3M9ImNoYXItdmFsdWUiPi0tPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJjaGFyLWxhYmVsIj5UeXBlPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJjaGFyLWl0ZW0iPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD0iY2hhclllYXIiIGNsYXNzPSJjaGFyLXZhbHVlIj4tLTwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iY2hhci1sYWJlbCI+QnVpbHQ8L2Rpdj4KICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImNoYXItaXRlbSI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGlkPSJjaGFyQ29uZGl0aW9uIiBjbGFzcz0iY2hhci12YWx1ZSI+LS08L2Rpdj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImNoYXItbGFiZWwiPkNvbmRpdGlvbjwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgIDwvZGl2PgoKICAgICAgICAgICAgICAgIDwhLS0gRVFVSVRZICYgT1dORVIgSU5URUxMSUdFTkNFIC0tPgogICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0icHJvcGVydHktZ3JpZCI+CiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0ic2VjdGlvbi1jb21wYWN0Ij4KICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0ic2VjdGlvbi10aXRsZS1jb21wYWN0Ij7wn5K1IEVxdWl0eSAmIE1vcnRnYWdlIEludGVsbGlnZW5jZTwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJkYXRhLXJvdyI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0iZGF0YS1sYWJlbCI+RXN0aW1hdGVkIEVxdWl0eTwvc3Bhbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGlkPSJlcXVpdHlEb2xsYXJzIiBjbGFzcz0iZGF0YS12YWx1ZSI+LS08L3NwYW4+CiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJkYXRhLXJvdyI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0iZGF0YS1sYWJlbCI+RXF1aXR5ICU8L3NwYW4+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBpZD0iZXF1aXR5UGVyY2VudCIgY2xhc3M9ImRhdGEtdmFsdWUiPi0tPC9zcGFuPgogICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iZGF0YS1yb3ciPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9ImRhdGEtbGFiZWwiPkxUViBSYXRpbzwvc3Bhbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGlkPSJsdHZSYXRpbyIgY2xhc3M9ImRhdGEtdmFsdWUiPi0tPC9zcGFuPgogICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iZGF0YS1yb3ciPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9ImRhdGEtbGFiZWwiPlN0YXR1czwvc3Bhbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGlkPSJlcXVpdHlTdGF0dXMiIGNsYXNzPSJkYXRhLXZhbHVlIj4tLTwvc3Bhbj4KICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgPC9kaXY+CgogICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InNlY3Rpb24tY29tcGFjdCI+CiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InNlY3Rpb24tdGl0bGUtY29tcGFjdCI+8J+RpCBPd25lciBJbnRlbGxpZ2VuY2U8L2Rpdj4KICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iZGF0YS1yb3ciPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9ImRhdGEtbGFiZWwiPk93bmVyIE5hbWU8L3NwYW4+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBpZD0ib3duZXJOYW1lIiBjbGFzcz0iZGF0YS12YWx1ZSI+LS08L3NwYW4+CiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJkYXRhLXJvdyI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0iZGF0YS1sYWJlbCI+T3duZXJzaGlwIFR5cGU8L3NwYW4+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBpZD0ib3duZXJUeXBlIiBjbGFzcz0iZGF0YS12YWx1ZSI+LS08L3NwYW4+CiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJkYXRhLXJvdyI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0iZGF0YS1sYWJlbCI+WWVhcnMgT3duZWQ8L3NwYW4+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBpZD0ib3duZXJzaGlwTGVuZ3RoIiBjbGFzcz0iZGF0YS12YWx1ZSI+LS08L3NwYW4+CiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGlkPSJvd25lckZsYWdzIiBjbGFzcz0icmlzay1mbGFncyIgc3R5bGU9Im1hcmdpbi10b3A6IDhweDsiPjwvZGl2PgogICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgPC9kaXY+CgogICAgICAgICAgICAgICAgPCEtLSBSSVNLICYgRU5WSVJPTk1FTlRBTCAtLT4KICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InByb3BlcnR5LWdyaWQiPgogICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InNlY3Rpb24tY29tcGFjdCI+CiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InNlY3Rpb24tdGl0bGUtY29tcGFjdCI+8J+MjSBFbnZpcm9ubWVudGFsICYgUmlzayBBc3Nlc3NtZW50PC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImRhdGEtcm93Ij4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSJkYXRhLWxhYmVsIj5GbG9vZCBab25lPC9zcGFuPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gaWQ9ImZsb29kWm9uZSIgY2xhc3M9ImRhdGEtdmFsdWUiPi0tPC9zcGFuPgogICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iZGF0YS1yb3ciPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9ImRhdGEtbGFiZWwiPkZsb29kIFJpc2s8L3NwYW4+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBpZD0iZmxvb2RSaXNrIiBjbGFzcz0iZGF0YS12YWx1ZSI+LS08L3NwYW4+CiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGlkPSJlbnZpcm9ubWVudGFsRmxhZ3MiIGNsYXNzPSJyaXNrLWZsYWdzIiBzdHlsZT0ibWFyZ2luLXRvcDogOHB4OyI+PC9kaXY+CiAgICAgICAgICAgICAgICAgICAgPC9kaXY+CgogICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InNlY3Rpb24tY29tcGFjdCI+CiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InNlY3Rpb24tdGl0bGUtY29tcGFjdCI+8J+PqyBTY2hvb2wgRGlzdHJpY3QgSW5mb3JtYXRpb248L2Rpdj4KICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iZGF0YS1yb3ciPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9ImRhdGEtbGFiZWwiPkRpc3RyaWN0PC9zcGFuPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gaWQ9InNjaG9vbERpc3RyaWN0IiBjbGFzcz0iZGF0YS12YWx1ZSI+LS08L3NwYW4+CiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJkYXRhLXJvdyI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0iZGF0YS1sYWJlbCI+RWxlbWVudGFyeTwvc3Bhbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGlkPSJzY2hvb2xFbGVtZW50YXJ5IiBjbGFzcz0iZGF0YS12YWx1ZSI+LS08L3NwYW4+CiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJkYXRhLXJvdyI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0iZGF0YS1sYWJlbCI+SGlnaCBTY2hvb2w8L3NwYW4+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBpZD0ic2Nob29sSGlnaCIgY2xhc3M9ImRhdGEtdmFsdWUiPi0tPC9zcGFuPgogICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgIDwvZGl2PgoKICAgICAgICAgICAgICAgIDwhLS0gRElTVFJFU1MgRkxBR1MgKElmIGFueSkgLS0+CiAgICAgICAgICAgICAgICA8ZGl2IGlkPSJkaXN0cmVzc1NlY3Rpb24iIGNsYXNzPSJzZWN0aW9uLWNvbXBhY3QiIHN0eWxlPSJkaXNwbGF5OiBub25lOyBtYXJnaW4tYm90dG9tOiAyMHB4OyI+CiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0ic2VjdGlvbi10aXRsZS1jb21wYWN0Ij7imqDvuI8gRGlzdHJlc3MgSW5kaWNhdG9yczwvZGl2PgogICAgICAgICAgICAgICAgICAgIDxkaXYgaWQ9ImRpc3RyZXNzRmxhZ3MiIGNsYXNzPSJyaXNrLWZsYWdzIj48L2Rpdj4KICAgICAgICAgICAgICAgICAgICA8ZGl2IGlkPSJkaXN0cmVzc0RldGFpbHMiIHN0eWxlPSJtYXJnaW4tdG9wOiAxMHB4OyBmb250LXNpemU6IDEycHg7IGNvbG9yOiAjNGE1NTY4OyI+PC9kaXY+CiAgICAgICAgICAgICAgICA8L2Rpdj4KCiAgICAgICAgICAgICAgICA8IS0tIENPTExBUFNJQkxFOiBBRERJVElPTkFMIERFVEFJTFMgLS0+CiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJzZWN0aW9uLWNvbXBhY3QiPgogICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InNlY3Rpb24tdGl0bGUtY29tcGFjdCBjb2xsYXBzaWJsZSIgb25jbGljaz0idG9nZ2xlQ29sbGFwc2libGUoJ2FkZGl0aW9uYWxEZXRhaWxzJykiPgogICAgICAgICAgICAgICAgICAgICAgICDwn5OLIEFkZGl0aW9uYWwgUHJvcGVydHkgRGV0YWlscwogICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgIDxkaXYgaWQ9ImFkZGl0aW9uYWxEZXRhaWxzIiBjbGFzcz0iY29sbGFwc2libGUtY29udGVudCI+CiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImRhdGEtcm93Ij4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSJkYXRhLWxhYmVsIj5TdG9yaWVzPC9zcGFuPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gaWQ9ImRldGFpbFN0b3JpZXMiIGNsYXNzPSJkYXRhLXZhbHVlIj4tLTwvc3Bhbj4KICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImRhdGEtcm93Ij4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSJkYXRhLWxhYmVsIj5RdWFsaXR5PC9zcGFuPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gaWQ9ImRldGFpbFF1YWxpdHkiIGNsYXNzPSJkYXRhLXZhbHVlIj4tLTwvc3Bhbj4KICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImRhdGEtcm93Ij4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSJkYXRhLWxhYmVsIj5Qb29sPC9zcGFuPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gaWQ9ImRldGFpbFBvb2wiIGNsYXNzPSJkYXRhLXZhbHVlIj4tLTwvc3Bhbj4KICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImRhdGEtcm93Ij4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSJkYXRhLWxhYmVsIj5GaXJlcGxhY2U8L3NwYW4+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBpZD0iZGV0YWlsRmlyZXBsYWNlIiBjbGFzcz0iZGF0YS12YWx1ZSI+LS08L3NwYW4+CiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJkYXRhLXJvdyI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0iZGF0YS1sYWJlbCI+SGVhdGluZzwvc3Bhbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGlkPSJkZXRhaWxIZWF0aW5nIiBjbGFzcz0iZGF0YS12YWx1ZSI+LS08L3NwYW4+CiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJkYXRhLXJvdyI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0iZGF0YS1sYWJlbCI+Q29vbGluZzwvc3Bhbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGlkPSJkZXRhaWxDb29saW5nIiBjbGFzcz0iZGF0YS12YWx1ZSI+LS08L3NwYW4+CiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJkYXRhLXJvdyI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0iZGF0YS1sYWJlbCI+VGF4IEFtb3VudDwvc3Bhbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGlkPSJkZXRhaWxUYXhBbW91bnQiIGNsYXNzPSJkYXRhLXZhbHVlIj4tLTwvc3Bhbj4KICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImRhdGEtcm93Ij4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSJkYXRhLWxhYmVsIj5UYXgvU3FGdDwvc3Bhbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGlkPSJkZXRhaWxUYXhQZXJTcWZ0IiBjbGFzcz0iZGF0YS12YWx1ZSI+LS08L3NwYW4+CiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJkYXRhLXJvdyI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0iZGF0YS1sYWJlbCI+QVRUT00gSUQ8L3NwYW4+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBpZD0iZGV0YWlsQXR0b21JZCIgY2xhc3M9ImRhdGEtdmFsdWUiPi0tPC9zcGFuPgogICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICA8L2Rpdj4KCiAgICAgICAgICAgIDwhLS0gQ01BIEdFTkVSQVRJT04gRk9STSAtLT4KICAgICAgICAgICAgPGRpdiBjbGFzcz0ic2VjdGlvbi1jb21wYWN0IiBzdHlsZT0ibWFyZ2luLXRvcDogMjBweDsiPgogICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0ic2VjdGlvbi10aXRsZS1jb21wYWN0Ij7wn5OKIEdlbmVyYXRlIENNQTwvZGl2PgogICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iZm9ybS1jb21wYWN0Ij4KICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJmb3JtLWdyb3VwLWNvbXBhY3QiPgogICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9ImZvcm0tbGFiZWwtY29tcGFjdCI+U2VhcmNoIFJhZGl1cyAobWlsZXMpPC9sYWJlbD4KICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9Im51bWJlciIgaWQ9ImNtYVJhZGl1cyIgY2xhc3M9ImZvcm0taW5wdXQtY29tcGFjdCIgdmFsdWU9IjMiIG1pbj0iMSIgbWF4PSIxMCI+CiAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iZm9ybS1ncm91cC1jb21wYWN0Ij4KICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPSJmb3JtLWxhYmVsLWNvbXBhY3QiPkRheXMgQmFjazwvbGFiZWw+CiAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPSJudW1iZXIiIGlkPSJjbWFEYXlzQmFjayIgY2xhc3M9ImZvcm0taW5wdXQtY29tcGFjdCIgdmFsdWU9IjE4MCIgbWluPSIzMCIgbWF4PSI3MzAiPgogICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImZvcm0tZ3JvdXAtY29tcGFjdCI+CiAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz0iZm9ybS1sYWJlbC1jb21wYWN0Ij5NYXggQ29tcGFyYWJsZXM8L2xhYmVsPgogICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT0ibnVtYmVyIiBpZD0iY21hTWF4Q29tcHMiIGNsYXNzPSJmb3JtLWlucHV0LWNvbXBhY3QiIHZhbHVlPSIxMCIgbWluPSIzIiBtYXg9IjIwIj4KICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJmb3JtLWdyb3VwLWNvbXBhY3QiPgogICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9ImZvcm0tbGFiZWwtY29tcGFjdCI+UHJpY2UgVmFyaWFuY2UgKCUpPC9sYWJlbD4KICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9Im51bWJlciIgaWQ9ImNtYVByaWNlVmFyaWFuY2UiIGNsYXNzPSJmb3JtLWlucHV0LWNvbXBhY3QiIHZhbHVlPSIyNSIgbWluPSIxMCIgbWF4PSI1MCI+CiAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImJ0bi1ncm91cCI+CiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz0iYnRuIGJ0bi1wcmltYXJ5IiBvbmNsaWNrPSJnZW5lcmF0ZUNNQSgpIj4KICAgICAgICAgICAgICAgICAgICAgICAg8J+TiiBHZW5lcmF0ZSBDTUEgUmVwb3J0CiAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+CiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz0iYnRuIGJ0bi1zZWNvbmRhcnkiIG9uY2xpY2s9ImV4cG9ydERhdGEoKSI+CiAgICAgICAgICAgICAgICAgICAgICAgIPCfkr4gRXhwb3J0IHRvIEZVQgogICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPgogICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgIDwvZGl2PgogICAgICAgIDwvZGl2PgogICAgPC9kaXY+CgogICAgPHNjcmlwdD4KICAgICAgICBsZXQgY3VycmVudFByb3BlcnR5RGF0YSA9IG51bGw7CiAgICAgICAgbGV0IGZ1YkNvbnRleHQgPSBudWxsOwoKICAgICAgICAvLyBJbml0aWFsaXplIEZVQiBlbWJlZGRlZCBhcHAKICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGFzeW5jIGZ1bmN0aW9uKCkgewogICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgICAgZnViQ29udGV4dCA9IGF3YWl0IEZVQi5nZXRDb250ZXh0KCk7CiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnRlVCIENvbnRleHQ6JywgZnViQ29udGV4dCk7CiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgIGlmIChmdWJDb250ZXh0ICYmIGZ1YkNvbnRleHQucGVyc29uKSB7CiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xlYWROYW1lJykudGV4dENvbnRlbnQgPSAKICAgICAgICAgICAgICAgICAgICAgICAgZnViQ29udGV4dC5wZXJzb24ubmFtZSB8fCAnVW5rbm93biBMZWFkJzsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHsKICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBsb2FkIEZVQiBjb250ZXh0OicsIGVycm9yKTsKICAgICAgICAgICAgfQogICAgICAgIH0pOwoKICAgICAgICAvLyBMb2FkIHByb3BlcnR5IGRhdGEgZnJvbSBBVFRPTSBBUEkKICAgICAgICBhc3luYyBmdW5jdGlvbiBsb2FkUHJvcGVydHlEYXRhKCkgewogICAgICAgICAgICBjb25zdCBhZGRyZXNzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N1YmplY3RBZGRyZXNzJykudmFsdWUudHJpbSgpOwogICAgICAgICAgICAKICAgICAgICAgICAgaWYgKCFhZGRyZXNzKSB7CiAgICAgICAgICAgICAgICBhbGVydCgnUGxlYXNlIGVudGVyIGEgcHJvcGVydHkgYWRkcmVzcycpOwogICAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICB9CgogICAgICAgICAgICAvLyBTaG93IGxvYWRpbmcgaW5kaWNhdG9yCiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsb2FkaW5nSW5kaWNhdG9yJykuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7CiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdlcnJvck1lc3NhZ2UnKS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnOwogICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncHJvcGVydHlJbnRlbGxpZ2VuY2UnKS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnOwoKICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICAgIGNvbnN0IHBlcnNvbklkID0gZnViQ29udGV4dD8ucGVyc29uPy5pZCB8fCBudWxsOwogICAgICAgICAgICAgICAgY29uc3QgdXJsID0gYC8ubmV0bGlmeS9mdW5jdGlvbnMvYXR0b20tcHJvcGVydHktbG9va3VwP2FkZHJlc3M9JHtlbmNvZGVVUklDb21wb25lbnQoYWRkcmVzcyl9JHtwZXJzb25JZCA/ICcmcGVyc29uSWQ9JyArIHBlcnNvbklkIDogJyd9YDsKICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwpOwogICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpOwoKICAgICAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2sgfHwgIXJlc3VsdC5zdWNjZXNzKSB7CiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3VsdC5tZXNzYWdlIHx8ICdGYWlsZWQgdG8gbG9hZCBwcm9wZXJ0eSBkYXRhJyk7CiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgY3VycmVudFByb3BlcnR5RGF0YSA9IHJlc3VsdC5kYXRhOwogICAgICAgICAgICAgICAgZGlzcGxheVByb3BlcnR5RGF0YShjdXJyZW50UHJvcGVydHlEYXRhKTsKCiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbG9hZGluZ0luZGljYXRvcicpLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7CiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncHJvcGVydHlJbnRlbGxpZ2VuY2UnKS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJzsKCiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7CiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIHByb3BlcnR5IGRhdGE6JywgZXJyb3IpOwogICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xvYWRpbmdJbmRpY2F0b3InKS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnOwogICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Vycm9yTWVzc2FnZScpLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snOwogICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Vycm9yTWVzc2FnZScpLnRleHRDb250ZW50ID0gCiAgICAgICAgICAgICAgICAgICAgJ0Vycm9yIGxvYWRpbmcgcHJvcGVydHkgZGF0YTogJyArIGVycm9yLm1lc3NhZ2U7CiAgICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIC8vIERpc3BsYXkgcHJvcGVydHkgZGF0YSBpbiBVSQogICAgICAgIGZ1bmN0aW9uIGRpc3BsYXlQcm9wZXJ0eURhdGEoZGF0YSkgewogICAgICAgICAgICAvLyBBVk0gU2VjdGlvbgogICAgICAgICAgICBpZiAoZGF0YS5hdm0pIHsKICAgICAgICAgICAgICAgIGNvbnN0IHN1Z2dlc3RlZFZhbHVlID0gZGF0YS5hdm0udmFsdWUgfHwgMDsKICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhdm1TdWdnZXN0ZWRWYWx1ZScpLnZhbHVlID0gZm9ybWF0Q3VycmVuY3koc3VnZ2VzdGVkVmFsdWUpOwogICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NlbnRlclZhbHVlJykudmFsdWUgPSBmb3JtYXRDdXJyZW5jeShzdWdnZXN0ZWRWYWx1ZSk7CiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2VudGVyVmFsdWUnKS5wbGFjZWhvbGRlciA9IGZvcm1hdEN1cnJlbmN5KHN1Z2dlc3RlZFZhbHVlKTsKICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2F2bVNjb3JlJykudGV4dENvbnRlbnQgPSBkYXRhLmF2bS5jb25maWRlbmNlU2NvcmUgfHwgJy0tJzsKICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhdm1Db25maWRlbmNlQmFkZ2UnKS50ZXh0Q29udGVudCA9IGRhdGEuYXZtLmNvbmZpZGVuY2VMZXZlbCB8fCAnVU5LTk9XTic7CiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYXZtQ29uZmlkZW5jZUJhZGdlJykuY2xhc3NOYW1lID0gCiAgICAgICAgICAgICAgICAgICAgJ2NvbmZpZGVuY2UtYmFkZ2UgY29uZmlkZW5jZS0nICsgKGRhdGEuYXZtLmNvbmZpZGVuY2VMZXZlbCB8fCAnVU5LTk9XTicpOwogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYXZtUmFuZ2UnKS50ZXh0Q29udGVudCA9IAogICAgICAgICAgICAgICAgICAgIGAke2Zvcm1hdEN1cnJlbmN5KGRhdGEuYXZtLnZhbHVlTG93KX0gLSAke2Zvcm1hdEN1cnJlbmN5KGRhdGEuYXZtLnZhbHVlSGlnaCl9YDsKICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhdm1EYXRlJykudGV4dENvbnRlbnQgPSAKICAgICAgICAgICAgICAgICAgICBkYXRhLmF2bS5kYXRlID8gbmV3IERhdGUoZGF0YS5hdm0uZGF0ZSkudG9Mb2NhbGVEYXRlU3RyaW5nKCkgOiAnLS0nOwogICAgICAgICAgICB9CgogICAgICAgICAgICAvLyBTYWxlcyBIaXN0b3J5CiAgICAgICAgICAgIGlmIChkYXRhLnNhbGVIaXN0b3J5KSB7CiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbGFzdFNhbGVEYXRlJykudGV4dENvbnRlbnQgPSAKICAgICAgICAgICAgICAgICAgICBkYXRhLnNhbGVIaXN0b3J5Lmxhc3RTYWxlRGF0ZSA/IG5ldyBEYXRlKGRhdGEuc2FsZUhpc3RvcnkubGFzdFNhbGVEYXRlKS50b0xvY2FsZURhdGVTdHJpbmcoKSA6ICctLSc7CiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbGFzdFNhbGVQcmljZScpLnRleHRDb250ZW50ID0gCiAgICAgICAgICAgICAgICAgICAgZm9ybWF0Q3VycmVuY3koZGF0YS5zYWxlSGlzdG9yeS5sYXN0U2FsZVByaWNlKTsKICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwcmljZVBlclNxZnQnKS50ZXh0Q29udGVudCA9IAogICAgICAgICAgICAgICAgICAgIGRhdGEuc2FsZUhpc3RvcnkucHJpY2VQZXJTcWZ0ID8gJyQnICsgZGF0YS5zYWxlSGlzdG9yeS5wcmljZVBlclNxZnQgOiAnLS0nOwogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICBpZiAoZGF0YS5zYWxlSGlzdG9yeS5hcHByZWNpYXRpb24pIHsKICAgICAgICAgICAgICAgICAgICBjb25zdCBhcHBEb2xsYXJzID0gZGF0YS5zYWxlSGlzdG9yeS5hcHByZWNpYXRpb24uZG9sbGFyczsKICAgICAgICAgICAgICAgICAgICBjb25zdCBhcHBQZXJjZW50ID0gZGF0YS5zYWxlSGlzdG9yeS5hcHByZWNpYXRpb24ucGVyY2VudGFnZTsKICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYXBwcmVjaWF0aW9uJykuaW5uZXJIVE1MID0gCiAgICAgICAgICAgICAgICAgICAgICAgIGA8c3BhbiBjbGFzcz0iJHthcHBEb2xsYXJzID49IDAgPyAnc3VjY2VzcycgOiAnZGFuZ2VyJ30iPiR7Zm9ybWF0Q3VycmVuY3koYXBwRG9sbGFycyl9ICgke2FwcFBlcmNlbnR9JSk8L3NwYW4+YDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgY29uc3QgdmVsb2NpdHkgPSBkYXRhLnNhbGVIaXN0b3J5Lm1hcmtldFZlbG9jaXR5IHx8ICdVTktOT1dOJzsKICAgICAgICAgICAgICAgIGNvbnN0IHZlbG9jaXR5Q2xhc3MgPSB2ZWxvY2l0eSA9PT0gJ0hPVCcgPyAnZGFuZ2VyJyA6IHZlbG9jaXR5ID09PSAnV0FSTScgPyAnd2FybmluZycgOiAnaGlnaGxpZ2h0JzsKICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtYXJrZXRWZWxvY2l0eScpLmlubmVySFRNTCA9IAogICAgICAgICAgICAgICAgICAgIGA8c3BhbiBjbGFzcz0iJHt2ZWxvY2l0eUNsYXNzfSI+JHt2ZWxvY2l0eX08L3NwYW4+YDsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgLy8gUHJvcGVydHkgQ2hhcmFjdGVyaXN0aWNzCiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjaGFyQmVkcycpLnRleHRDb250ZW50ID0gZGF0YS5iZWRzIHx8ICctLSc7CiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjaGFyQmF0aHMnKS50ZXh0Q29udGVudCA9IGRhdGEuYmF0aHMgfHwgJy0tJzsKICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NoYXJTcWZ0JykudGV4dENvbnRlbnQgPSBkYXRhLnNxZnQgPyBkYXRhLnNxZnQudG9Mb2NhbGVTdHJpbmcoKSA6ICctLSc7CiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjaGFyQWNyZXMnKS50ZXh0Q29udGVudCA9IGRhdGEuYWNyZXMgfHwgJy0tJzsKICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NoYXJHYXJhZ2UnKS50ZXh0Q29udGVudCA9IGRhdGEuZ2FyYWdlIHx8ICctLSc7CiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjaGFyVHlwZScpLnRleHRDb250ZW50ID0gZGF0YS5wcm9wZXJ0eVR5cGUgfHwgJy0tJzsKICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NoYXJZZWFyJykudGV4dENvbnRlbnQgPSBkYXRhLnllYXJCdWlsdCB8fCAnLS0nOwogICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2hhckNvbmRpdGlvbicpLnRleHRDb250ZW50ID0gZGF0YS5jb25kaXRpb24gfHwgJy0tJzsKCiAgICAgICAgICAgIC8vIEVxdWl0eQogICAgICAgICAgICBpZiAoZGF0YS5lcXVpdHkpIHsKICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdlcXVpdHlEb2xsYXJzJykudGV4dENvbnRlbnQgPSBmb3JtYXRDdXJyZW5jeShkYXRhLmVxdWl0eS5lcXVpdHlEb2xsYXJzKTsKICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdlcXVpdHlQZXJjZW50JykudGV4dENvbnRlbnQgPSAKICAgICAgICAgICAgICAgICAgICBkYXRhLmVxdWl0eS5lcXVpdHlQZXJjZW50YWdlID8gZGF0YS5lcXVpdHkuZXF1aXR5UGVyY2VudGFnZSArICclJyA6ICctLSc7CiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbHR2UmF0aW8nKS50ZXh0Q29udGVudCA9IAogICAgICAgICAgICAgICAgICAgIGRhdGEuZXF1aXR5Lmx0dlJhdGlvID8gZGF0YS5lcXVpdHkubHR2UmF0aW8gKyAnJScgOiAnLS0nOwogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICBjb25zdCBzdGF0dXMgPSBkYXRhLmVxdWl0eS5pc1VuZGVyd2F0ZXIgPyAnVU5ERVJXQVRFUicgOiAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuZXF1aXR5Lmhhc0VxdWl0eSA/ICdQT1NJVElWRSBFUVVJVFknIDogJ1VOS05PV04nOwogICAgICAgICAgICAgICAgY29uc3Qgc3RhdHVzQ2xhc3MgPSBkYXRhLmVxdWl0eS5pc1VuZGVyd2F0ZXIgPyAnZGFuZ2VyJyA6IAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5lcXVpdHkuaGFzRXF1aXR5ID8gJ3N1Y2Nlc3MnIDogJyc7CiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZXF1aXR5U3RhdHVzJykuaW5uZXJIVE1MID0gCiAgICAgICAgICAgICAgICAgICAgYDxzcGFuIGNsYXNzPSIke3N0YXR1c0NsYXNzfSI+JHtzdGF0dXN9PC9zcGFuPmA7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIC8vIE93bmVyIEludGVsbGlnZW5jZQogICAgICAgICAgICBpZiAoZGF0YS5vd25lcikgewogICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ293bmVyTmFtZScpLnRleHRDb250ZW50ID0gZGF0YS5vd25lci5uYW1lIHx8ICctLSc7CiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnb3duZXJUeXBlJykudGV4dENvbnRlbnQgPSBkYXRhLm93bmVyLm93bmVyc2hpcFR5cGUgfHwgJy0tJzsKICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdvd25lcnNoaXBMZW5ndGgnKS50ZXh0Q29udGVudCA9IAogICAgICAgICAgICAgICAgICAgIGRhdGEub3duZXIub3duZXJzaGlwTGVuZ3RoID8gZGF0YS5vd25lci5vd25lcnNoaXBMZW5ndGggKyAnIHllYXJzJyA6ICctLSc7CiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgIGNvbnN0IG93bmVyRmxhZ3NFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdvd25lckZsYWdzJyk7CiAgICAgICAgICAgICAgICBvd25lckZsYWdzRWwuaW5uZXJIVE1MID0gJyc7CiAgICAgICAgICAgICAgICBpZiAoZGF0YS5vd25lci5pc0Fic2VudGVlKSB7CiAgICAgICAgICAgICAgICAgICAgb3duZXJGbGFnc0VsLmlubmVySFRNTCArPSAnPHNwYW4gY2xhc3M9InJpc2stZmxhZyBmbGFnLXdhcm5pbmciPkFCU0VOVEVFIE9XTkVSPC9zcGFuPic7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoZGF0YS5vd25lci5pc0NvcnBvcmF0ZU93bmVkKSB7CiAgICAgICAgICAgICAgICAgICAgb3duZXJGbGFnc0VsLmlubmVySFRNTCArPSAnPHNwYW4gY2xhc3M9InJpc2stZmxhZyBmbGFnLWluZm8iPkNPUlBPUkFURSBPV05FRDwvc3Bhbj4nOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CgogICAgICAgICAgICAvLyBFbnZpcm9ubWVudGFsCiAgICAgICAgICAgIGlmIChkYXRhLmVudmlyb25tZW50YWwpIHsKICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmbG9vZFpvbmUnKS50ZXh0Q29udGVudCA9IGRhdGEuZW52aXJvbm1lbnRhbC5mbG9vZFpvbmUgfHwgJy0tJzsKICAgICAgICAgICAgICAgIGNvbnN0IGZsb29kUmlzayA9IGRhdGEuZW52aXJvbm1lbnRhbC5mbG9vZFJpc2sgfHwgJ1VOS05PV04nOwogICAgICAgICAgICAgICAgY29uc3Qgcmlza0NsYXNzID0gZmxvb2RSaXNrID09PSAnSElHSCcgPyAnZGFuZ2VyJyA6IGZsb29kUmlzayA9PT0gJ01PREVSQVRFJyA/ICd3YXJuaW5nJyA6ICdzdWNjZXNzJzsKICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmbG9vZFJpc2snKS5pbm5lckhUTUwgPSAKICAgICAgICAgICAgICAgICAgICBgPHNwYW4gY2xhc3M9IiR7cmlza0NsYXNzfSI+JHtmbG9vZFJpc2t9PC9zcGFuPmA7CiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgIGNvbnN0IGVudkZsYWdzRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZW52aXJvbm1lbnRhbEZsYWdzJyk7CiAgICAgICAgICAgICAgICBlbnZGbGFnc0VsLmlubmVySFRNTCA9ICcnOwogICAgICAgICAgICAgICAgaWYgKGZsb29kUmlzayA9PT0gJ0hJR0gnKSB7CiAgICAgICAgICAgICAgICAgICAgZW52RmxhZ3NFbC5pbm5lckhUTUwgKz0gJzxzcGFuIGNsYXNzPSJyaXNrLWZsYWcgZmxhZy1kYW5nZXIiPkhJR0ggRkxPT0QgUklTSzwvc3Bhbj4nOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CgogICAgICAgICAgICAvLyBTY2hvb2xzCiAgICAgICAgICAgIGlmIChkYXRhLnNjaG9vbHMpIHsKICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzY2hvb2xEaXN0cmljdCcpLnRleHRDb250ZW50ID0gZGF0YS5zY2hvb2xzLmRpc3RyaWN0IHx8ICctLSc7CiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2Nob29sRWxlbWVudGFyeScpLnRleHRDb250ZW50ID0gZGF0YS5zY2hvb2xzLmVsZW1lbnRhcnlTY2hvb2wgfHwgJy0tJzsKICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzY2hvb2xIaWdoJykudGV4dENvbnRlbnQgPSBkYXRhLnNjaG9vbHMuaGlnaFNjaG9vbCB8fCAnLS0nOwogICAgICAgICAgICB9CgogICAgICAgICAgICAvLyBEaXN0cmVzcyBJbmRpY2F0b3JzCiAgICAgICAgICAgIGlmIChkYXRhLmRpc3RyZXNzICYmIChkYXRhLmRpc3RyZXNzLmlzSW5Gb3JlY2xvc3VyZSB8fCBkYXRhLmRpc3RyZXNzLmlzUkVPKSkgewogICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Rpc3RyZXNzU2VjdGlvbicpLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snOwogICAgICAgICAgICAgICAgY29uc3QgZGlzdHJlc3NGbGFnc0VsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Rpc3RyZXNzRmxhZ3MnKTsKICAgICAgICAgICAgICAgIGRpc3RyZXNzRmxhZ3NFbC5pbm5lckhUTUwgPSAnJzsKICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgaWYgKGRhdGEuZGlzdHJlc3MuaXNJbkZvcmVjbG9zdXJlKSB7CiAgICAgICAgICAgICAgICAgICAgZGlzdHJlc3NGbGFnc0VsLmlubmVySFRNTCArPSAnPHNwYW4gY2xhc3M9InJpc2stZmxhZyBmbGFnLWRhbmdlciI+SU4gRk9SRUNMT1NVUkU8L3NwYW4+JzsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChkYXRhLmRpc3RyZXNzLmlzUkVPKSB7CiAgICAgICAgICAgICAgICAgICAgZGlzdHJlc3NGbGFnc0VsLmlubmVySFRNTCArPSAnPHNwYW4gY2xhc3M9InJpc2stZmxhZyBmbGFnLWRhbmdlciI+UkVPIFBST1BFUlRZPC9zcGFuPic7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgIGxldCBkZXRhaWxzID0gJyc7CiAgICAgICAgICAgICAgICBpZiAoZGF0YS5kaXN0cmVzcy5mb3JlY2xvc3VyZURhdGUpIHsKICAgICAgICAgICAgICAgICAgICBkZXRhaWxzICs9IGBGb3JlY2xvc3VyZSBEYXRlOiAke25ldyBEYXRlKGRhdGEuZGlzdHJlc3MuZm9yZWNsb3N1cmVEYXRlKS50b0xvY2FsZURhdGVTdHJpbmcoKX08YnI+YDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChkYXRhLmRpc3RyZXNzLmF1Y3Rpb25EYXRlKSB7CiAgICAgICAgICAgICAgICAgICAgZGV0YWlscyArPSBgQXVjdGlvbiBEYXRlOiAke25ldyBEYXRlKGRhdGEuZGlzdHJlc3MuYXVjdGlvbkRhdGUpLnRvTG9jYWxlRGF0ZVN0cmluZygpfTxicj5gOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Rpc3RyZXNzRGV0YWlscycpLmlubmVySFRNTCA9IGRldGFpbHM7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIC8vIEFkZGl0aW9uYWwgRGV0YWlscwogICAgICAgICAgICBpZiAoZGF0YS5idWlsZGluZykgewogICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RldGFpbFN0b3JpZXMnKS50ZXh0Q29udGVudCA9IGRhdGEuYnVpbGRpbmcuc3RvcmllcyB8fCAnLS0nOwogICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RldGFpbFF1YWxpdHknKS50ZXh0Q29udGVudCA9IGRhdGEuYnVpbGRpbmcucXVhbGl0eSB8fCAnLS0nOwogICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RldGFpbFBvb2wnKS50ZXh0Q29udGVudCA9IGRhdGEuYnVpbGRpbmcucG9vbCA/ICdZZXMnIDogJ05vJzsKICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkZXRhaWxGaXJlcGxhY2UnKS50ZXh0Q29udGVudCA9IGRhdGEuYnVpbGRpbmcuZmlyZXBsYWNlID8gJ1llcycgOiAnTm8nOwogICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RldGFpbEhlYXRpbmcnKS50ZXh0Q29udGVudCA9IGRhdGEuYnVpbGRpbmcuaGVhdGluZyB8fCAnLS0nOwogICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RldGFpbENvb2xpbmcnKS50ZXh0Q29udGVudCA9IGRhdGEuYnVpbGRpbmcuY29vbGluZyB8fCAnLS0nOwogICAgICAgICAgICB9CiAgICAgICAgICAgIAogICAgICAgICAgICBpZiAoZGF0YS5hc3Nlc3NtZW50KSB7CiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGV0YWlsVGF4QW1vdW50JykudGV4dENvbnRlbnQgPSBmb3JtYXRDdXJyZW5jeShkYXRhLmFzc2Vzc21lbnQudGF4QW1vdW50KTsKICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkZXRhaWxUYXhQZXJTcWZ0JykudGV4dENvbnRlbnQgPSAKICAgICAgICAgICAgICAgICAgICBkYXRhLmFzc2Vzc21lbnQudGF4UGVyU3FmdCA/ICckJyArIGRhdGEuYXNzZXNzbWVudC50YXhQZXJTcWZ0IDogJy0tJzsKICAgICAgICAgICAgfQogICAgICAgICAgICAKICAgICAgICAgICAgaWYgKGRhdGEubWV0YWRhdGEpIHsKICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkZXRhaWxBdHRvbUlkJykudGV4dENvbnRlbnQgPSBkYXRhLm1ldGFkYXRhLmF0dG9tSWQgfHwgJy0tJzsKICAgICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgLy8gRm9ybWF0IGN1cnJlbmN5CiAgICAgICAgZnVuY3Rpb24gZm9ybWF0Q3VycmVuY3kodmFsdWUpIHsKICAgICAgICAgICAgaWYgKCF2YWx1ZSAmJiB2YWx1ZSAhPT0gMCkgcmV0dXJuICctLSc7CiAgICAgICAgICAgIHJldHVybiAnJCcgKyBNYXRoLnJvdW5kKHZhbHVlKS50b0xvY2FsZVN0cmluZygpOwogICAgICAgIH0KCiAgICAgICAgLy8gVXBkYXRlIGNlbnRlciB2YWx1ZSB3aGVuIHVzZXIgZWRpdHMKICAgICAgICBmdW5jdGlvbiB1cGRhdGVDZW50ZXJWYWx1ZSgpIHsKICAgICAgICAgICAgY29uc3QgaW5wdXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2VudGVyVmFsdWUnKTsKICAgICAgICAgICAgaW5wdXQuY2xhc3NMaXN0LmFkZCgndXNlci1vdmVycmlkZScpOwogICAgICAgICAgICBjb25zb2xlLmxvZygnQ2VudGVyIHZhbHVlIHVwZGF0ZWQgYnkgdXNlcjonLCBpbnB1dC52YWx1ZSk7CiAgICAgICAgfQoKICAgICAgICAvLyBUb2dnbGUgY29sbGFwc2libGUgc2VjdGlvbnMKICAgICAgICBmdW5jdGlvbiB0b2dnbGVDb2xsYXBzaWJsZShpZCkgewogICAgICAgICAgICBjb25zdCBjb250ZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpOwogICAgICAgICAgICBjb25zdCB0cmlnZ2VyID0gY29udGVudC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nOwogICAgICAgICAgICAKICAgICAgICAgICAgY29udGVudC5jbGFzc0xpc3QudG9nZ2xlKCdoaWRkZW4nKTsKICAgICAgICAgICAgdHJpZ2dlci5jbGFzc0xpc3QudG9nZ2xlKCdjb2xsYXBzZWQnKTsKICAgICAgICB9CgogICAgICAgIC8vIEdlbmVyYXRlIENNQSAocGxhY2Vob2xkZXIpCiAgICAgICAgZnVuY3Rpb24gZ2VuZXJhdGVDTUEoKSB7CiAgICAgICAgICAgIGlmICghY3VycmVudFByb3BlcnR5RGF0YSkgewogICAgICAgICAgICAgICAgYWxlcnQoJ1BsZWFzZSBsb2FkIHByb3BlcnR5IGRhdGEgZmlyc3QnKTsKICAgICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgfQogICAgICAgICAgICAKICAgICAgICAgICAgY29uc3QgY2VudGVyVmFsdWUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2VudGVyVmFsdWUnKS52YWx1ZTsKICAgICAgICAgICAgY29uc3QgcmFkaXVzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NtYVJhZGl1cycpLnZhbHVlOwogICAgICAgICAgICBjb25zdCBkYXlzQmFjayA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjbWFEYXlzQmFjaycpLnZhbHVlOwogICAgICAgICAgICAKICAgICAgICAgICAgYWxlcnQoYENNQSBHZW5lcmF0aW9uXG5cbkNlbnRlciBWYWx1ZTogJHtjZW50ZXJWYWx1ZX1cblJhZGl1czogJHtyYWRpdXN9IG1pbGVzXG5EYXlzIEJhY2s6ICR7ZGF5c0JhY2t9XG5cblRoaXMgd2lsbCBpbnRlZ3JhdGUgd2l0aCB5b3VyIGV4aXN0aW5nIENNQSBnZW5lcmF0aW9uIHdvcmtmbG93LmApOwogICAgICAgIH0KCiAgICAgICAgLy8gRXhwb3J0IHRvIEZVQiAocGxhY2Vob2xkZXIpCiAgICAgICAgZnVuY3Rpb24gZXhwb3J0RGF0YSgpIHsKICAgICAgICAgICAgaWYgKCFjdXJyZW50UHJvcGVydHlEYXRhKSB7CiAgICAgICAgICAgICAgICBhbGVydCgnUGxlYXNlIGxvYWQgcHJvcGVydHkgZGF0YSBmaXJzdCcpOwogICAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICB9CiAgICAgICAgICAgIAogICAgICAgICAgICBhbGVydCgnUHJvcGVydHkgZGF0YSB3aWxsIGJlIGV4cG9ydGVkIHRvIEZVQiBjdXN0b20gZmllbGRzLicpOwogICAgICAgIH0KICAgIDwvc2NyaXB0Pgo8L2JvZHk+CjwvaHRtbD4K';
            const html = Buffer.from(htmlBase64, 'base64').toString('utf8');
            
            return {
                statusCode: 200,
                headers: {
                    'Content-Type': 'text/html',
                    'Access-Control-Allow-Origin': '*'
                },
                body: html
            };
        }

        // Route to appropriate API handler
        switch (action) {
            case 'getPersonData':
                return await getPersonData(params.personId, headers);
            
            case 'generateCMA':
                return await generateCMA(params, headers);
            
            case 'getHomebeatData':
                return await getHomebeatData(params.personId, headers);
            
            case 'resendHomebeat':
                return await resendHomebeat(params, headers);
            
            case 'createTask':
                return await createTask(params, headers);
            
            case 'createManualAction':
                return await createManualAction(params, headers);
            
            default:
                return {
                    statusCode: 400,
                    headers,
                    body: JSON.stringify({ error: 'Invalid action' })
                };
        }

    } catch (error) {
        console.error('Function error:', error);
        return {
            statusCode: 500,
            headers,
            body: JSON.stringify({ error: error.message })
        };
    }
};

// Get person data from FUB
async function getPersonData(personId, headers) {
    try {
        const personData = await fubAPIRequest('GET', `/v1/people/${personId}`);
        
        return {
            statusCode: 200,
            headers,
            body: JSON.stringify(personData)
        };
    } catch (error) {
        return {
            statusCode: 500,
            headers,
            body: JSON.stringify({ error: 'Failed to fetch person data: ' + error.message })
        };
    }
}

// Generate CMA with CloudCMA API
async function generateCMA(params, headers) {
    try {
        const {
            personId,
            address,
            beds,
            baths,
            sqft,
            radius,
            monthsBack,
            minListings,
            propType,
            title,
            createHomebeat,
            homebeatFrequency
        } = params;

        // Get person data for lead info
        const personData = await fubAPIRequest('GET', `/v1/people/${personId}`);

        // Build CMA URL
        const cmaParams = new URLSearchParams({
            api_key: CLOUDCMA_API_KEY,
            address: address,
            beds: beds || '',
            baths: baths || '',
            sqft: sqft || '',
            radius: radius || '0.75',
            months_back: monthsBack || '9',
            min_listings: minListings || '10',
            prop_type: propType || '',
            title: title || `${personData.name || 'Client'} - ${address}`,
            callback_url: WEBHOOK_URL
        });

        const cmaUrl = `https://cloudcma.com/cmas/new?${cmaParams.toString()}`;

        // Update FUB custom fields
        const updatePayload = {
            customWILLOWCMADate: new Date().toISOString(),
            customWILLOWCMAAddress: address,
            customWILLOWCMALink: cmaUrl
        };

        await fubAPIRequest('PUT', `/v1/people/${personId}`, updatePayload);

        // Create FUB activity
        await fubAPIRequest('POST', '/v1/events', {
            person_id: parseInt(personId),
            type: 'Note',
            body: `CMA generated for ${address}. Parameters: ${beds}bd/${baths}ba, ${sqft}sqft, ${radius}mi radius, ${monthsBack}mo back.`
        });

        let homebeatUrl = null;
        let homebeatCreated = false;

        // Create Homebeat if requested
        if (createHomebeat === true || createHomebeat === 'true') {
            try {
                const homebeatPayload = {
                    automation: {
                        api_key: CLOUDCMA_API_KEY,
                        frequency: homebeatFrequency || 'quarterly',
                        welcome_email: 'true',
                        report: {
                            prop_type: propType || null,
                            callback_url: null
                        },
                        subject_property: {
                            address: address,
                            sqft: sqft || null,
                            beds: beds || null,
                            baths: baths || null
                        },
                        lead: {
                            name: personData.name || '',
                            email_address: personData.emails?.[0]?.value || '',
                            phone: personData.phones?.[0]?.value || ''
                        }
                    }
                };

                const homebeatResponse = await cloudCMAAPIRequest('POST', '/homebeats/widget', homebeatPayload);
                homebeatCreated = true;
                homebeatUrl = homebeatResponse.homebeat_url || null;

                // Update FUB with Homebeat info
                await fubAPIRequest('PUT', `/v1/people/${personId}`, {
                    customWILLOWCloudCMAHomeBeatURL: homebeatUrl,
                    customWILLOWHomebeatFirstSendDate: new Date().toISOString()
                });

                // Create FUB activity for Homebeat
                await fubAPIRequest('POST', '/v1/events', {
                    person_id: parseInt(personId),
                    type: 'Note',
                    body: `Homebeat subscription created for ${address}. Frequency: ${homebeatFrequency}. Lead will receive automated market updates.`
                });

            } catch (homebeatError) {
                console.error('Homebeat creation failed:', homebeatError);
            }
        }

        return {
            statusCode: 200,
            headers,
            body: JSON.stringify({
                success: true,
                cmaUrl: cmaUrl,
                homebeatCreated: homebeatCreated,
                homebeatUrl: homebeatUrl
            })
        };

    } catch (error) {
        return {
            statusCode: 500,
            headers,
            body: JSON.stringify({ error: 'Failed to generate CMA: ' + error.message })
        };
    }
}

// Get Homebeat data from CloudCMA
async function getHomebeatData(personId, headers) {
    try {
        // Try to fetch homebeat data, but gracefully handle CloudCMA auth failures
        let homebeatReport = [];
        try {
            homebeatReport = await cloudCMAAPIRequest('GET', `/homebeats/report?api_key=${CLOUDCMA_API_KEY}&format=json`);
        } catch (cloudCMAError) {
            console.warn('CloudCMA API unavailable:', cloudCMAError.message);
            // Return empty homebeats array instead of failing
            return {
                statusCode: 200,
                headers,
                body: JSON.stringify({ 
                    homebeats: [],
                    warning: 'CloudCMA API unavailable. Check API key configuration.'
                })
            };
        }

        const personData = await fubAPIRequest('GET', `/v1/people/${personId}`);
        const personEmail = personData.emails?.[0]?.value?.toLowerCase();

        if (!personEmail) {
            return {
                statusCode: 200,
                headers,
                body: JSON.stringify({ homebeats: [] })
            };
        }

        const leadHomebeats = (homebeatReport || []).filter(hb => 
            hb.lead_email?.toLowerCase() === personEmail
        );

        const enrichedHomebeats = leadHomebeats.map(hb => ({
            ...hb,
            first_send_date: personData.customWILLOWHomebeatFirstSendDate || hb.created_at,
            status: (hb.total_views || 0) === 0 ? 'pending' : 'active'
        }));

        if (enrichedHomebeats.length > 0) {
            const totalViews = enrichedHomebeats.reduce((sum, hb) => sum + (hb.total_views || 0), 0);
            const latestView = enrichedHomebeats
                .map(hb => hb.last_view)
                .filter(v => v)
                .sort()
                .reverse()[0];

            await fubAPIRequest('PUT', `/v1/people/${personId}`, {
                customWILLOWHomebeatViews: totalViews,
                customWILLOWHomebeatLastView: latestView || null
            });
        }

        return {
            statusCode: 200,
            headers,
            body: JSON.stringify({ homebeats: enrichedHomebeats })
        };

    } catch (error) {
        return {
            statusCode: 500,
            headers,
            body: JSON.stringify({ error: 'Failed to fetch Homebeat data: ' + error.message })
        };
    }
}

// Resend Homebeat
async function resendHomebeat(params, headers) {
    try {
        const { homebeatId, personId } = params;

        const personData = await fubAPIRequest('GET', `/v1/people/${personId}`);
        
        const homebeatReport = await cloudCMAAPIRequest('GET', `/homebeats/report?api_key=${CLOUDCMA_API_KEY}&format=json`);
        const homebeat = (homebeatReport || []).find(hb => hb.id === homebeatId);

        if (!homebeat) {
            throw new Error('Homebeat not found');
        }

        const homebeatPayload = {
            automation: {
                api_key: CLOUDCMA_API_KEY,
                frequency: homebeat.frequency || 'quarterly',
                welcome_email: 'true',
                subject_property: {
                    address: homebeat.property_address,
                    sqft: homebeat.sqft || null,
                    beds: homebeat.beds || null,
                    baths: homebeat.baths || null
                },
                lead: {
                    name: personData.name || '',
                    email_address: personData.emails?.[0]?.value || '',
                    phone: personData.phones?.[0]?.value || ''
                }
            }
        };

        await cloudCMAAPIRequest('POST', '/homebeats/widget', homebeatPayload);

        await fubAPIRequest('PUT', `/v1/people/${personId}`, {
            customWILLOWHomebeatLastResend: new Date().toISOString()
        });

        await fubAPIRequest('POST', '/v1/events', {
            person_id: parseInt(personId),
            type: 'Note',
            body: `Homebeat resent for ${homebeat.property_address}. Status was pending (0 views). Manual resend triggered.`
        });

        return {
            statusCode: 200,
            headers,
            body: JSON.stringify({ success: true })
        };

    } catch (error) {
        return {
            statusCode: 500,
            headers,
            body: JSON.stringify({ error: 'Failed to resend Homebeat: ' + error.message })
        };
    }
}

// Create task in FUB
async function createTask(params, headers) {
    try {
        const { personId, taskDescription, urgency, assignedTo } = params;

        const now = new Date();
        let dueDate = new Date(now);
        
        switch (urgency) {
            case 'IMMEDIATE':
                dueDate.setHours(now.getHours() + 24);
                break;
            case 'SAME_DAY':
                dueDate.setHours(23, 59, 59);
                break;
            case 'NEXT_DAY':
                dueDate.setDate(now.getDate() + 1);
                break;
            case 'WEEKLY':
                dueDate.setDate(now.getDate() + 7);
                break;
            default:
                dueDate.setDate(now.getDate() + 1);
        }

        // FUB tasks API doesn't accept description/body field
        // Task details should be added as a note after task creation
        const taskPayload = {
            personId: parseInt(personId),
            type: 'Follow Up',
            dueDate: dueDate.toISOString()
        };

        const taskResult = await fubAPIRequest('POST', '/v1/tasks', taskPayload);
        
        // Add task details as a note
        const notePayload = {
            personId: parseInt(personId),
            subject: `Task: ${taskDescription}`,
            body: `${taskDescription}\n\nAssigned to: ${assignedTo}\nUrgency: ${urgency}\nDue: ${dueDate.toLocaleDateString()}`,
            isHtml: false
        };
        await fubAPIRequest('POST', '/v1/notes', notePayload);

        return {
            statusCode: 200,
            headers,
            body: JSON.stringify({ success: true })
        };

    } catch (error) {
        return {
            statusCode: 500,
            headers,
            body: JSON.stringify({ error: 'Failed to create task: ' + error.message })
        };
    }
}

// Create manual action in FUB
async function createManualAction(params, headers) {
    try {
        const { personId, actionType, assignedTo, urgency, notes } = params;

        const now = new Date();
        let dueDate = new Date(now);
        
        switch (urgency) {
            case 'IMMEDIATE':
                dueDate.setHours(now.getHours() + 24);
                break;
            case 'SAME_DAY':
                dueDate.setHours(23, 59, 59);
                break;
            case 'NEXT_DAY':
                dueDate.setDate(now.getDate() + 1);
                break;
            case 'WEEKLY':
                dueDate.setDate(now.getDate() + 7);
                break;
            default:
                dueDate.setDate(now.getDate() + 1);
        }

        // Map action types to FUB task types
        const taskTypeMap = {
            'Task': 'Follow Up',
            'Call': 'Call',
            'Email': 'Email',
            'Text': 'Text',
            'Note': 'Note'
        };
        
        const fubType = taskTypeMap[actionType] || 'Follow Up';
        
        // If it's a Note, use /v1/notes endpoint, otherwise use /v1/tasks
        if (actionType === 'Note') {
            const notePayload = {
                personId: parseInt(personId),
                subject: `${urgency} Action`,
                body: `${notes}\n\nAssigned to: ${assignedTo}`,
                isHtml: false
            };
            await fubAPIRequest('POST', '/v1/notes', notePayload);
        } else {
            // FUB tasks API doesn't accept description field
            const taskPayload = {
                personId: parseInt(personId),
                type: fubType,
                dueDate: dueDate.toISOString()
            };
            await fubAPIRequest('POST', '/v1/tasks', taskPayload);
            
            // Add action details as a note
            const notePayload = {
                personId: parseInt(personId),
                subject: `${fubType} Action`,
                body: `${notes}\n\nAssigned to: ${assignedTo}\nUrgency: ${urgency}`,
                isHtml: false
            };
            await fubAPIRequest('POST', '/v1/notes', notePayload);
        }

        return {
            statusCode: 200,
            headers,
            body: JSON.stringify({ success: true })
        };

    } catch (error) {
        return {
            statusCode: 500,
            headers,
            body: JSON.stringify({ error: 'Failed to create action: ' + error.message })
        };
    }
}

// FUB API Request Helper
function fubAPIRequest(method, path, data = null) {
    return new Promise((resolve, reject) => {
        const options = {
            hostname: 'api.followupboss.com',
            port: 443,
            path: path,
            method: method,
            headers: {
                'Authorization': `Basic ${Buffer.from(FUB_API_KEY + ':').toString('base64')}`,
                'Content-Type': 'application/json'
            }
        };

        const req = https.request(options, (res) => {
            let body = '';
            res.on('data', (chunk) => body += chunk);
            res.on('end', () => {
                try {
                    const parsed = JSON.parse(body);
                    if (res.statusCode >= 200 && res.statusCode < 300) {
                        resolve(parsed);
                    } else {
                        reject(new Error(`FUB API error: ${res.statusCode} - ${body}`));
                    }
                } catch (e) {
                    reject(new Error(`Failed to parse FUB response: ${body}`));
                }
            });
        });

        req.on('error', reject);
        
        if (data) {
            req.write(JSON.stringify(data));
        }
        
        req.end();
    });
}

// CloudCMA API Request Helper
function cloudCMAAPIRequest(method, path, data = null) {
    return new Promise((resolve, reject) => {
        const options = {
            hostname: 'cloudcma.com',
            port: 443,
            path: path,
            method: method,
            headers: {
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            }
        };

        const req = https.request(options, (res) => {
            let body = '';
            res.on('data', (chunk) => body += chunk);
            res.on('end', () => {
                try {
                    const parsed = body ? JSON.parse(body) : {};
                    if (res.statusCode >= 200 && res.statusCode < 300) {
                        resolve(parsed);
                    } else {
                        reject(new Error(`CloudCMA API error: ${res.statusCode} - ${body}`));
                    }
                } catch (e) {
                    if (res.statusCode >= 200 && res.statusCode < 300) {
                        resolve({});
                    } else {
                        reject(new Error(`Failed to parse CloudCMA response: ${body}`));
                    }
                }
            });
        });

        req.on('error', reject);
        
        if (data) {
            req.write(JSON.stringify(data));
        }
        
        req.end();
    });
}
